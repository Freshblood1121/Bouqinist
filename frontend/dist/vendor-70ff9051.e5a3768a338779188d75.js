"use strict";(self.webpackChunkelder_books_fe=self.webpackChunkelder_books_fe||[]).push([[584],{1300:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ep: () => (/* binding */ createPath),\n/* harmony export */   J0: () => (/* binding */ invariant),\n/* harmony export */   OF: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   RQ: () => (/* binding */ joinPaths),\n/* harmony export */   WK: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   X3: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Zn: () => (/* binding */ stripBasename),\n/* harmony export */   Zq: () => (/* binding */ getPathContributingMatches),\n/* harmony export */   aU: () => (/* binding */ Action),\n/* harmony export */   cP: () => (/* binding */ parsePath),\n/* harmony export */   fp: () => (/* binding */ matchRoutes),\n/* harmony export */   lX: () => (/* binding */ createBrowserHistory),\n/* harmony export */   p7: () => (/* binding */ createRouter),\n/* harmony export */   pC: () => (/* binding */ resolveTo),\n/* harmony export */   uX: () => (/* binding */ redirect)\n/* harmony export */ });\n/* unused harmony exports IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, UNSAFE_DeferredData, UNSAFE_convertRouteMatchToUiMatch, UNSAFE_convertRoutesToDataRoutes, UNSAFE_warning, createHashHistory, createMemoryHistory, createStaticHandler, defer, generatePath, getStaticContextFromError, getToPathname, isDeferredData, json, matchPath, normalizePathname, redirectDocument, resolvePath */\n/* provided dependency */ var console = __webpack_require__(1283);\n/**\n * @remix-run/router v1.9.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action["Pop"] = "POP";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action["Push"] = "PUSH";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action["Replace"] = "REPLACE";\n})(Action || (Action = {}));\nconst PopStateEventType = "popstate";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = ["/"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);\n    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === "string" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), "http://localhost");\n    },\n    encodeLocation(to) {\n      let path = typeof to === "string" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || "",\n        search: path.search || "",\n        hash: path.hash || ""\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation("", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === "string" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don\'t want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = "/",\n      search = "",\n      hash = ""\n    } = parsePath(window.location.hash.substr(1));\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path="*">) since that matches internally against\n    // "/*" and we\'d expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {\n      pathname = "/" + pathname;\n    }\n    return createLocation("", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector("base");\n    let href = "";\n    if (base && base.getAttribute("href")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf("#");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + "#" + (typeof to === "string" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === "undefined") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== "undefined") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling "pause on exceptions" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === "string" ? current : current.pathname,\n    search: "",\n    hash: ""\n  }, typeof to === "string" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that\'s a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = "/",\n    search = "",\n    hash = ""\n  } = _ref;\n  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;\n  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf("#");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf("?");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it\'s because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), "");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, "", url);\n    } catch (error) {\n      // If the exception is because `state` can\'t be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === "DataCloneError") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, "", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is "null" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;\n    let href = typeof to === "string" ? to : createPath(to);\n    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error("A history only accepts one active listener");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType["data"] = "data";\n  ResultType["deferred"] = "deferred";\n  ResultType["redirect"] = "redirect";\n  ResultType["error"] = "error";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject\'s within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === "string" ? route.id : treePath.join("-");\n    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");\n    invariant(!manifest[id], "Found a route id collision on id \\"" + id + "\\".  Route " + "id\'s must be globally unique within Data Router usages");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = "/";\n  }\n  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || "/", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i],\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won\'t be\n    // encoded here but there also shouldn\'t be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    safelyDecodeURI(pathname));\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = "";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || "" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith("/")) {\n      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \\"" + meta.relativePath + "\\" nested under path " + ("\\"" + parentPath + "\\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the "flattened" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \\"" + path + "\\"."));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn\'t ever match by themselves unless they are\n    // index routes, so don\'t add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split("/");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith("?");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, "");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, ""] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join("/"));\n  let result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === "*";\nfunction computeScore(path, index) {\n  let segments = path.split("/");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn\'t really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = "/";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== "/") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {\n    warning(false, "Route path \\"" + path + "\\" will be treated as if it were " + ("\\"" + path.replace(/\\*$/, "/*") + "\\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \\"" + path.replace(/\\*$/, "/*") + "\\"."));\n    path = path.replace(/\\*$/, "/*");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith("/") ? "/" : "";\n  const stringify = p => p == null ? "" : typeof p === "string" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    // only apply the splat if it\'s the last segment\n    if (isLastSegment && segment === "*") {\n      const star = "*";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === "?" || param != null, "Missing \\":" + key + "\\" param");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, "");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join("/");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === "string") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, "$1");\n  let captureGroups = match.slice(1);\n  let params = paramNames.reduce((memo, paramName, index) => {\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params["*"] later because it will be decoded then\n    if (paramName === "*") {\n      let splatValue = captureGroups[index] || "";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, "$1");\n    }\n    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \\"" + path + "\\" will be treated as if it were " + ("\\"" + path.replace(/\\*$/, "/*") + "\\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \\"" + path.replace(/\\*$/, "/*") + "\\"."));\n  let paramNames = [];\n  let regexpSource = "^" + path.replace(/\\/*\\*?$/, "") // Ignore trailing / and /*, we\'ll handle it below\n  .replace(/^\\/*/, "/") // Make sure it has a leading /\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, "\\\\$&") // Escape special regex chars\n  .replace(/\\/:(\\w+)/g, (_, paramName) => {\n    paramNames.push(paramName);\n    return "/([^\\\\/]+)";\n  });\n  if (path.endsWith("*")) {\n    paramNames.push("*");\n    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest\n    : "(?:\\\\/(.+)|\\\\/*)$"; // Don\'t include the / in params["*"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += "\\\\/*$";\n  } else if (path !== "" && path !== "/") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we\'ve matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += "(?:(?=\\\\/|$))";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");\n  return [matcher, paramNames];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, "The URL path \\"" + value + "\\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, "The value for the URL param \\"" + paramName + "\\" will not be decoded because" + (" the string \\"" + value + "\\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === "/") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user\'s control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== "/") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || "/";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = "/";\n  }\n  let {\n    pathname: toPathname,\n    search = "",\n    hash = ""\n  } = typeof to === "string" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, "").split("/");\n  let relativeSegments = relativePath.split("/");\n  relativeSegments.forEach(segment => {\n    if (segment === "..") {\n      // Keep the root "" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== ".") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join("/") : "/";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return "Cannot include a \'" + char + "\' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\\"...\\"> and the router will parse it for you.";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don\'t\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path="/">\n *     <Route path="accounts" element={<Link to=".."}>\n *   </Route>\n *\n *   <Route path="/">\n *     <Route path="accounts">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=".."} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === "string") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));\n    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));\n    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));\n  }\n  let isEmptyPath = toArg === "" || to.pathname === "";\n  let toPathname = isEmptyPath ? "/" : to.pathname;\n  let from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location\'s pathname and *not* the route pathname.\n  if (isPathRelative || toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith("..")) {\n      let toSegments = toPathname.split("/");\n      // Each leading .. segment means "go up one route" instead of "go up one\n      // URL segment".  This is a key difference from how <a href> works and a\n      // major reason we call this a "to" value instead of a "href".\n      while (toSegments[0] === "..") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join("/");\n    }\n    // If there are more ".." segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";\n  }\n  let path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original "to" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");\n  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += "/";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nconst joinPaths = paths => paths.join("/").replace(/\\/\\/+/g, "/");\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, "").replace(/^\\/*/, "/");\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === "number" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has("Content-Type")) {\n    headers.set("Content-Type", "application/json; charset=utf-8");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);\n    this.controller.signal.addEventListener("abort", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref) => {\n      let [key, value] = _ref;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, "_tracked", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, "_error", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n    // If the promise was resolved/rejected with undefined, we\'ll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error("Deferred data for key \\"" + key + "\\" resolved/rejected with `undefined`, " + "you must resolve/reject with a value or `null`.");\n      Object.defineProperty(promise, "_error", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, "_error", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, "_data", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener("abort", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener("abort", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");\n    return Object.entries(this.data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === "number" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to "302 Found".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === "number") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === "undefined") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set("Location", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to "302 Found".\n */\nconst redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set("X-Remix-Reload-Document", "true");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */\nclass ErrorResponseImpl {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || "";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;\n}\nconst validMutationMethodsArr = ["post", "put", "patch", "delete"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = ["get", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: "idle",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: "idle",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: "unblocked",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : undefined;\n  const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || "/";\n  // Config driven behavior flags\n  let future = _extends({\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don\'t get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR\'d and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized =\n  // All initialMatches need to be loaded before we\'re ready.  If we have lazy\n  // functions around still then we\'ll need to run them in initialize()\n  !initialMatches.some(m => m.route.lazy) && (\n  // And we have to either have no loaders or have been provided hydrationData\n  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don\'t restore on initial updateState() if we were SSR\'d\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: "idle",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don\'t need to update UI state if they change\n  let blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We\'ll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don\'t update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: "blocked",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: "proceeding",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don\'t do any handling of lazy here.  For SPA\'s it\'ll get handled\n    // in the normal navigation flow.  For SSR it\'s expected that lazy modules are\n    // resolved prior to router creation since we can\'t go into a fallbackElement\n    // UI for SSR\'d apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location);\n    }\n    return router;\n  }\n  // Clean up a router and it\'s side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState) {\n    state = _extends({}, state, newState);\n    subscribers.forEach(subscriber => subscriber(state));\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState) {\n    var _location$state, _location$state2;\n    // Deduce if we\'re in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We\'re past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we\'re wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    // Always respect the user flag.  Otherwise don\'t reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: "idle",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }));\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === "number") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    // When using navigate as a PUSH/REPLACE we aren\'t reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we\'d get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don\'t have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: "blocked",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: "proceeding",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace\n    });\n  }\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to "succeed" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: "loading"\n    });\n    // If we\'re currently submitting an action, we don\'t need to start a new\n    // navigation, we\'ll just let the follow up loader execution call all loaders\n    if (state.navigation.state === "submitting") {\n      return;\n    }\n    // If we\'re currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === "idle") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we\'re currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don\'t keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      });\n      return;\n    }\n    // Short circuit if it\'s only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be "same hash".  For example, on /page#hash and submit a <Form method="post">\n    // which will default to a navigation to /page\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      });\n      return;\n    }\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It\'s not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      // Create a GET request for the loaders\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    // Call loaders\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    // Clean up now that the action/loaders have completed.  Don\'t clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    });\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn\'t explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we\'re currently at to avoid\n        // double back-buttons\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that\'ll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: "defer-action"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    // If this was a redirect from an action we don\'t have a "submission" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    // Cancel pending deferreds for no-longer-matched routes or routes we\'re\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we\'re short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n      return {\n        shortCircuited: true\n      };\n    }\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(rf => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n    }\n    revalidatingFetchers.forEach(rf => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    // Clean up _after_ loaders have completed.  Don\'t clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn\'t get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  function getFetcher(key) {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error("router.fetch() was called during the server render, but it shouldn\'t be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }));\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error);\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, submission);\n      return;\n    }\n    // Store off the match so we can call it\'s shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId\n      });\n      setFetcherError(key, routeId, error);\n      return;\n    }\n    // Put this fetcher into it\'s submitting state\n    let existingFetcher = state.fetchers.get(key);\n    let fetcher = getSubmittingFetcher(submission, existingFetcher);\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren\'t aborted by ou our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        let loadingFetcher = getLoadingFetcher(submission);\n        state.fetchers.set(key, loadingFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: "defer-action"\n      });\n    }\n    // Start the data load for current matches, or the next location if we\'re\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, "Didn\'t find any matches after fetcher action");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n      [match.route.id]: actionResult.data\n    }, undefined // No need to send through errors since we short circuit above\n    );\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it\'s current loading state which\n    // contains it\'s action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn\'t get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn\'t been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, "Expected pending action");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren\'t going through completeNavigation\n      updateState(_extends({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)\n      }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n      isRevalidationRequired = false;\n    }\n  }\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    // Put this fetcher into it\'s loading state\n    let loadingFetcher = getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined);\n    state.fetchers.set(key, loadingFetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n    // Deferred isn\'t supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n    // We can delete this so long as we weren\'t aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\n      state.fetchers.delete(key);\n      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n      // do we need to behave any differently with our non-redirect errors?\n      // What if it was a non-redirect Response?\n      updateState({\n        fetchers: new Map(state.fetchers),\n        errors: {\n          [boundaryMatch.route.id]: result.error\n        }\n      });\n      return;\n    }\n    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");\n    // Put the fetcher back into an idle state\n    let doneFetcher = getDoneFetcher(result.data);\n    state.fetchers.set(key, doneFetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect "replaces" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we\'ve processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(state, redirect, _temp) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp === void 0 ? {} : _temp;\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state.location, redirect.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, "Expected a location on the redirect navigation");\n    if (isBrowser) {\n      let isDocumentReload = false;\n      if (redirect.reloadDocument) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n        const url = init.history.createURL(redirect.location);\n        isDocumentReload =\n        // Hard reload if it\'s an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin ||\n        // Hard reload if it\'s an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n    // There\'s no need to abort on redirects, since we don\'t detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map(f => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function setFetcherError(key, routeId, error) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don\'t abort the controller if this is a deletion of a fetcher.submit()\n    // in it\'s loading phase since - we don\'t want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, "Expected fetch controller: " + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, "Expected fetcher: " + key);\n      if (fetcher.state === "loading") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, "Expected fetcher: " + key);\n        if (fetcher.state === "loading") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don\'t have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, "A router only supports one blocker at a time");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === "proceeding") {\n      // If the blocker is currently proceeding, we don\'t need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we\'re unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we\'ve not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === "number") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it\'s temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || "/";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(request, _temp2) {\n    let {\n      requestContext\n    } = _temp2 === void 0 ? {} : _temp2;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation("", createPath(url), null, "default");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn\'t\n    if (!isValidMethod(method) && method !== "HEAD") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(request, _temp3) {\n    let {\n      routeId,\n      requestContext\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation("", createPath(url), null, "default");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn\'t\n    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don\'t think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn\'t a Response, but it\'s not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the "error" state outside of queryImpl.\n      throw error;\n    }\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, routeMatch) {\n    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don\'t propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n        isStaticRequest: true,\n        isRouteRequest,\n        requestContext\n      });\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? "queryRoute" : "query";\n        throw new Error(method + "() call aborted: " + request.method + " " + request.url);\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the "throw all redirect responses" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: "defer-action"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(request, matches, requestContext, undefined, {\n        [boundaryMatch.route.id]: result.error\n      });\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n    return _extends({}, context, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      actionHeaders: _extends({}, result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {})\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n    let isRouteRequest = routeMatch != null;\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, {\n      isStaticRequest: true,\n      isRouteRequest,\n      requestContext\n    }))]);\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? "queryRoute" : "query";\n      throw new Error(method + "() call aborted: " + request.method + " " + request.url);\n    }\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId != null && relative !== "path") {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route.  When using relative:path,\n    // fromRouteId is ignored since that is always relative to the current\n    // location path\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  let path = resolveTo(to ? to : ".", getPathContributingMatches(contextualMatches).map(m => m.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === "path");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to="." and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Add an ?index param for matched index routes if we don\'t already have one\n  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, "?index&") : "?index";\n  }\n  // If we\'re operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== "/") {\n    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: "invalid-body"\n    })\n  });\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || "get";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === "text/plain") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n        let [name, value] = _ref3;\n        return "" + acc + name + "=" + value + "\\n";\n      }, "") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === "application/json") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === "function", "FormData is not available in this environment");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append("index", "");\n  }\n  parsedPath.search = "?" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n// Filter out all routes below any caught error as they aren\'t going to\n// render so we don\'t need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex(m => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven\'t loaded this route yet so we don\'t know if it\'s got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it\'s own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate:\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired ||\n      // Clicked the same link, resubmitted a GET form\n      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don\'t revalidate if fetcher won\'t be present in the subsequent render\n    if (!matches.some(m => m.route.id === f.routeId)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === undefined) {\n      // If the fetcher hasn\'t ever completed loading yet, then this isn\'t a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don\'t have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don\'t yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === "boolean") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, "No route found in manifest");\n  // Update the route in place.  This should be safe because there\'s no way\n  // we could yet be sitting on this route as we can\'t get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR "update" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to "does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn\'t static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== "hasErrorBoundary";\n    warning(!isPropertyStaticallyDefined, "Route \\"" + routeToUpdate.id + "\\" has a static property \\"" + lazyRouteProperty + "\\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \\"" + lazyRouteProperty + "\\" will be ignored."));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don\'t resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener("abort", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let values = await Promise.all([\n        // If the handler throws, don\'t let it immediately bubble out,\n        // since we need to let the lazy() execution finish so we know if this\n        // route has a boundary that can handle the error\n        runHandler(handler).catch(e => {\n          handlerError = e;\n        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === "action") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don\'t\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            data: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\\"" + match.route.id + "\\" but didn\'t return anything from your `" + type + "` ") + "function. Please return a value or `null`.");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener("abort", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get("Location");\n      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      // Don\'t process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set("Location", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get("X-Remix-Revalidate") !== null,\n        reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null\n      };\n    }\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    let contentType = result.headers.get("Content-Type");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn\'t think we needed this but it turns out unlike other methods, patch\n    // won\'t be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === "application/json") {\n      init.headers = new Headers({\n        "Content-Type": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === "text/plain") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === "string" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  // If we didn\'t consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");\n    let result = fetcherResults[index];\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, "Unhandled fetcher revalidation redirect");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, "Unhandled fetcher deferred data");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn\'t removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don\'t keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.find(r => r.index || !r.path || r.path === "/") || {\n    id: "__shim-error-route__"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: "",\n      pathnameBase: "",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp4) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp4 === void 0 ? {} : _temp4;\n  let statusText = "Unknown Server Error";\n  let errorMessage = "Unknown @remix-run/router error";\n  if (status === 400) {\n    statusText = "Bad Request";\n    if (method && pathname && routeId) {\n      errorMessage = "You made a " + method + " request to \\"" + pathname + "\\" but " + ("did not provide a `loader` for route \\"" + routeId + "\\", ") + "so there is no way to handle the request.";\n    } else if (type === "defer-action") {\n      errorMessage = "defer() is not supported in actions";\n    } else if (type === "invalid-body") {\n      errorMessage = "Unable to encode submission body";\n    }\n  } else if (status === 403) {\n    statusText = "Forbidden";\n    errorMessage = "Route \\"" + routeId + "\\" does not match URL \\"" + pathname + "\\"";\n  } else if (status === 404) {\n    statusText = "Not Found";\n    errorMessage = "No route matches URL \\"" + pathname + "\\"";\n  } else if (status === 405) {\n    statusText = "Method Not Allowed";\n    if (method && pathname && routeId) {\n      errorMessage = "You made a " + method.toUpperCase() + " request to \\"" + pathname + "\\" but " + ("did not provide an `action` for route \\"" + routeId + "\\", ") + "so there is no way to handle the request.";\n    } else if (method) {\n      errorMessage = "Invalid request method \\"" + method.toUpperCase() + "\\"";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === "string" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: ""\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === "") {\n    // /page -> /page#hash\n    return b.hash !== "";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== "") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get("Location");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don\'t have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they\'ll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll("index").some(v => v === "");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === "string" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest "path contributing" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: "loading",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: "loading",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: "submitting",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: "loading",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: "loading",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: "submitting",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: "idle",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data\n  };\n  return fetcher;\n}\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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N0UsSUFBSSxFQUFFc0ssVUFBVSxDQUFDdEssSUFBSTtJQUNyQjhFLElBQUksRUFBRXdGLFVBQVUsQ0FBQ3hGLElBQUk7SUFDckI5TCxJQUFJLEVBQUUyVixlQUFlLEdBQUdBLGVBQWUsQ0FBQzNWLElBQUksR0FBRy9IO0dBQ2hEO0VBQ0QsT0FBT21jLE9BQU87QUFDaEI7QUFFQSxTQUFTOEIsY0FBY0EsQ0FBQ2xXLElBQXFCO0VBQzNDLElBQUlvVSxPQUFPLEdBQTBCO0lBQ25DcGMsS0FBSyxFQUFFLE1BQU07SUFDYjBULFVBQVUsRUFBRXpULFNBQVM7SUFDckIwVCxVQUFVLEVBQUUxVCxTQUFTO0lBQ3JCMlQsV0FBVyxFQUFFM1QsU0FBUztJQUN0QjRULFFBQVEsRUFBRTVULFNBQVM7SUFDbkIrTyxJQUFJLEVBQUUvTyxTQUFTO0lBQ2Y2VCxJQUFJLEVBQUU3VCxTQUFTO0lBQ2YrSDtHQUNEO0VBQ0QsT0FBT29VLE9BQU87QUFDaEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4uL2hpc3RvcnkudHM/NzFmOSIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uLi91dGlscy50cz9hYzExIiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4uL3JvdXRlci50cz9hNjQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cbiAqL1xuZXhwb3J0IGVudW0gQWN0aW9uIHtcbiAgLyoqXG4gICAqIEEgUE9QIGluZGljYXRlcyBhIGNoYW5nZSB0byBhbiBhcmJpdHJhcnkgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2hcbiAgICogYXMgYSBiYWNrIG9yIGZvcndhcmQgbmF2aWdhdGlvbi4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICogbmF2aWdhdGlvbiwgb25seSB0aGF0IHRoZSBjdXJyZW50IGluZGV4IGNoYW5nZWQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBuZXdseSBjcmVhdGVkIGhpc3Rvcnkgb2JqZWN0cy5cbiAgICovXG4gIFBvcCA9IFwiUE9QXCIsXG5cbiAgLyoqXG4gICAqIEEgUFVTSCBpbmRpY2F0ZXMgYSBuZXcgZW50cnkgYmVpbmcgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2ggYXMgd2hlblxuICAgKiBhIGxpbmsgaXMgY2xpY2tlZCBhbmQgYSBuZXcgcGFnZSBsb2Fkcy4gV2hlbiB0aGlzIGhhcHBlbnMsIGFsbCBzdWJzZXF1ZW50XG4gICAqIGVudHJpZXMgaW4gdGhlIHN0YWNrIGFyZSBsb3N0LlxuICAgKi9cbiAgUHVzaCA9IFwiUFVTSFwiLFxuXG4gIC8qKlxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXG4gICAqL1xuICBSZXBsYWNlID0gXCJSRVBMQUNFXCIsXG59XG5cbi8qKlxuICogVGhlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIHZhbHVlcyBvZiBhIFVSTC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoIHtcbiAgLyoqXG4gICAqIEEgVVJMIHBhdGhuYW1lLCBiZWdpbm5pbmcgd2l0aCBhIC8uXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIFVSTCBzZWFyY2ggc3RyaW5nLCBiZWdpbm5pbmcgd2l0aCBhID8uXG4gICAqL1xuICBzZWFyY2g6IHN0cmluZztcblxuICAvKipcbiAgICogQSBVUkwgZnJhZ21lbnQgaWRlbnRpZmllciwgYmVnaW5uaW5nIHdpdGggYSAjLlxuICAgKi9cbiAgaGFzaDogc3RyaW5nO1xufVxuXG4vLyBUT0RPOiAodjcpIENoYW5nZSB0aGUgTG9jYXRpb24gZ2VuZXJpYyBkZWZhdWx0IGZyb20gYGFueWAgdG8gYHVua25vd25gIGFuZFxuLy8gcmVtb3ZlIFJlbWl4IGB1c2VMb2NhdGlvbmAgd3JhcHBlci5cblxuLyoqXG4gKiBBbiBlbnRyeSBpbiBhIGhpc3Rvcnkgc3RhY2suIEEgbG9jYXRpb24gY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBVUkwgcGF0aCwgYXMgd2VsbCBhcyBwb3NzaWJseSBzb21lIGFyYml0cmFyeSBzdGF0ZSBhbmQgYSBrZXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb248U3RhdGUgPSBhbnk+IGV4dGVuZHMgUGF0aCB7XG4gIC8qKlxuICAgKiBBIHZhbHVlIG9mIGFyYml0cmFyeSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLlxuICAgKi9cbiAgc3RhdGU6IFN0YXRlO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbG9jYXRpb24uIE1heSBiZSB1c2VkIHRvIHNhZmVseSBzdG9yZVxuICAgKiBhbmQgcmV0cmlldmUgZGF0YSBpbiBzb21lIG90aGVyIHN0b3JhZ2UgQVBJLCBsaWtlIGBsb2NhbFN0b3JhZ2VgLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIHZhbHVlIGlzIGFsd2F5cyBcImRlZmF1bHRcIiBvbiB0aGUgaW5pdGlhbCBsb2NhdGlvbi5cbiAgICovXG4gIGtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY2hhbmdlIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBjaGFuZ2UuXG4gICAqL1xuICBhY3Rpb246IEFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIG5ldyBsb2NhdGlvbi5cbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogVGhlIGRlbHRhIGJldHdlZW4gdGhpcyBsb2NhdGlvbiBhbmQgdGhlIGZvcm1lciBsb2NhdGlvbiBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKi9cbiAgZGVsdGE6IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIG5vdGlmaWNhdGlvbnMgYWJvdXQgbG9jYXRpb24gY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5lciB7XG4gICh1cGRhdGU6IFVwZGF0ZSk6IHZvaWQ7XG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgbG9jYXRpb24gdGhhdCBpcyB0aGUgZGVzdGluYXRpb24gb2Ygc29tZSBuYXZpZ2F0aW9uLCBlaXRoZXIgdmlhXG4gKiBgaGlzdG9yeS5wdXNoYCBvciBgaGlzdG9yeS5yZXBsYWNlYC4gVGhpcyBtYXkgYmUgZWl0aGVyIGEgVVJMIG9yIHRoZSBwaWVjZXNcbiAqIG9mIGEgVVJMIHBhdGguXG4gKi9cbmV4cG9ydCB0eXBlIFRvID0gc3RyaW5nIHwgUGFydGlhbDxQYXRoPjtcblxuLyoqXG4gKiBBIGhpc3RvcnkgaXMgYW4gaW50ZXJmYWNlIHRvIHRoZSBuYXZpZ2F0aW9uIHN0YWNrLiBUaGUgaGlzdG9yeSBzZXJ2ZXMgYXMgdGhlXG4gKiBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBhcyB3ZWxsIGFzIHByb3ZpZGVzIGEgc2V0IG9mXG4gKiBtZXRob2RzIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hhbmdlIGl0LlxuICpcbiAqIEl0IGlzIHNpbWlsYXIgdG8gdGhlIERPTSdzIGB3aW5kb3cuaGlzdG9yeWAgb2JqZWN0LCBidXQgd2l0aCBhIHNtYWxsZXIsIG1vcmVcbiAqIGZvY3VzZWQgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhpc3Rvcnkge1xuICAvKipcbiAgICogVGhlIGxhc3QgYWN0aW9uIHRoYXQgbW9kaWZpZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgd2lsbCBhbHdheXMgYmVcbiAgICogQWN0aW9uLlBvcCB3aGVuIGEgaGlzdG9yeSBpbnN0YW5jZSBpcyBmaXJzdCBjcmVhdGVkLiBUaGlzIHZhbHVlIGlzIG11dGFibGUuXG4gICAqL1xuICByZWFkb25seSBhY3Rpb246IEFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgdmFsdWUgaXMgbXV0YWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbGlkIGhyZWYgZm9yIHRoZSBnaXZlbiBgdG9gIHZhbHVlIHRoYXQgbWF5IGJlIHVzZWQgYXNcbiAgICogdGhlIHZhbHVlIG9mIGFuIDxhIGhyZWY+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIGRlc3RpbmF0aW9uIFVSTFxuICAgKi9cbiAgY3JlYXRlSHJlZih0bzogVG8pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBVUkwgZm9yIHRoZSBnaXZlbiBgdG9gIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAgICovXG4gIGNyZWF0ZVVSTCh0bzogVG8pOiBVUkw7XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIGxvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cuaGlzdG9yeSB3b3VsZCBkbyAobm8tb3AgZm9yIG1lbW9yeVxuICAgKiBoaXN0b3J5KSBzbyB3ZSBlbnN1cmUgb3VyIFBVU0gvUkVQTEFDRSBuYXZpZ2F0aW9ucyBmb3IgZGF0YSByb3V0ZXJzXG4gICAqIGJlaGF2ZSB0aGUgc2FtZSBhcyBQT1BcbiAgICpcbiAgICogQHBhcmFtIHRvIFVuZW5jb2RlZCBwYXRoXG4gICAqL1xuICBlbmNvZGVMb2NhdGlvbih0bzogVG8pOiBQYXRoO1xuXG4gIC8qKlxuICAgKiBQdXNoZXMgYSBuZXcgbG9jYXRpb24gb250byB0aGUgaGlzdG9yeSBzdGFjaywgaW5jcmVhc2luZyBpdHMgbGVuZ3RoIGJ5IG9uZS5cbiAgICogSWYgdGhlcmUgd2VyZSBhbnkgZW50cmllcyBpbiB0aGUgc3RhY2sgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLCB0aGV5IGFyZVxuICAgKiBsb3N0LlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbmV3IFVSTFxuICAgKiBAcGFyYW0gc3RhdGUgLSBEYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgbG9jYXRpb25cbiAgICovXG4gIHB1c2godG86IFRvLCBzdGF0ZT86IGFueSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBoaXN0b3J5IHN0YWNrIHdpdGggYSBuZXcgb25lLiAgVGhlXG4gICAqIGxvY2F0aW9uIHRoYXQgd2FzIHJlcGxhY2VkIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIG5ldyBVUkxcbiAgICogQHBhcmFtIHN0YXRlIC0gRGF0YSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbmV3IGxvY2F0aW9uXG4gICAqL1xuICByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZXMgYG5gIGVudHJpZXMgYmFja3dhcmQvZm9yd2FyZCBpbiB0aGUgaGlzdG9yeSBzdGFjayByZWxhdGl2ZSB0byB0aGVcbiAgICogY3VycmVudCBpbmRleC4gRm9yIGV4YW1wbGUsIGEgXCJiYWNrXCIgbmF2aWdhdGlvbiB3b3VsZCB1c2UgZ28oLTEpLlxuICAgKlxuICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgZGVsdGEgaW4gdGhlIHN0YWNrIGluZGV4XG4gICAqL1xuICBnbyhkZWx0YTogbnVtYmVyKTogdm9pZDtcblxuICAvKipcbiAgICogU2V0cyB1cCBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICogY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXNcbiAgICogQHJldHVybnMgdW5saXN0ZW4gLSBBIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gc3RvcCBsaXN0ZW5pbmdcbiAgICovXG4gIGxpc3RlbihsaXN0ZW5lcjogTGlzdGVuZXIpOiAoKSA9PiB2b2lkO1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9IHtcbiAgdXNyOiBhbnk7XG4gIGtleT86IHN0cmluZztcbiAgaWR4OiBudW1iZXI7XG59O1xuXG5jb25zdCBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIE1lbW9yeSBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgdXNlci1zdXBwbGllZCBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBsb2NhdGlvbi4gVXNlZCB3aGVuIHByb3ZpZGluZ1xuICogZW50cmllcyB0byBgY3JlYXRlTWVtb3J5SGlzdG9yeWAgdmlhIGl0cyBgaW5pdGlhbEVudHJpZXNgIG9wdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgSW5pdGlhbEVudHJ5ID0gc3RyaW5nIHwgUGFydGlhbDxMb2NhdGlvbj47XG5cbmV4cG9ydCB0eXBlIE1lbW9yeUhpc3RvcnlPcHRpb25zID0ge1xuICBpbml0aWFsRW50cmllcz86IEluaXRpYWxFbnRyeVtdO1xuICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG4gIHY1Q29tcGF0PzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogQSBtZW1vcnkgaGlzdG9yeSBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS4gVGhpcyBpcyB1c2VmdWwgaW4gc3RhdGVmdWxcbiAqIGVudmlyb25tZW50cyB3aGVyZSB0aGVyZSBpcyBubyB3ZWIgYnJvd3Nlciwgc3VjaCBhcyBub2RlIHRlc3RzIG9yIFJlYWN0XG4gKiBOYXRpdmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb3J5SGlzdG9yeSBleHRlbmRzIEhpc3Rvcnkge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICByZWFkb25seSBpbmRleDogbnVtYmVyO1xufVxuXG4vKipcbiAqIE1lbW9yeSBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBtZW1vcnkuIEl0IGlzIGRlc2lnbmVkIGZvciB1c2VcbiAqIGluIHN0YXRlZnVsIG5vbi1icm93c2VyIGVudmlyb25tZW50cyBsaWtlIHRlc3RzIGFuZCBSZWFjdCBOYXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KFxuICBvcHRpb25zOiBNZW1vcnlIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBNZW1vcnlIaXN0b3J5IHtcbiAgbGV0IHsgaW5pdGlhbEVudHJpZXMgPSBbXCIvXCJdLCBpbml0aWFsSW5kZXgsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzOiBMb2NhdGlvbltdOyAvLyBEZWNsYXJlIHNvIHdlIGNhbiBhY2Nlc3MgZnJvbSBjcmVhdGVNZW1vcnlMb2NhdGlvblxuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKChlbnRyeSwgaW5kZXgpID0+XG4gICAgY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgICBlbnRyeSxcbiAgICAgIHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiA/IG51bGwgOiBlbnRyeS5zdGF0ZSxcbiAgICAgIGluZGV4ID09PSAwID8gXCJkZWZhdWx0XCIgOiB1bmRlZmluZWRcbiAgICApXG4gICk7XG4gIGxldCBpbmRleCA9IGNsYW1wSW5kZXgoXG4gICAgaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXhcbiAgKTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lcjogTGlzdGVuZXIgfCBudWxsID0gbnVsbDtcblxuICBmdW5jdGlvbiBjbGFtcEluZGV4KG46IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIDApLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpOiBMb2NhdGlvbiB7XG4gICAgcmV0dXJuIGVudHJpZXNbaW5kZXhdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKFxuICAgIHRvOiBUbyxcbiAgICBzdGF0ZTogYW55ID0gbnVsbCxcbiAgICBrZXk/OiBzdHJpbmdcbiAgKTogTG9jYXRpb24ge1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgZW50cmllcyA/IGdldEN1cnJlbnRMb2NhdGlvbigpLnBhdGhuYW1lIDogXCIvXCIsXG4gICAgICB0byxcbiAgICAgIHN0YXRlLFxuICAgICAga2V5XG4gICAgKTtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3Rvcnk6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHRvXG4gICAgICApfWBcbiAgICApO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG86IFRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cblxuICBsZXQgaGlzdG9yeTogTWVtb3J5SGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlVVJMKHRvKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChjcmVhdGVIcmVmKHRvKSwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICAgIH0sXG4gICAgZW5jb2RlTG9jYXRpb24odG86IFRvKSB7XG4gICAgICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIHx8IFwiXCIsXG4gICAgICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCIsXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgZW50cmllc1tpbmRleF0gPSBuZXh0TG9jYXRpb247XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgICBsZXQgbmV4dEluZGV4ID0gY2xhbXBJbmRleChpbmRleCArIGRlbHRhKTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW4oZm46IExpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gQnJvd3NlciBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgYnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMgaW4gYSB3ZWJcbiAqIGJyb3dzZXIgZW52aXJvbm1lbnQuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvciBtb3N0IHdlYiBhcHBzIGFuZCBwcm92aWRlcyB0aGVcbiAqIGNsZWFuZXN0IFVSTHMgdGhlIGJyb3dzZXIncyBhZGRyZXNzIGJhci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2Jyb3dzZXJoaXN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3Nlckhpc3RvcnkgZXh0ZW5kcyBVcmxIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIEJyb3dzZXJIaXN0b3J5T3B0aW9ucyA9IFVybEhpc3RvcnlPcHRpb25zO1xuXG4vKipcbiAqIEJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcy4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yXG4gKiBtb3N0IHdlYiBhcHBzLCBidXQgaXQgcmVxdWlyZXMgc29tZSBjb25maWd1cmF0aW9uIG9uIHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIHlvdVxuICogc2VydmUgdGhlIHNhbWUgYXBwIGF0IG11bHRpcGxlIFVSTHMuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVicm93c2VyaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoXG4gIG9wdGlvbnM6IEJyb3dzZXJIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBCcm93c2VySGlzdG9yeSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbihcbiAgICB3aW5kb3c6IFdpbmRvdyxcbiAgICBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdXG4gICkge1xuICAgIGxldCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyKSB8fCBudWxsLFxuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkpIHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIcmVmKHdpbmRvdzogV2luZG93LCB0bzogVG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlQnJvd3NlckxvY2F0aW9uLFxuICAgIGNyZWF0ZUJyb3dzZXJIcmVmLFxuICAgIG51bGwsXG4gICAgb3B0aW9uc1xuICApO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGFzaCBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgaGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBwb3J0aW9uXG4gKiBvZiB0aGUgVVJMIGluIGEgd2ViIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gKlxuICogVGhpcyBpcyBpZGVhbCBmb3IgYXBwcyB0aGF0IGRvIG5vdCBjb250cm9sIHRoZSBzZXJ2ZXIgZm9yIHNvbWUgcmVhc29uXG4gKiAoYmVjYXVzZSB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBpcyBuZXZlciBzZW50IHRvIHRoZSBzZXJ2ZXIpLCBpbmNsdWRpbmcgc29tZVxuICogc2hhcmVkIGhvc3RpbmcgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHByb3ZpZGUgZmluZS1ncmFpbmVkIGNvbnRyb2xzIG92ZXJcbiAqIHdoaWNoIHBhZ2VzIGFyZSBzZXJ2ZWQgYXQgd2hpY2ggVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2hhc2hoaXN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaEhpc3RvcnkgZXh0ZW5kcyBVcmxIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIEhhc2hIaXN0b3J5T3B0aW9ucyA9IFVybEhpc3RvcnlPcHRpb25zO1xuXG4vKipcbiAqIEhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHdpbmRvdy5sb2NhdGlvbi5oYXNoLiBUaGlzIG1ha2VzIGl0IGlkZWFsXG4gKiBmb3Igc2l0dWF0aW9ucyB3aGVyZSB5b3UgZG9uJ3Qgd2FudCB0byBzZW5kIHRoZSBsb2NhdGlvbiB0byB0aGUgc2VydmVyIGZvclxuICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcbiAqIHJlc2VydmVkIGZvciBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShcbiAgb3B0aW9uczogSGFzaEhpc3RvcnlPcHRpb25zID0ge31cbik6IEhhc2hIaXN0b3J5IHtcbiAgZnVuY3Rpb24gY3JlYXRlSGFzaExvY2F0aW9uKFxuICAgIHdpbmRvdzogV2luZG93LFxuICAgIGdsb2JhbEhpc3Rvcnk6IFdpbmRvd1tcImhpc3RvcnlcIl1cbiAgKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCIsXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xuXG4gICAgLy8gSGFzaCBVUkwgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbGVhZGluZyAvIGp1c3QgbGlrZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVcbiAgICAvLyBkb2VzLCBzbyBpZiBhbiBhcHAgZW5kcyB1cCBhdCBhIHJvdXRlIGxpa2UgLyNzb21ldGhpbmcgdGhlbiB3ZSBhZGQgYVxuICAgIC8vIGxlYWRpbmcgc2xhc2ggc28gYWxsIG9mIG91ciBwYXRoLW1hdGNoaW5nIGJlaGF2ZXMgdGhlIHNhbWUgYXMgaWYgaXQgd291bGRcbiAgICAvLyBpbiBhIGJyb3dzZXIgcm91dGVyLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHkgaW1wb3J0YW50IHdoZW4gdGhlcmUgZXhpc3RzIGFcbiAgICAvLyByb290IHNwbGF0IHJvdXRlICg8Um91dGUgcGF0aD1cIipcIj4pIHNpbmNlIHRoYXQgbWF0Y2hlcyBpbnRlcm5hbGx5IGFnYWluc3RcbiAgICAvLyBcIi8qXCIgYW5kIHdlJ2QgZXhwZWN0IC8jc29tZXRoaW5nIHRvIDQwNCBpbiBhIGhhc2ggcm91dGVyIGFwcC5cbiAgICBpZiAoIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IpIHx8IG51bGwsXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93OiBXaW5kb3csIHRvOiBUbykge1xuICAgIGxldCBiYXNlID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcblxuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgbGV0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgbGV0IGhhc2hJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGhyZWYgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWYgKyBcIiNcIiArICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uOiBMb2NhdGlvbiwgdG86IFRvKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHRvXG4gICAgICApfSlgXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlSGFzaExvY2F0aW9uLFxuICAgIGNyZWF0ZUhhc2hIcmVmLFxuICAgIHZhbGlkYXRlSGFzaExvY2F0aW9uLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQodmFsdWU6IGJvb2xlYW4sIG1lc3NhZ2U/OiBzdHJpbmcpOiBhc3NlcnRzIHZhbHVlO1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudDxUPihcbiAgdmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBtZXNzYWdlPzogc3RyaW5nXG4pOiBhc3NlcnRzIHZhbHVlIGlzIFQ7XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlOiBhbnksIG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2UsIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXItYmFzZWQgaGlzdG9yaWVzLCB3ZSBjb21iaW5lIHRoZSBzdGF0ZSBhbmQga2V5IGludG8gYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbjogTG9jYXRpb24sIGluZGV4OiBudW1iZXIpOiBIaXN0b3J5U3RhdGUge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleCxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTG9jYXRpb24gb2JqZWN0IHdpdGggYSB1bmlxdWUga2V5IGZyb20gdGhlIGdpdmVuIFBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKFxuICBjdXJyZW50OiBzdHJpbmcgfCBMb2NhdGlvbixcbiAgdG86IFRvLFxuICBzdGF0ZTogYW55ID0gbnVsbCxcbiAga2V5Pzogc3RyaW5nXG4pOiBSZWFkb25seTxMb2NhdGlvbj4ge1xuICBsZXQgbG9jYXRpb246IFJlYWRvbmx5PExvY2F0aW9uPiA9IHtcbiAgICBwYXRobmFtZTogdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIgPyBjdXJyZW50IDogY3VycmVudC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IFwiXCIsXG4gICAgaGFzaDogXCJcIixcbiAgICAuLi4odHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvKSxcbiAgICBzdGF0ZSxcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNsZWFuZWQgdXAuICBwdXNoL3JlcGxhY2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgdGFrZVxuICAgIC8vIGZ1bGwgTG9jYXRpb25zIG5vdyBhbmQgYXZvaWQgdGhlIG5lZWQgdG8gcnVuIHRocm91Z2ggdGhpcyBmbG93IGF0IGFsbFxuICAgIC8vIEJ1dCB0aGF0J3MgYSBwcmV0dHkgYmlnIHJlZmFjdG9yIHRvIHRoZSBjdXJyZW50IHRlc3Qgc3VpdGUgc28gZ29pbmcgdG9cbiAgICAvLyBrZWVwIGFzIGlzIGZvciB0aGUgdGltZSBiZWluZyBhbmQganVzdCBsZXQgYW55IGluY29taW5nIGtleXMgdGFrZSBwcmVjZWRlbmNlXG4gICAga2V5OiAodG8gJiYgKHRvIGFzIExvY2F0aW9uKS5rZXkpIHx8IGtleSB8fCBjcmVhdGVLZXkoKSxcbiAgfTtcbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgVVJMIHBhdGggZnJvbSB0aGUgZ2l2ZW4gcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoe1xuICBwYXRobmFtZSA9IFwiL1wiLFxuICBzZWFyY2ggPSBcIlwiLFxuICBoYXNoID0gXCJcIixcbn06IFBhcnRpYWw8UGF0aD4pIHtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKVxuICAgIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09IFwiP1wiID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKVxuICAgIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgVVJMIHBhdGggaW50byBpdHMgc2VwYXJhdGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoOiBzdHJpbmcpOiBQYXJ0aWFsPFBhdGg+IHtcbiAgbGV0IHBhcnNlZFBhdGg6IFBhcnRpYWw8UGF0aD4gPSB7fTtcblxuICBpZiAocGF0aCkge1xuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXJsSGlzdG9yeSBleHRlbmRzIEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgVXJsSGlzdG9yeU9wdGlvbnMgPSB7XG4gIHdpbmRvdz86IFdpbmRvdztcbiAgdjVDb21wYXQ/OiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICBnZXRMb2NhdGlvbjogKHdpbmRvdzogV2luZG93LCBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdKSA9PiBMb2NhdGlvbixcbiAgY3JlYXRlSHJlZjogKHdpbmRvdzogV2luZG93LCB0bzogVG8pID0+IHN0cmluZyxcbiAgdmFsaWRhdGVMb2NhdGlvbjogKChsb2NhdGlvbjogTG9jYXRpb24sIHRvOiBUbykgPT4gdm9pZCkgfCBudWxsLFxuICBvcHRpb25zOiBVcmxIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBVcmxIaXN0b3J5IHtcbiAgbGV0IHsgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXchLCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIGxldCBpbmRleCA9IGdldEluZGV4KCkhO1xuICAvLyBJbmRleCBzaG91bGQgb25seSBiZSBudWxsIHdoZW4gd2UgaW5pdGlhbGl6ZS4gSWYgbm90LCBpdCdzIGJlY2F1c2UgdGhlXG4gIC8vIHVzZXIgY2FsbGVkIGhpc3RvcnkucHVzaFN0YXRlIG9yIGhpc3RvcnkucmVwbGFjZVN0YXRlIGRpcmVjdGx5LCBpbiB3aGljaFxuICAvLyBjYXNlIHdlIHNob3VsZCBsb2cgYSB3YXJuaW5nIGFzIGl0IHdpbGwgcmVzdWx0IGluIGJ1Z3MuXG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsgLi4uZ2xvYmFsSGlzdG9yeS5zdGF0ZSwgaWR4OiBpbmRleCB9LCBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluZGV4KCk6IG51bWJlciB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7IGlkeDogbnVsbCB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICBsZXQgbmV4dEluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgZGVsdGEgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXggLSBpbmRleDtcbiAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bzogVG8sIHN0YXRlPzogYW55KSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuXG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG5cbiAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSBleGNlcHRpb24gaXMgYmVjYXVzZSBgc3RhdGVgIGNhbid0IGJlIHNlcmlhbGl6ZWQsIGxldCB0aGF0IHRocm93XG4gICAgICAvLyBvdXR3YXJkcyBqdXN0IGxpa2UgYSByZXBsYWNlIGNhbGwgd291bGQgc28gdGhlIGRldiBrbm93cyB0aGUgY2F1c2VcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL25hdi1oaXN0b3J5LWFwaXMuaHRtbCNzaGFyZWQtaGlzdG9yeS1wdXNoL3JlcGxhY2Utc3RhdGUtc3RlcHNcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N0cnVjdHVyZWQtZGF0YS5odG1sI3N0cnVjdHVyZWRzZXJpYWxpemVpbnRlcm5hbFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiRGF0YUNsb25lRXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuXG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcblxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuXG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVSTCh0bzogVG8pOiBVUkwge1xuICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gaXMgXCJudWxsXCIgKHRoZSBsaXRlcmFsIHN0cmluZyB2YWx1ZSkgaW4gRmlyZWZveFxuICAgIC8vIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucywgbm90YWJseSB3aGVuIHNlcnZpbmcgZnJvbSBhIGxvY2FsIEhUTUwgZmlsZVxuICAgIC8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04NzgyOTdcbiAgICBsZXQgYmFzZSA9XG4gICAgICB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIlxuICAgICAgICA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcblxuICAgIGxldCBocmVmID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBiYXNlLFxuICAgICAgYE5vIHdpbmRvdy5sb2NhdGlvbi4ob3JpZ2lufGhyZWYpIGF2YWlsYWJsZSB0byBjcmVhdGUgVVJMIGZvciBocmVmOiAke2hyZWZ9YFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeTogSGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpO1xuICAgIH0sXG4gICAgbGlzdGVuKGZuOiBMaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSHJlZih3aW5kb3csIHRvKTtcbiAgICB9LFxuICAgIGNyZWF0ZVVSTCxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgLy8gRW5jb2RlIGEgTG9jYXRpb24gdGhlIHNhbWUgd2F5IHdpbmRvdy5sb2NhdGlvbiB3b3VsZFxuICAgICAgbGV0IHVybCA9IGNyZWF0ZVVSTCh0byk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZSxcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG4vLyNlbmRyZWdpb25cbiIsImltcG9ydCB0eXBlIHsgTG9jYXRpb24sIFBhdGgsIFRvIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHsgaW52YXJpYW50LCBwYXJzZVBhdGgsIHdhcm5pbmcgfSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5cbi8qKlxuICogTWFwIG9mIHJvdXRlSWQgLT4gZGF0YSByZXR1cm5lZCBmcm9tIGEgbG9hZGVyL2FjdGlvbi9lcnJvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlRGF0YSB7XG4gIFtyb3V0ZUlkOiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBlbnVtIFJlc3VsdFR5cGUge1xuICBkYXRhID0gXCJkYXRhXCIsXG4gIGRlZmVycmVkID0gXCJkZWZlcnJlZFwiLFxuICByZWRpcmVjdCA9IFwicmVkaXJlY3RcIixcbiAgZXJyb3IgPSBcImVycm9yXCIsXG59XG5cbi8qKlxuICogU3VjY2Vzc2Z1bCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWNjZXNzUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kYXRhO1xuICBkYXRhOiBhbnk7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFN1Y2Nlc3NmdWwgZGVmZXIoKSByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZlcnJlZFJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG4gIGRlZmVycmVkRGF0YTogRGVmZXJyZWREYXRhO1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBSZWRpcmVjdCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWRpcmVjdFJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG4gIHN0YXR1czogbnVtYmVyO1xuICBsb2NhdGlvbjogc3RyaW5nO1xuICByZXZhbGlkYXRlOiBib29sZWFuO1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVW5zdWNjZXNzZnVsIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcjtcbiAgZXJyb3I6IGFueTtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uIC0gcG90ZW50aWFsbHkgc3VjY2Vzc2Z1bCBvciB1bnN1Y2Nlc3NmdWxcbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVJlc3VsdCA9XG4gIHwgU3VjY2Vzc1Jlc3VsdFxuICB8IERlZmVycmVkUmVzdWx0XG4gIHwgUmVkaXJlY3RSZXN1bHRcbiAgfCBFcnJvclJlc3VsdDtcblxudHlwZSBMb3dlckNhc2VGb3JtTWV0aG9kID0gXCJnZXRcIiB8IFwicG9zdFwiIHwgXCJwdXRcIiB8IFwicGF0Y2hcIiB8IFwiZGVsZXRlXCI7XG50eXBlIFVwcGVyQ2FzZUZvcm1NZXRob2QgPSBVcHBlcmNhc2U8TG93ZXJDYXNlRm9ybU1ldGhvZD47XG5cbi8qKlxuICogVXNlcnMgY2FuIHNwZWNpZnkgZWl0aGVyIGxvd2VyY2FzZSBvciB1cHBlcmNhc2UgZm9ybSBtZXRob2RzIG9uIDxGb3JtPixcbiAqIHVzZVN1Ym1pdCgpLCA8ZmV0Y2hlci5Gb3JtPiwgZXRjLlxuICovXG5leHBvcnQgdHlwZSBIVE1MRm9ybU1ldGhvZCA9IExvd2VyQ2FzZUZvcm1NZXRob2QgfCBVcHBlckNhc2VGb3JtTWV0aG9kO1xuXG4vKipcbiAqIEFjdGl2ZSBuYXZpZ2F0aW9uL2ZldGNoZXIgZm9ybSBtZXRob2RzIGFyZSBleHBvc2VkIGluIGxvd2VyY2FzZSBvbiB0aGVcbiAqIFJvdXRlclN0YXRlXG4gKi9cbmV4cG9ydCB0eXBlIEZvcm1NZXRob2QgPSBMb3dlckNhc2VGb3JtTWV0aG9kO1xuZXhwb3J0IHR5cGUgTXV0YXRpb25Gb3JtTWV0aG9kID0gRXhjbHVkZTxGb3JtTWV0aG9kLCBcImdldFwiPjtcblxuLyoqXG4gKiBJbiB2NywgYWN0aXZlIG5hdmlnYXRpb24vZmV0Y2hlciBmb3JtIG1ldGhvZHMgYXJlIGV4cG9zZWQgaW4gdXBwZXJjYXNlIG9uIHRoZVxuICogUm91dGVyU3RhdGUuICBUaGlzIGlzIHRvIGFsaWduIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gZG9uZSB2aWEgZmV0Y2goKS5cbiAqL1xuZXhwb3J0IHR5cGUgVjdfRm9ybU1ldGhvZCA9IFVwcGVyQ2FzZUZvcm1NZXRob2Q7XG5leHBvcnQgdHlwZSBWN19NdXRhdGlvbkZvcm1NZXRob2QgPSBFeGNsdWRlPFY3X0Zvcm1NZXRob2QsIFwiR0VUXCI+O1xuXG5leHBvcnQgdHlwZSBGb3JtRW5jVHlwZSA9XG4gIHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICB8IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiXG4gIHwgXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgfCBcInRleHQvcGxhaW5cIjtcblxuLy8gVGhhbmtzIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdHlwZS1mZXN0IVxudHlwZSBKc29uT2JqZWN0ID0geyBbS2V5IGluIHN0cmluZ106IEpzb25WYWx1ZSB9ICYge1xuICBbS2V5IGluIHN0cmluZ10/OiBKc29uVmFsdWUgfCB1bmRlZmluZWQ7XG59O1xudHlwZSBKc29uQXJyYXkgPSBKc29uVmFsdWVbXSB8IHJlYWRvbmx5IEpzb25WYWx1ZVtdO1xudHlwZSBKc29uUHJpbWl0aXZlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGw7XG50eXBlIEpzb25WYWx1ZSA9IEpzb25QcmltaXRpdmUgfCBKc29uT2JqZWN0IHwgSnNvbkFycmF5O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gcGFzcyBhcm91bmQgZm9yIGFjdGlvbiBzdWJtaXNzaW9ucywgbm90IGludGVuZGVkIGZvclxuICogZXh0ZXJuYWwgY29uc3VtcHRpb25cbiAqL1xuZXhwb3J0IHR5cGUgU3VibWlzc2lvbiA9XG4gIHwge1xuICAgICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCB8IFY3X0Zvcm1NZXRob2Q7XG4gICAgICBmb3JtQWN0aW9uOiBzdHJpbmc7XG4gICAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gICAgICBmb3JtRGF0YTogRm9ybURhdGE7XG4gICAgICBqc29uOiB1bmRlZmluZWQ7XG4gICAgICB0ZXh0OiB1bmRlZmluZWQ7XG4gICAgfVxuICB8IHtcbiAgICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgICAgIGpzb246IEpzb25WYWx1ZTtcbiAgICAgIHRleHQ6IHVuZGVmaW5lZDtcbiAgICB9XG4gIHwge1xuICAgICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCB8IFY3X0Zvcm1NZXRob2Q7XG4gICAgICBmb3JtQWN0aW9uOiBzdHJpbmc7XG4gICAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkO1xuICAgICAganNvbjogdW5kZWZpbmVkO1xuICAgICAgdGV4dDogc3RyaW5nO1xuICAgIH07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gcm91dGUgbG9hZGVyL2FjdGlvbiBmdW5jdGlvbnMuICBTYW1lIGZvciBub3cgYnV0IHdlIGtlZXBcbiAqIHRoaXMgYXMgYSBwcml2YXRlIGltcGxlbWVudGF0aW9uIGRldGFpbCBpbiBjYXNlIHRoZXkgZGl2ZXJnZSBpbiB0aGUgZnV0dXJlLlxuICovXG5pbnRlcmZhY2UgRGF0YUZ1bmN0aW9uQXJnczxDb250ZXh0PiB7XG4gIHJlcXVlc3Q6IFJlcXVlc3Q7XG4gIHBhcmFtczogUGFyYW1zO1xuICBjb250ZXh0PzogQ29udGV4dDtcbn1cblxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIGRlZmF1bHRzIGZyb20gYW55IHRvIHVua25vd24gaW4gYW5kIHJlbW92ZSBSZW1peCB3cmFwcGVyczpcbi8vICAgQWN0aW9uRnVuY3Rpb24sIEFjdGlvbkZ1bmN0aW9uQXJncywgTG9hZGVyRnVuY3Rpb24sIExvYWRlckZ1bmN0aW9uQXJnc1xuLy8gICBBbHNvLCBtYWtlIHRoZW0gYSB0eXBlIGFsaWFzIGluc3RlYWQgb2YgYW4gaW50ZXJmYWNlXG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBsb2FkZXIgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb25BcmdzPENvbnRleHQgPSBhbnk+XG4gIGV4dGVuZHMgRGF0YUZ1bmN0aW9uQXJnczxDb250ZXh0PiB7fVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gYWN0aW9uIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkZ1bmN0aW9uQXJnczxDb250ZXh0ID0gYW55PlxuICBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3M8Q29udGV4dD4ge31cblxuLyoqXG4gKiBMb2FkZXJzIGFuZCBhY3Rpb25zIGNhbiByZXR1cm4gYW55dGhpbmcgZXhjZXB0IGB1bmRlZmluZWRgIChgbnVsbGAgaXMgYVxuICogdmFsaWQgcmV0dXJuIHZhbHVlIGlmIHRoZXJlIGlzIG5vIGRhdGEgdG8gcmV0dXJuKS4gIFJlc3BvbnNlcyBhcmUgcHJlZmVycmVkXG4gKiBhbmQgd2lsbCBlYXNlIGFueSBmdXR1cmUgbWlncmF0aW9uIHRvIFJlbWl4XG4gKi9cbnR5cGUgRGF0YUZ1bmN0aW9uVmFsdWUgPSBSZXNwb25zZSB8IE5vbk51bGxhYmxlPHVua25vd24+IHwgbnVsbDtcblxuLyoqXG4gKiBSb3V0ZSBsb2FkZXIgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb248Q29udGV4dCA9IGFueT4ge1xuICAoYXJnczogTG9hZGVyRnVuY3Rpb25BcmdzPENvbnRleHQ+KTpcbiAgICB8IFByb21pc2U8RGF0YUZ1bmN0aW9uVmFsdWU+XG4gICAgfCBEYXRhRnVuY3Rpb25WYWx1ZTtcbn1cblxuLyoqXG4gKiBSb3V0ZSBhY3Rpb24gZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uRnVuY3Rpb248Q29udGV4dCA9IGFueT4ge1xuICAoYXJnczogQWN0aW9uRnVuY3Rpb25BcmdzPENvbnRleHQ+KTpcbiAgICB8IFByb21pc2U8RGF0YUZ1bmN0aW9uVmFsdWU+XG4gICAgfCBEYXRhRnVuY3Rpb25WYWx1ZTtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIHNob3VsZFJldmFsaWRhdGUgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzIHtcbiAgY3VycmVudFVybDogVVJMO1xuICBjdXJyZW50UGFyYW1zOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBuZXh0VXJsOiBVUkw7XG4gIG5leHRQYXJhbXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gIGZvcm1NZXRob2Q/OiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXTtcbiAgZm9ybUFjdGlvbj86IFN1Ym1pc3Npb25bXCJmb3JtQWN0aW9uXCJdO1xuICBmb3JtRW5jVHlwZT86IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXTtcbiAgdGV4dD86IFN1Ym1pc3Npb25bXCJ0ZXh0XCJdO1xuICBmb3JtRGF0YT86IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXTtcbiAganNvbj86IFN1Ym1pc3Npb25bXCJqc29uXCJdO1xuICBhY3Rpb25SZXN1bHQ/OiBhbnk7XG4gIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJvdXRlIHNob3VsZFJldmFsaWRhdGUgZnVuY3Rpb24gc2lnbmF0dXJlLiAgVGhpcyBydW5zIGFmdGVyIGFueSBzdWJtaXNzaW9uXG4gKiAobmF2aWdhdGlvbiBvciBmZXRjaGVyKSwgc28gd2UgZmxhdHRlbiB0aGUgbmF2aWdhdGlvbi9mZXRjaGVyIHN1Ym1pc3Npb25cbiAqIG9udG8gdGhlIGFyZ3VtZW50cy4gIEl0IHNob3VsZG4ndCBtYXR0ZXIgd2hldGhlciBpdCBjYW1lIGZyb20gYSBuYXZpZ2F0aW9uXG4gKiBvciBhIGZldGNoZXIsIHdoYXQgcmVhbGx5IG1hdHRlcnMgaXMgdGhlIFVSTHMgYW5kIHRoZSBmb3JtRGF0YSBzaW5jZSBsb2FkZXJzXG4gKiBoYXZlIHRvIHJlLXJ1biBiYXNlZCBvbiB0aGUgZGF0YSBtb2RlbHMgdGhhdCB3ZXJlIHBvdGVudGlhbGx5IG11dGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uIHtcbiAgKGFyZ3M6IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbkFyZ3MpOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBmcmFtZXdvcmstYXdhcmUgbGF5ZXJzIHRvIHNldCBgaGFzRXJyb3JCb3VuZGFyeWBcbiAqIGZyb20gdGhlIGZyYW1ld29yay1hd2FyZSBgZXJyb3JFbGVtZW50YCBwcm9wXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBtYXBSb3V0ZVByb3BlcnRpZXNgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb24ge1xuICAocm91dGU6IEFnbm9zdGljUm91dGVPYmplY3QpOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBmcmFtZXdvcmstYXdhcmUgbGF5ZXJzIHRvIHNldCBhbnkgZnJhbWV3b3JrLXNwZWNpZmljXG4gKiBwcm9wZXJ0aWVzIGZyb20gZnJhbWV3b3JrLWFnbm9zdGljIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbiB7XG4gIChyb3V0ZTogQWdub3N0aWNSb3V0ZU9iamVjdCk6IHtcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiBib29sZWFuO1xuICB9ICYgUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuLyoqXG4gKiBLZXlzIHdlIGNhbm5vdCBjaGFuZ2UgZnJvbSB3aXRoaW4gYSBsYXp5KCkgZnVuY3Rpb24uIFdlIHNwcmVhZCBhbGwgb3RoZXIga2V5c1xuICogb250byB0aGUgcm91dGUuIEVpdGhlciB0aGV5J3JlIG1lYW5pbmdmdWwgdG8gdGhlIHJvdXRlciwgb3IgdGhleSdsbCBnZXRcbiAqIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCB0eXBlIEltbXV0YWJsZVJvdXRlS2V5ID1cbiAgfCBcImxhenlcIlxuICB8IFwiY2FzZVNlbnNpdGl2ZVwiXG4gIHwgXCJwYXRoXCJcbiAgfCBcImlkXCJcbiAgfCBcImluZGV4XCJcbiAgfCBcImNoaWxkcmVuXCI7XG5cbmV4cG9ydCBjb25zdCBpbW11dGFibGVSb3V0ZUtleXMgPSBuZXcgU2V0PEltbXV0YWJsZVJvdXRlS2V5PihbXG4gIFwibGF6eVwiLFxuICBcImNhc2VTZW5zaXRpdmVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImNoaWxkcmVuXCIsXG5dKTtcblxudHlwZSBSZXF1aXJlT25lPFQsIEtleSA9IGtleW9mIFQ+ID0gRXhjbHVkZTxcbiAge1xuICAgIFtLIGluIGtleW9mIFRdOiBLIGV4dGVuZHMgS2V5ID8gT21pdDxULCBLPiAmIFJlcXVpcmVkPFBpY2s8VCwgSz4+IDogbmV2ZXI7XG4gIH1ba2V5b2YgVF0sXG4gIHVuZGVmaW5lZFxuPjtcblxuLyoqXG4gKiBsYXp5KCkgZnVuY3Rpb24gdG8gbG9hZCBhIHJvdXRlIGRlZmluaXRpb24sIHdoaWNoIGNhbiBhZGQgbm9uLW1hdGNoaW5nXG4gKiByZWxhdGVkIHByb3BlcnRpZXMgdG8gYSByb3V0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExhenlSb3V0ZUZ1bmN0aW9uPFIgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0PiB7XG4gICgpOiBQcm9taXNlPFJlcXVpcmVPbmU8T21pdDxSLCBJbW11dGFibGVSb3V0ZUtleT4+Pjtcbn1cblxuLyoqXG4gKiBCYXNlIFJvdXRlT2JqZWN0IHdpdGggY29tbW9uIHByb3BzIHNoYXJlZCBieSBhbGwgdHlwZXMgb2Ygcm91dGVzXG4gKi9cbnR5cGUgQWdub3N0aWNCYXNlUm91dGVPYmplY3QgPSB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgbG9hZGVyPzogTG9hZGVyRnVuY3Rpb247XG4gIGFjdGlvbj86IEFjdGlvbkZ1bmN0aW9uO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogYm9vbGVhbjtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbjtcbiAgaGFuZGxlPzogYW55O1xuICBsYXp5PzogTGF6eVJvdXRlRnVuY3Rpb248QWdub3N0aWNCYXNlUm91dGVPYmplY3Q+O1xufTtcblxuLyoqXG4gKiBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZHJlblxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY0Jhc2VSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiB1bmRlZmluZWQ7XG4gIGluZGV4OiB0cnVlO1xufTtcblxuLyoqXG4gKiBOb24taW5kZXggcm91dGVzIG1heSBoYXZlIGNoaWxkcmVuLCBidXQgY2Fubm90IGhhdmUgaW5kZXhcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNSb3V0ZU9iamVjdFtdO1xuICBpbmRleD86IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBIHJvdXRlIG9iamVjdCByZXByZXNlbnRzIGEgbG9naWNhbCByb3V0ZSwgd2l0aCAob3B0aW9uYWxseSkgaXRzIGNoaWxkXG4gKiByb3V0ZXMgb3JnYW5pemVkIGluIGEgdHJlZS1saWtlIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0XG4gIHwgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ICYge1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuICBpZDogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBBIGRhdGEgcm91dGUgb2JqZWN0LCB3aGljaCBpcyBqdXN0IGEgUm91dGVPYmplY3Qgd2l0aCBhIHJlcXVpcmVkIHVuaXF1ZSBJRFxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3Q7XG5cbmV4cG9ydCB0eXBlIFJvdXRlTWFuaWZlc3QgPSBSZWNvcmQ8c3RyaW5nLCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCB8IHVuZGVmaW5lZD47XG5cbi8vIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGZpbmRpbmcgcGF0aCBwYXJhbWV0ZXJzIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xudHlwZSBfUGF0aFBhcmFtPFBhdGggZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gc3BsaXQgcGF0aCBpbnRvIGluZGl2aWR1YWwgcGF0aCBzZWdtZW50c1xuICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgTH0vJHtpbmZlciBSfWBcbiAgICA/IF9QYXRoUGFyYW08TD4gfCBfUGF0aFBhcmFtPFI+XG4gICAgOiAvLyBmaW5kIHBhcmFtcyBhZnRlciBgOmBcbiAgICBQYXRoIGV4dGVuZHMgYDoke2luZmVyIFBhcmFtfWBcbiAgICA/IFBhcmFtIGV4dGVuZHMgYCR7aW5mZXIgT3B0aW9uYWx9P2BcbiAgICAgID8gT3B0aW9uYWxcbiAgICAgIDogUGFyYW1cbiAgICA6IC8vIG90aGVyd2lzZSwgdGhlcmUgYXJlbid0IGFueSBwYXJhbXMgcHJlc2VudFxuICAgICAgbmV2ZXI7XG5cbi8qKlxuICogRXhhbXBsZXM6XG4gKiBcIi9hL2IvKlwiIC0+IFwiKlwiXG4gKiBcIjphXCIgLT4gXCJhXCJcbiAqIFwiL2EvOmJcIiAtPiBcImJcIlxuICogXCIvYS9ibGFoYmxhaGJsYWg6YlwiIC0+IFwiYlwiXG4gKiBcIi86YS86YlwiIC0+IFwiYVwiIHwgXCJiXCJcbiAqIFwiLzphL2IvOmMvKlwiIC0+IFwiYVwiIHwgXCJjXCIgfCBcIipcIlxuICovXG50eXBlIFBhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGNoZWNrIGlmIHBhdGggaXMganVzdCBhIHdpbGRjYXJkXG4gIFBhdGggZXh0ZW5kcyBcIipcIiB8IFwiLypcIlxuICAgID8gXCIqXCJcbiAgICA6IC8vIGxvb2sgZm9yIHdpbGRjYXJkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdGhcbiAgICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgUmVzdH0vKmBcbiAgICA/IFwiKlwiIHwgX1BhdGhQYXJhbTxSZXN0PlxuICAgIDogLy8gbG9vayBmb3IgcGFyYW1zIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xuICAgICAgX1BhdGhQYXJhbTxQYXRoPjtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIHNlZ21lbnQuIElmIGl0IGZhaWxzLCB0aGVuIGp1c3QgcmV0dXJuIHRoZVxuLy8gcGxhaW4gc3RyaW5nIHR5cGUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLiBPdGhlcndpc2UsIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxuZXhwb3J0IHR5cGUgUGFyYW1QYXJzZUtleTxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGlmIHlvdSBjb3VsZCBub3QgZmluZCBwYXRoIHBhcmFtcywgZmFsbGJhY2sgdG8gYHN0cmluZ2BcbiAgW1BhdGhQYXJhbTxTZWdtZW50Pl0gZXh0ZW5kcyBbbmV2ZXJdID8gc3RyaW5nIDogUGF0aFBhcmFtPFNlZ21lbnQ+O1xuXG4vKipcbiAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXJzZWQgZnJvbSB0aGUgVVJMIHBhdGguXG4gKi9cbmV4cG9ydCB0eXBlIFBhcmFtczxLZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0ge1xuICByZWFkb25seSBba2V5IGluIEtleV06IHN0cmluZyB8IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQSBSb3V0ZU1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgcm91dGUgbWF0Y2hlZCBhIFVSTC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZ25vc3RpY1JvdXRlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJvdXRlIG9iamVjdCB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4gIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU1hdGNoPHN0cmluZywgQWdub3N0aWNEYXRhUm91dGVPYmplY3Q+IHt9XG5cbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShcbiAgcm91dGU6IEFnbm9zdGljUm91dGVPYmplY3Rcbik6IHJvdXRlIGlzIEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdCB7XG4gIHJldHVybiByb3V0ZS5pbmRleCA9PT0gdHJ1ZTtcbn1cblxuLy8gV2FsayB0aGUgcm91dGUgdHJlZSBnZW5lcmF0aW5nIHVuaXF1ZSBJRHMgd2hlcmUgbmVjZXNzYXJ5LCBzbyB3ZSBhcmUgd29ya2luZ1xuLy8gc29sZWx5IHdpdGggQWdub3N0aWNEYXRhUm91dGVPYmplY3QncyB3aXRoaW4gdGhlIFJvdXRlclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdLFxuICBtYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uLFxuICBwYXJlbnRQYXRoOiBudW1iZXJbXSA9IFtdLFxuICBtYW5pZmVzdDogUm91dGVNYW5pZmVzdCA9IHt9XG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sXG4gICAgICBgQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVgXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhbWFuaWZlc3RbaWRdLFxuICAgICAgYEZvdW5kIGEgcm91dGUgaWQgY29sbGlzaW9uIG9uIGlkIFwiJHtpZH1cIi4gIFJvdXRlIGAgK1xuICAgICAgICBcImlkJ3MgbXVzdCBiZSBnbG9iYWxseSB1bmlxdWUgd2l0aGluIERhdGEgUm91dGVyIHVzYWdlc1wiXG4gICAgKTtcblxuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZTogQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdCA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IGluZGV4Um91dGU7XG4gICAgICByZXR1cm4gaW5kZXhSb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhdGhPckxheW91dFJvdXRlOiBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0ID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSxcbiAgICAgICAgaWQsXG4gICAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gcGF0aE9yTGF5b3V0Um91dGU7XG5cbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICAgICAgcm91dGUuY2hpbGRyZW4sXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgIHRyZWVQYXRoLFxuICAgICAgICAgIG1hbmlmZXN0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGxvY2F0aW9uQXJnOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZyxcbiAgYmFzZW5hbWUgPSBcIi9cIlxuKTogQWdub3N0aWNSb3V0ZU1hdGNoPHN0cmluZywgUm91dGVPYmplY3RUeXBlPltdIHwgbnVsbCB7XG4gIGxldCBsb2NhdGlvbiA9XG4gICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcblxuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG5cbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoPHN0cmluZywgUm91dGVPYmplY3RUeXBlPihcbiAgICAgIGJyYW5jaGVzW2ldLFxuICAgICAgLy8gSW5jb21pbmcgcGF0aG5hbWVzIGFyZSBnZW5lcmFsbHkgZW5jb2RlZCBmcm9tIGVpdGhlciB3aW5kb3cubG9jYXRpb25cbiAgICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcbiAgICAgIC8vIHBhdGhzIGluIHRoZSByb3V0ZSBkZWZpbml0aW9ucy4gIE1lbW9yeSByb3V0ZXIgbG9jYXRpb25zIHdvbid0IGJlXG4gICAgICAvLyBlbmNvZGVkIGhlcmUgYnV0IHRoZXJlIGFsc28gc2hvdWxkbid0IGJlIGFueXRoaW5nIHRvIGRlY29kZSBzbyB0aGlzXG4gICAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcbiAgICAgIC8vIGhpc3RvcnktYXdhcmUuXG4gICAgICBzYWZlbHlEZWNvZGVVUkkocGF0aG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVJTWF0Y2g8RGF0YSA9IHVua25vd24sIEhhbmRsZSA9IHVua25vd24+IHtcbiAgaWQ6IHN0cmluZztcbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgcGFyYW1zOiBBZ25vc3RpY1JvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gIGRhdGE6IERhdGE7XG4gIGhhbmRsZTogSGFuZGxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2goXG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBsb2FkZXJEYXRhOiBSb3V0ZURhdGFcbik6IFVJTWF0Y2gge1xuICBsZXQgeyByb3V0ZSwgcGF0aG5hbWUsIHBhcmFtcyB9ID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJvdXRlLmlkLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkYXRhOiBsb2FkZXJEYXRhW3JvdXRlLmlkXSxcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSxcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFJvdXRlTWV0YTxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICByZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgY2FzZVNlbnNpdGl2ZTogYm9vbGVhbjtcbiAgY2hpbGRyZW5JbmRleDogbnVtYmVyO1xuICByb3V0ZTogUm91dGVPYmplY3RUeXBlO1xufVxuXG5pbnRlcmZhY2UgUm91dGVCcmFuY2g8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgcGF0aDogc3RyaW5nO1xuICBzY29yZTogbnVtYmVyO1xuICByb3V0ZXNNZXRhOiBSb3V0ZU1ldGE8Um91dGVPYmplY3RUeXBlPltdO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFR5cGVbXSxcbiAgYnJhbmNoZXM6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT5bXSA9IFtdLFxuICBwYXJlbnRzTWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT5bXSA9IFtdLFxuICBwYXJlbnRQYXRoID0gXCJcIlxuKTogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPltdIHtcbiAgbGV0IGZsYXR0ZW5Sb3V0ZSA9IChcbiAgICByb3V0ZTogUm91dGVPYmplY3RUeXBlLFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgcmVsYXRpdmVQYXRoPzogc3RyaW5nXG4gICkgPT4ge1xuICAgIGxldCBtZXRhOiBSb3V0ZU1ldGE8Um91dGVPYmplY3RUeXBlPiA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDpcbiAgICAgICAgcmVsYXRpdmVQYXRoID09PSB1bmRlZmluZWQgPyByb3V0ZS5wYXRoIHx8IFwiXCIgOiByZWxhdGl2ZVBhdGgsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxuICAgICAgY2hpbGRyZW5JbmRleDogaW5kZXgsXG4gICAgICByb3V0ZSxcbiAgICB9O1xuXG4gICAgaWYgKG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCksXG4gICAgICAgIGBBYnNvbHV0ZSByb3V0ZSBwYXRoIFwiJHttZXRhLnJlbGF0aXZlUGF0aH1cIiBuZXN0ZWQgdW5kZXIgcGF0aCBgICtcbiAgICAgICAgICBgXCIke3BhcmVudFBhdGh9XCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIGAgK1xuICAgICAgICAgIGBtdXN0IHN0YXJ0IHdpdGggdGhlIGNvbWJpbmVkIHBhdGggb2YgYWxsIGl0cyBwYXJlbnQgcm91dGVzLmBcbiAgICAgICk7XG5cbiAgICAgIG1ldGEucmVsYXRpdmVQYXRoID0gbWV0YS5yZWxhdGl2ZVBhdGguc2xpY2UocGFyZW50UGF0aC5sZW5ndGgpO1xuICAgIH1cblxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuXG4gICAgLy8gQWRkIHRoZSBjaGlsZHJlbiBiZWZvcmUgYWRkaW5nIHRoaXMgcm91dGUgdG8gdGhlIGFycmF5LCBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYCArXG4gICAgICAgICAgYGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG5cbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICBwYXRoLFxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXG4gICAgICByb3V0ZXNNZXRhLFxuICAgIH0pO1xuICB9O1xuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgLy8gY29hcnNlLWdyYWluIGNoZWNrIGZvciBvcHRpb25hbCBwYXJhbXNcbiAgICBpZiAocm91dGUucGF0aCA9PT0gXCJcIiB8fCAhcm91dGUucGF0aD8uaW5jbHVkZXMoXCI/XCIpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFsbCBjb21iaW5hdGlvbnMgb2Ygb3B0aW9uYWwgcGF0aCBzZWdtZW50cyBmb3IgYSBnaXZlbiBwYXRoLFxuICogZXhjbHVkaW5nIGNvbWJpbmF0aW9ucyB0aGF0IGFyZSBhbWJpZ3VvdXMgYW5kIG9mIGxvd2VyIHByaW9yaXR5LlxuICpcbiAqIEZvciBleGFtcGxlLCBgL29uZS86dHdvPy90aHJlZS86Zm91cj8vOmZpdmU/YCBleHBsb2RlcyB0bzpcbiAqIC0gYC9vbmUvdGhyZWVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXIvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXIvOmZpdmVgXG4gKi9cbmZ1bmN0aW9uIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHBhdGg6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuXG4gIC8vIE9wdGlvbmFsIHBhdGggc2VnbWVudHMgYXJlIGRlbm90ZWQgYnkgYSB0cmFpbGluZyBgP2BcbiAgbGV0IGlzT3B0aW9uYWwgPSBmaXJzdC5lbmRzV2l0aChcIj9cIik7XG4gIC8vIENvbXB1dGUgdGhlIGNvcnJlc3BvbmRpbmcgcmVxdWlyZWQgc2VnbWVudDogYGZvbz9gIC0+IGBmb29gXG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcblxuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJbnRlcHJldCBlbXB0eSBzdHJpbmcgYXMgb21pdHRpbmcgYW4gb3B0aW9uYWwgc2VnbWVudFxuICAgIC8vIGBbXCJvbmVcIiwgXCJcIiwgXCJ0aHJlZVwiXWAgY29ycmVzcG9uZHMgdG8gb21pdHRpbmcgYDp0d29gIGZyb20gYC9vbmUvOnR3bz8vdGhyZWVgIC0+IGAvb25lL3RocmVlYFxuICAgIHJldHVybiBpc09wdGlvbmFsID8gW3JlcXVpcmVkLCBcIlwiXSA6IFtyZXF1aXJlZF07XG4gIH1cblxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG5cbiAgbGV0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcblxuICAvLyBBbGwgY2hpbGQgcGF0aHMgd2l0aCB0aGUgcHJlZml4LiAgRG8gdGhpcyBmb3IgYWxsIGNoaWxkcmVuIGJlZm9yZSB0aGVcbiAgLy8gb3B0aW9uYWwgdmVyc2lvbiBmb3IgYWxsIGNoaWxkcmVuLCBzbyB3ZSBnZXQgY29uc2lzdGVudCBvcmRlcmluZyB3aGVyZSB0aGVcbiAgLy8gcGFyZW50IG9wdGlvbmFsIGFzcGVjdCBpcyBwcmVmZXJyZWQgYXMgcmVxdWlyZWQuICBPdGhlcndpc2UsIHdlIGNhbiBnZXRcbiAgLy8gY2hpbGQgc2VjdGlvbnMgaW50ZXJzcGVyc2VkIHdoZXJlIGRlZXBlciBvcHRpb25hbCBzZWdtZW50cyBhcmUgaGlnaGVyIHRoYW5cbiAgLy8gcGFyZW50IG9wdGlvbmFsIHNlZ21lbnRzLCB3aGVyZSBmb3IgZXhhbXBsZSwgLzp0d28gd291bGQgZXhwbG9kZSBfZWFybGllcl9cbiAgLy8gdGhlbiAvOm9uZS4gIEJ5IGFsd2F5cyBpbmNsdWRpbmcgdGhlIHBhcmVudCBhcyByZXF1aXJlZCBfZm9yIGFsbCBjaGlsZHJlbl9cbiAgLy8gZmlyc3QsIHdlIGF2b2lkIHRoaXMgaXNzdWVcbiAgcmVzdWx0LnB1c2goXG4gICAgLi4ucmVzdEV4cGxvZGVkLm1hcCgoc3VicGF0aCkgPT5cbiAgICAgIHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIilcbiAgICApXG4gICk7XG5cbiAgLy8gVGhlbiwgaWYgdGhpcyBpcyBhbiBvcHRpb25hbCB2YWx1ZSwgYWRkIGFsbCBjaGlsZCB2ZXJzaW9ucyB3aXRob3V0XG4gIGlmIChpc09wdGlvbmFsKSB7XG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcbiAgfVxuXG4gIC8vIGZvciBhYnNvbHV0ZSBwYXRocywgZW5zdXJlIGAvYCBpbnN0ZWFkIG9mIGVtcHR5IHNlZ21lbnRcbiAgcmV0dXJuIHJlc3VsdC5tYXAoKGV4cGxvZGVkKSA9PlxuICAgIHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdKTogdm9pZCB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+XG4gICAgYS5zY29yZSAhPT0gYi5zY29yZVxuICAgICAgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICAgIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICAgICAgYS5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgICAgIClcbiAgKTtcbn1cblxuY29uc3QgcGFyYW1SZSA9IC9eOlxcdyskLztcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xuY29uc3QgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbmNvbnN0IGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xuY29uc3Qgc3BsYXRQZW5hbHR5ID0gLTI7XG5jb25zdCBpc1NwbGF0ID0gKHM6IHN0cmluZykgPT4gcyA9PT0gXCIqXCI7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoOiBzdHJpbmcsIGluZGV4OiBib29sZWFuIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuXG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNcbiAgICAuZmlsdGVyKChzKSA9PiAhaXNTcGxhdChzKSlcbiAgICAucmVkdWNlKFxuICAgICAgKHNjb3JlLCBzZWdtZW50KSA9PlxuICAgICAgICBzY29yZSArXG4gICAgICAgIChwYXJhbVJlLnRlc3Qoc2VnbWVudClcbiAgICAgICAgICA/IGR5bmFtaWNTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHNlZ21lbnQgPT09IFwiXCJcbiAgICAgICAgICA/IGVtcHR5U2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgICAgaW5pdGlhbFNjb3JlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNpYmxpbmdzID1cbiAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuXG4gIHJldHVybiBzaWJsaW5nc1xuICAgID8gLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICAgIDogLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIGJyYW5jaDogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPixcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+W10gfCBudWxsIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuXG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXM6IEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gcGF0aG5hbWVcbiAgICAgICAgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG5cbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuXG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIC8vIFRPRE86IENhbiB0aGlzIGFzIGJlIGF2b2lkZWQ/XG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMgYXMgUGFyYW1zPFBhcmFtS2V5PixcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlLFxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9nZW5lcmF0ZS1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhdGg8UGF0aCBleHRlbmRzIHN0cmluZz4oXG4gIG9yaWdpbmFsUGF0aDogUGF0aCxcbiAgcGFyYW1zOiB7XG4gICAgW2tleSBpbiBQYXRoUGFyYW08UGF0aD5dOiBzdHJpbmcgfCBudWxsO1xuICB9ID0ge30gYXMgYW55XG4pOiBzdHJpbmcge1xuICBsZXQgcGF0aDogc3RyaW5nID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgICBgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBgICtcbiAgICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgICApO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpIGFzIFBhdGg7XG4gIH1cblxuICAvLyBlbnN1cmUgYC9gIGlzIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGVcbiAgY29uc3QgcHJlZml4ID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIjtcblxuICBjb25zdCBzdHJpbmdpZnkgPSAocDogYW55KSA9PlxuICAgIHAgPT0gbnVsbCA/IFwiXCIgOiB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHAgOiBTdHJpbmcocCk7XG5cbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoXG4gICAgLnNwbGl0KC9cXC8rLylcbiAgICAubWFwKChzZWdtZW50LCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcblxuICAgICAgLy8gb25seSBhcHBseSB0aGUgc3BsYXQgaWYgaXQncyB0aGUgbGFzdCBzZWdtZW50XG4gICAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgICBjb25zdCBzdGFyID0gXCIqXCIgYXMgUGF0aFBhcmFtPFBhdGg+O1xuICAgICAgICAvLyBBcHBseSB0aGUgc3BsYXRcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbXNbc3Rhcl0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFxcdyspKFxcPz8pJC8pO1xuICAgICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICAgIGNvbnN0IFssIGtleSwgb3B0aW9uYWxdID0ga2V5TWF0Y2g7XG4gICAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXkgYXMgUGF0aFBhcmFtPFBhdGg+XTtcbiAgICAgICAgaW52YXJpYW50KG9wdGlvbmFsID09PSBcIj9cIiB8fCBwYXJhbSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGFueSBvcHRpb25hbCBtYXJrZXJzIGZyb20gb3B0aW9uYWwgc3RhdGljIHNlZ21lbnRzXG4gICAgICByZXR1cm4gc2VnbWVudC5yZXBsYWNlKC9cXD8kL2csIFwiXCIpO1xuICAgIH0pXG4gICAgLy8gUmVtb3ZlIGVtcHR5IHNlZ21lbnRzXG4gICAgLmZpbHRlcigoc2VnbWVudCkgPT4gISFzZWdtZW50KTtcblxuICByZXR1cm4gcHJlZml4ICsgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5cbi8qKlxuICogQSBQYXRoUGF0dGVybiBpcyB1c2VkIHRvIG1hdGNoIG9uIHNvbWUgcG9ydGlvbiBvZiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoUGF0dGVybjxQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0IGEgVVJMIHBhdGhuYW1lLiBNYXkgY29udGFpbiBgOmlkYC1zdHlsZSBzZWdtZW50c1xuICAgKiB0byBpbmRpY2F0ZSBwbGFjZWhvbGRlcnMgZm9yIGR5bmFtaWMgcGFyYW1ldGVycy4gTWF5IGFsc28gZW5kIHdpdGggYC8qYCB0b1xuICAgKiBpbmRpY2F0ZSBtYXRjaGluZyB0aGUgcmVzdCBvZiB0aGUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgcGF0aDogUGF0aDtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhlIHN0YXRpYyBwb3J0aW9ucyBvZiB0aGUgYHBhdGhgIHNob3VsZCBiZSBtYXRjaGVkIGluXG4gICAqIHRoZSBzYW1lIGNhc2UuXG4gICAqL1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhpcyBwYXR0ZXJuIHNob3VsZCBtYXRjaCB0aGUgZW50aXJlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIGVuZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSBQYXRoTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSBQYXRoUGF0dGVybiBtYXRjaGVkIG9uIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhNYXRjaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwYXR0ZXJuIHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjtcbn1cblxudHlwZSBNdXRhYmxlPFQ+ID0ge1xuICAtcmVhZG9ubHkgW1AgaW4ga2V5b2YgVF06IFRbUF07XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHBhdHRlcm4gbWF0Y2hpbmcgb24gYSBVUkwgcGF0aG5hbWUgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHRoZSBtYXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUGF0aDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KFxuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKVxuICAgICAgICAgIC5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIixcbiAgICAgICAgcGFyYW1OYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm4sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgZW5kID0gdHJ1ZVxuKTogW1JlZ0V4cCwgc3RyaW5nW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9XG4gICAgXCJeXCIgK1xuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAgICAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgICAgIC5yZXBsYWNlKC9bXFxcXC4qK14kP3t9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC9cXC86KFxcdyspL2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gXCIvKFteXFxcXC9dKylcIjtcbiAgICAgIH0pO1xuXG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtTmFtZXMucHVzaChcIipcIik7XG4gICAgcmVnZXhwU291cmNlICs9XG4gICAgICBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCJcbiAgICAgICAgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcbiAgICAgICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCwgc28gd2Ugc2hvdWxkIGV4cGVjdCB0b1xuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcbiAgICAvLyBub24tY2FwdHVyZWQgdHJhaWxpbmcgc2xhc2ggKHRvIG1hdGNoIGEgcG9ydGlvbiBvZiB0aGUgVVJMKSBvciB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHBhdGggKGlmIHdlJ3ZlIG1hdGNoZWQgdG8gdGhlIGVuZCkuICBXZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBhXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcbiAgICAvLyAvdXNlci1wcmVmZXJlbmNlcyBzaW5jZSBgLWAgY291bnRzIGFzIGEgd29yZCBib3VuZGFyeS5cbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3RoaW5nIHRvIG1hdGNoIGZvciBcIlwiIG9yIFwiL1wiXG4gIH1cblxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xuXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1OYW1lc107XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSSh2YWx1ZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSBVUkwgcGF0aCBcIiR7dmFsdWV9XCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBpcyBhIGAgK1xuICAgICAgICBgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5IGR1ZSB0byBhIGJhZCBwZXJjZW50IGAgK1xuICAgICAgICBgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQodmFsdWU6IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgVGhlIHZhbHVlIGZvciB0aGUgVVJMIHBhcmFtIFwiJHtwYXJhbU5hbWV9XCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlYCArXG4gICAgICAgIGAgdGhlIHN0cmluZyBcIiR7dmFsdWV9XCIgaXMgYSBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHlgICtcbiAgICAgICAgYCBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIGJhc2VuYW1lOiBzdHJpbmdcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG5cbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFdlIHdhbnQgdG8gbGVhdmUgdHJhaWxpbmcgc2xhc2ggYmVoYXZpb3IgaW4gdGhlIHVzZXIncyBjb250cm9sLCBzbyBpZiB0aGV5XG4gIC8vIHNwZWNpZnkgYSBiYXNlbmFtZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2gsIHdlIHNob3VsZCBzdXBwb3J0IGl0XG4gIGxldCBzdGFydEluZGV4ID0gYmFzZW5hbWUuZW5kc1dpdGgoXCIvXCIpXG4gICAgPyBiYXNlbmFtZS5sZW5ndGggLSAxXG4gICAgOiBiYXNlbmFtZS5sZW5ndGg7XG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChzdGFydEluZGV4KTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIC8vIHBhdGhuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggYmFzZW5hbWUvXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWUuc2xpY2Uoc3RhcnRJbmRleCkgfHwgXCIvXCI7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG86IFRvLCBmcm9tUGF0aG5hbWUgPSBcIi9cIik6IFBhdGgge1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG5cbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZVxuICAgID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgPyB0b1BhdGhuYW1lXG4gICAgICA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpXG4gICAgOiBmcm9tUGF0aG5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGg6IHN0cmluZywgZnJvbVBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcblxuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkUGF0aEVycm9yKFxuICBjaGFyOiBzdHJpbmcsXG4gIGZpZWxkOiBzdHJpbmcsXG4gIGRlc3Q6IHN0cmluZyxcbiAgcGF0aDogUGFydGlhbDxQYXRoPlxuKSB7XG4gIHJldHVybiAoXG4gICAgYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBgICtcbiAgICBgXFxgdG8uJHtmaWVsZH1cXGAgZmllbGQgWyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBwYXRoXG4gICAgKX1dLiAgUGxlYXNlIHNlcGFyYXRlIGl0IG91dCB0byB0aGUgYCArXG4gICAgYFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYCArXG4gICAgYGEgc3RyaW5nIGluIDxMaW5rIHRvPVwiLi4uXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5gXG4gICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlczxcbiAgVCBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaCA9IEFnbm9zdGljUm91dGVNYXRjaFxuPihtYXRjaGVzOiBUW10pIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKFxuICAgIChtYXRjaCwgaW5kZXgpID0+XG4gICAgICBpbmRleCA9PT0gMCB8fCAobWF0Y2gucm91dGUucGF0aCAmJiBtYXRjaC5yb3V0ZS5wYXRoLmxlbmd0aCA+IDApXG4gICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVUbyhcbiAgdG9Bcmc6IFRvLFxuICByb3V0ZVBhdGhuYW1lczogc3RyaW5nW10sXG4gIGxvY2F0aW9uUGF0aG5hbWU6IHN0cmluZyxcbiAgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZVxuKTogUGF0aCB7XG4gIGxldCB0bzogUGFydGlhbDxQYXRoPjtcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IHsgLi4udG9BcmcgfTtcblxuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJwYXRobmFtZVwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gIH1cblxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG5cbiAgbGV0IGZyb206IHN0cmluZztcblxuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmIChpc1BhdGhSZWxhdGl2ZSB8fCB0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgLy8gRWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnMgXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lXG4gICAgICAvLyBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleSBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhXG4gICAgICAvLyBtYWpvciByZWFzb24gd2UgY2FsbCB0aGlzIGEgXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCBcInRvXCIgaGFkIG9uZVxuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID1cbiAgICB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPVxuICAgIChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGlmIChcbiAgICAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKVxuICApIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG86IFRvKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCAodG8gYXMgUGF0aCkucGF0aG5hbWUgPT09IFwiXCJcbiAgICA/IFwiL1wiXG4gICAgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCJcbiAgICA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWVcbiAgICA6IHRvLnBhdGhuYW1lO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBqb2luUGF0aHMgPSAocGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+XG4gIHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZTogc3RyaW5nKTogc3RyaW5nID0+XG4gIHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IChzZWFyY2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCJcbiAgICA/IFwiXCJcbiAgICA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKVxuICAgID8gc2VhcmNoXG4gICAgOiBcIj9cIiArIHNlYXJjaDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplSGFzaCA9IChoYXNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG5cbmV4cG9ydCB0eXBlIEpzb25GdW5jdGlvbiA9IDxEYXRhPihcbiAgZGF0YTogRGF0YSxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5leHBvcnQgY29uc3QganNvbjogSnNvbkZ1bmN0aW9uID0gKGRhdGEsIGluaXQgPSB7fSkgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZWRQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTxhbnk+IHtcbiAgX3RyYWNrZWQ/OiBib29sZWFuO1xuICBfZGF0YT86IGFueTtcbiAgX2Vycm9yPzogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQWJvcnRlZERlZmVycmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWREYXRhIHtcbiAgcHJpdmF0ZSBwZW5kaW5nS2V5c1NldDogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG4gIHByaXZhdGUgYWJvcnRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICBwcml2YXRlIHVubGlzdGVuQWJvcnRTaWduYWw6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgc3Vic2NyaWJlcnM6IFNldDwoYWJvcnRlZDogYm9vbGVhbiwgc2V0dGxlZEtleT86IHN0cmluZykgPT4gdm9pZD4gPVxuICAgIG5ldyBTZXQoKTtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIGluaXQ/OiBSZXNwb25zZUluaXQ7XG4gIGRlZmVycmVkS2V5czogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgcmVzcG9uc2VJbml0PzogUmVzcG9uc2VJbml0KSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSxcbiAgICAgIFwiZGVmZXIoKSBvbmx5IGFjY2VwdHMgcGxhaW4gb2JqZWN0c1wiXG4gICAgKTtcblxuICAgIC8vIFNldCB1cCBhbiBBYm9ydENvbnRyb2xsZXIgKyBQcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3QgdG8gZXhpdCBlYXJseVxuICAgIC8vIGNhbmNlbGxhdGlvblxuICAgIGxldCByZWplY3Q6IChlOiBBYm9ydGVkRGVmZXJyZWRFcnJvcikgPT4gdm9pZDtcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiAocmVqZWN0ID0gcikpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgb25BYm9ydCA9ICgpID0+XG4gICAgICByZWplY3QobmV3IEFib3J0ZWREZWZlcnJlZEVycm9yKFwiRGVmZXJyZWQgZGF0YSBhYm9ydGVkXCIpKTtcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PlxuICAgICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG5cbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW2tleV06IHRoaXMudHJhY2tQcm9taXNlKGtleSwgdmFsdWUpLFxuICAgICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIC8vIEFsbCBpbmNvbWluZyB2YWx1ZXMgd2VyZSByZXNvbHZlZFxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0ID0gcmVzcG9uc2VJbml0O1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFja1Byb21pc2UoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IFByb21pc2U8dW5rbm93bj4gfCB1bmtub3duXG4gICk6IFRyYWNrZWRQcm9taXNlIHwgdW5rbm93biB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuZGVmZXJyZWRLZXlzLnB1c2goa2V5KTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmFkZChrZXkpO1xuXG4gICAgLy8gV2Ugc3RvcmUgYSBsaXR0bGUgd3JhcHBlciBwcm9taXNlIHRoYXQgd2lsbCBiZSBleHRlbmRlZCB3aXRoXG4gICAgLy8gX2RhdGEvX2Vycm9yIHByb3BzIHVwb24gcmVzb2x2ZS9yZWplY3RcbiAgICBsZXQgcHJvbWlzZTogVHJhY2tlZFByb21pc2UgPSBQcm9taXNlLnJhY2UoW3ZhbHVlLCB0aGlzLmFib3J0UHJvbWlzZV0pLnRoZW4oXG4gICAgICAoZGF0YSkgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIHVuZGVmaW5lZCwgZGF0YSBhcyB1bmtub3duKSxcbiAgICAgIChlcnJvcikgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yIGFzIHVua25vd24pXG4gICAgKTtcblxuICAgIC8vIFJlZ2lzdGVyIHJlamVjdGlvbiBsaXN0ZW5lcnMgdG8gYXZvaWQgdW5jYXVnaHQgcHJvbWlzZSByZWplY3Rpb25zIG9uXG4gICAgLy8gZXJyb3JzIG9yIGFib3J0ZWQgZGVmZXJyZWQgdmFsdWVzXG4gICAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgb25TZXR0bGUoXG4gICAgcHJvbWlzZTogVHJhY2tlZFByb21pc2UsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZXJyb3I6IHVua25vd24sXG4gICAgZGF0YT86IHVua25vd25cbiAgKTogdW5rbm93biB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkICYmXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yXG4gICAgKSB7XG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBOb3RoaW5nIGxlZnQgdG8gYWJvcnQhXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcHJvbWlzZSB3YXMgcmVzb2x2ZWQvcmVqZWN0ZWQgd2l0aCB1bmRlZmluZWQsIHdlJ2xsIHRocm93IGFuIGVycm9yIGFzIHlvdVxuICAgIC8vIHNob3VsZCBhbHdheXMgcmVzb2x2ZSB3aXRoIGEgdmFsdWUgb3IgbnVsbFxuICAgIGlmIChlcnJvciA9PT0gdW5kZWZpbmVkICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHVuZGVmaW5lZEVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgRGVmZXJyZWQgZGF0YSBmb3Iga2V5IFwiJHtrZXl9XCIgcmVzb2x2ZWQvcmVqZWN0ZWQgd2l0aCBcXGB1bmRlZmluZWRcXGAsIGAgK1xuICAgICAgICAgIGB5b3UgbXVzdCByZXNvbHZlL3JlamVjdCB3aXRoIGEgdmFsdWUgb3IgXFxgbnVsbFxcYC5gXG4gICAgICApO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiB1bmRlZmluZWRFcnJvciB9KTtcbiAgICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh1bmRlZmluZWRFcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KTtcbiAgICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IGRhdGEgfSk7XG4gICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0KGFib3J0ZWQ6IGJvb2xlYW4sIHNldHRsZWRLZXk/OiBzdHJpbmcpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoYWJvcnRlZCwgc2V0dGxlZEtleSkpO1xuICB9XG5cbiAgc3Vic2NyaWJlKGZuOiAoYWJvcnRlZDogYm9vbGVhbiwgc2V0dGxlZEtleT86IHN0cmluZykgPT4gdm9pZCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZm9yRWFjaCgodiwgaykgPT4gdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoaykpO1xuICAgIHRoaXMuZW1pdCh0cnVlKTtcbiAgfVxuXG4gIGFzeW5jIHJlc29sdmVEYXRhKHNpZ25hbDogQWJvcnRTaWduYWwpIHtcbiAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5kb25lKSB7XG4gICAgICBsZXQgb25BYm9ydCA9ICgpID0+IHRoaXMuY2FuY2VsKCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgYWJvcnRlZCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKChhYm9ydGVkKSA9PiB7XG4gICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgICAgICBpZiAoYWJvcnRlZCB8fCB0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoYWJvcnRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYWJvcnRlZDtcbiAgfVxuXG4gIGdldCBkb25lKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdLZXlzU2V0LnNpemUgPT09IDA7XG4gIH1cblxuICBnZXQgdW53cmFwcGVkRGF0YSgpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICB0aGlzLmRhdGEgIT09IG51bGwgJiYgdGhpcy5kb25lLFxuICAgICAgXCJDYW4gb25seSB1bndyYXAgZGF0YSBvbiBpbml0aWFsaXplZCBhbmQgc2V0dGxlZCBkZWZlcnJlZHNcIlxuICAgICk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5kYXRhKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW2tleV06IHVud3JhcFRyYWNrZWRQcm9taXNlKHZhbHVlKSxcbiAgICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH1cblxuICBnZXQgcGVuZGluZ0tleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nS2V5c1NldCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUcmFja2VkUHJvbWlzZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgVHJhY2tlZFByb21pc2Uge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiAodmFsdWUgYXMgVHJhY2tlZFByb21pc2UpLl90cmFja2VkID09PSB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcFRyYWNrZWRQcm9taXNlKHZhbHVlOiBhbnkpIHtcbiAgaWYgKCFpc1RyYWNrZWRQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5fZXJyb3IpIHtcbiAgICB0aHJvdyB2YWx1ZS5fZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLl9kYXRhO1xufVxuXG5leHBvcnQgdHlwZSBEZWZlckZ1bmN0aW9uID0gKFxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBEZWZlcnJlZERhdGE7XG5cbmV4cG9ydCBjb25zdCBkZWZlcjogRGVmZXJGdW5jdGlvbiA9IChkYXRhLCBpbml0ID0ge30pID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8geyBzdGF0dXM6IGluaXQgfSA6IGluaXQ7XG5cbiAgcmV0dXJuIG5ldyBEZWZlcnJlZERhdGEoZGF0YSwgcmVzcG9uc2VJbml0KTtcbn07XG5cbmV4cG9ydCB0eXBlIFJlZGlyZWN0RnVuY3Rpb24gPSAoXG4gIHVybDogc3RyaW5nLFxuICBpbml0PzogbnVtYmVyIHwgUmVzcG9uc2VJbml0XG4pID0+IFJlc3BvbnNlO1xuXG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UuIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxuICovXG5leHBvcnQgY29uc3QgcmVkaXJlY3Q6IFJlZGlyZWN0RnVuY3Rpb24gPSAodXJsLCBpbml0ID0gMzAyKSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHsgc3RhdHVzOiByZXNwb25zZUluaXQgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgIC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzLFxuICB9KTtcbn07XG5cbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZSB0aGF0IHdpbGwgZm9yY2UgYSBkb2N1bWVudCByZWxvYWQgdG8gdGhlIG5ldyBsb2NhdGlvbi5cbiAqIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxuICovXG5leHBvcnQgY29uc3QgcmVkaXJlY3REb2N1bWVudDogUmVkaXJlY3RGdW5jdGlvbiA9ICh1cmwsIGluaXQpID0+IHtcbiAgbGV0IHJlc3BvbnNlID0gcmVkaXJlY3QodXJsLCBpbml0KTtcbiAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFV0aWxpdHkgY2xhc3Mgd2UgdXNlIHRvIGhvbGQgYXV0by11bndyYXBwZWQgNHh4LzV4eCBSZXNwb25zZSBib2RpZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yUmVzcG9uc2VJbXBsIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIHN0YXR1c1RleHQ6IHN0cmluZztcbiAgZGF0YTogYW55O1xuICBwcml2YXRlIGVycm9yPzogRXJyb3I7XG4gIHByaXZhdGUgaW50ZXJuYWw6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhdHVzOiBudW1iZXIsXG4gICAgc3RhdHVzVGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGRhdGE6IGFueSxcbiAgICBpbnRlcm5hbCA9IGZhbHNlXG4gICkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG59XG5cbi8vIFdlIGRvbid0IHdhbnQgdGhlIGNsYXNzIGV4cG9ydGVkIHNpbmNlIHVzYWdlIG9mIGl0IGF0IHJ1bnRpbWUgaXMgYW5cbi8vIGltcGxlbWVudGF0aW9uIGRldGFpbCwgYnV0IHdlIGRvIHdhbnQgdG8gZXhwb3J0IHRoZSBzaGFwZSBzbyBmb2xrcyBjYW5cbi8vIGJ1aWxkIHRoZWlyIG93biBhYnN0cmFjdGlvbnMgYXJvdW5kIGluc3RhbmNlcyB2aWEgaXNSb3V0ZUVycm9yUmVzcG9uc2UoKVxuZXhwb3J0IHR5cGUgRXJyb3JSZXNwb25zZSA9IEluc3RhbmNlVHlwZTx0eXBlb2YgRXJyb3JSZXNwb25zZUltcGw+O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBFcnJvclJlc3BvbnNlIGdlbmVyYXRlZCBmcm9tIGEgNHh4LzV4eFxuICogUmVzcG9uc2UgdGhyb3duIGZyb20gYW4gYWN0aW9uL2xvYWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3I6IGFueSk6IGVycm9yIGlzIEVycm9yUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIGVycm9yICE9IG51bGwgJiZcbiAgICB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmXG4gICAgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiZcbiAgICB0eXBlb2YgZXJyb3IuaW50ZXJuYWwgPT09IFwiYm9vbGVhblwiICYmXG4gICAgXCJkYXRhXCIgaW4gZXJyb3JcbiAgKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgSGlzdG9yeSwgTG9jYXRpb24sIFBhdGgsIFRvIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIEhpc3RvcnlBY3Rpb24sXG4gIGNyZWF0ZUxvY2F0aW9uLFxuICBjcmVhdGVQYXRoLFxuICBpbnZhcmlhbnQsXG4gIHBhcnNlUGF0aCxcbiAgd2FybmluZyxcbn0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHR5cGUge1xuICBBY3Rpb25GdW5jdGlvbixcbiAgQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIEFnbm9zdGljUm91dGVPYmplY3QsXG4gIERhdGFSZXN1bHQsXG4gIERlZmVycmVkRGF0YSxcbiAgRGVmZXJyZWRSZXN1bHQsXG4gIERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbixcbiAgRXJyb3JSZXN1bHQsXG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBIVE1MRm9ybU1ldGhvZCxcbiAgSW1tdXRhYmxlUm91dGVLZXksXG4gIExvYWRlckZ1bmN0aW9uLFxuICBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgTXV0YXRpb25Gb3JtTWV0aG9kLFxuICBSZWRpcmVjdFJlc3VsdCxcbiAgUm91dGVEYXRhLFxuICBSb3V0ZU1hbmlmZXN0LFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzLFxuICBTdWJtaXNzaW9uLFxuICBTdWNjZXNzUmVzdWx0LFxuICBVSU1hdGNoLFxuICBWN19Gb3JtTWV0aG9kLFxuICBWN19NdXRhdGlvbkZvcm1NZXRob2QsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQge1xuICBFcnJvclJlc3BvbnNlSW1wbCxcbiAgUmVzdWx0VHlwZSxcbiAgY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsXG4gIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsXG4gIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzLFxuICBpbW11dGFibGVSb3V0ZUtleXMsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqb2luUGF0aHMsXG4gIG1hdGNoUm91dGVzLFxuICByZXNvbHZlVG8sXG4gIHN0cmlwQmFzZW5hbWUsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIFJvdXRlciBpbnN0YW5jZSBtYW5hZ2VzIGFsbCBuYXZpZ2F0aW9uIGFuZCBkYXRhIGxvYWRpbmcvbXV0YXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIGJhc2VuYW1lIGZvciB0aGUgcm91dGVyXG4gICAqL1xuICBnZXQgYmFzZW5hbWUoKTogUm91dGVySW5pdFtcImJhc2VuYW1lXCJdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByb3V0ZXJcbiAgICovXG4gIGdldCBzdGF0ZSgpOiBSb3V0ZXJTdGF0ZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgcm91dGVzIGZvciB0aGlzIHJvdXRlciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHJvdXRlcygpOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBpbmNsdWRpbmcgYWRkaW5nIGhpc3RvcnkgbGlzdGVuZXJzIGFuZCBraWNraW5nIG9mZlxuICAgKiBpbml0aWFsIGRhdGEgZmV0Y2hlcy4gIFJldHVybnMgYSBmdW5jdGlvbiB0byBjbGVhbnVwIGxpc3RlbmVycyBhbmQgYWJvcnRcbiAgICogYW55IGluLXByb2dyZXNzIGxvYWRzXG4gICAqL1xuICBpbml0aWFsaXplKCk6IFJvdXRlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFN1YnNjcmliZSB0byByb3V0ZXIuc3RhdGUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBuZXcgc3RhdGVcbiAgICovXG4gIHN1YnNjcmliZShmbjogUm91dGVyU3Vic2NyaWJlcik6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGJlaGF2aW9yIGluIHRoZSByb3V0ZXJcbiAgICpcbiAgICogQHBhcmFtIHNhdmVkU2Nyb2xsUG9zaXRpb25zIE9iamVjdCB0aGF0IHdpbGwgbWFuYWdlIHBvc2l0aW9ucywgaW4gY2FzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQncyBiZWluZyByZXN0b3JlZCBmcm9tIHNlc3Npb25TdG9yYWdlXG4gICAqIEBwYXJhbSBnZXRTY3JvbGxQb3NpdGlvbiAgICBGdW5jdGlvbiB0byBnZXQgdGhlIGFjdGl2ZSBZIHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0gZ2V0S2V5ICAgICAgICAgICAgICAgRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgdG8gdXNlIGZvciByZXN0b3JhdGlvblxuICAgKi9cbiAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24sXG4gICAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvblxuICApOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogTmF2aWdhdGUgZm9yd2FyZC9iYWNrd2FyZCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBAcGFyYW0gdG8gRGVsdGEgdG8gbW92ZSBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKi9cbiAgbmF2aWdhdGUodG86IG51bWJlcik6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBnaXZlbiBwYXRoXG4gICAqIEBwYXJhbSB0byBQYXRoIHRvIG5hdmlnYXRlIHRvXG4gICAqIEBwYXJhbSBvcHRzIE5hdmlnYXRpb24gb3B0aW9ucyAobWV0aG9kLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgKi9cbiAgbmF2aWdhdGUodG86IFRvIHwgbnVsbCwgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pc3Npb25cbiAgICpcbiAgICogQHBhcmFtIGtleSAgICAgRmV0Y2hlciBrZXlcbiAgICogQHBhcmFtIHJvdXRlSWQgUm91dGUgdGhhdCBvd25zIHRoZSBmZXRjaGVyXG4gICAqIEBwYXJhbSBocmVmICAgIGhyZWYgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdHMgICAgRmV0Y2hlciBvcHRpb25zLCAobWV0aG9kLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgKi9cbiAgZmV0Y2goXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIGhyZWY6IHN0cmluZyB8IG51bGwsXG4gICAgb3B0cz86IFJvdXRlckZldGNoT3B0aW9uc1xuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIHJldmFsaWRhdGlvbiBvZiBhbGwgY3VycmVudCByb3V0ZSBsb2FkZXJzIGFuZCBmZXRjaGVyIGxvYWRzXG4gICAqL1xuICByZXZhbGlkYXRlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBocmVmIGZvciB0aGUgZ2l2ZW4gbG9jYXRpb25cbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqL1xuICBjcmVhdGVIcmVmKGxvY2F0aW9uOiBMb2NhdGlvbiB8IFVSTCk6IHN0cmluZztcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gVVJMIGVuY29kZSBhIGRlc3RpbmF0aW9uIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBpbnRlcm5hbFxuICAgKiBoaXN0b3J5IGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB0b1xuICAgKi9cbiAgZW5jb2RlTG9jYXRpb24odG86IFRvKTogUGF0aDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEdldC9jcmVhdGUgYSBmZXRjaGVyIGZvciB0aGUgZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIGdldEZldGNoZXI8VERhdGEgPSBhbnk+KGtleT86IHN0cmluZyk6IEZldGNoZXI8VERhdGE+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRGVsZXRlIHRoZSBmZXRjaGVyIGZvciBhIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBkZWxldGVGZXRjaGVyKGtleT86IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBDbGVhbnVwIGxpc3RlbmVycyBhbmQgYWJvcnQgYW55IGluLXByb2dyZXNzIGxvYWRzXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBHZXQgYSBuYXZpZ2F0aW9uIGJsb2NrZXJcbiAgICogQHBhcmFtIGtleSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrZXJcbiAgICogQHBhcmFtIGZuIFRoZSBibG9ja2VyIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBnZXRCbG9ja2VyKGtleTogc3RyaW5nLCBmbjogQmxvY2tlckZ1bmN0aW9uKTogQmxvY2tlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIERlbGV0ZSBhIG5hdmlnYXRpb24gYmxvY2tlclxuICAgKiBAcGFyYW0ga2V5IFRoZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tlclxuICAgKi9cbiAgZGVsZXRlQmxvY2tlcihrZXk6IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBITVIgbmVlZHMgdG8gcGFzcyBpbi1mbGlnaHQgcm91dGUgdXBkYXRlcyB0byBSZWFjdCBSb3V0ZXJcbiAgICogVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggZ3JhbnVsYXIgcm91dGUgdXBkYXRlIEFQSXMgKGFkZFJvdXRlLCB1cGRhdGVSb3V0ZSwgZGVsZXRlUm91dGUpXG4gICAqL1xuICBfaW50ZXJuYWxTZXRSb3V0ZXMocm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W10pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW50ZXJuYWwgZmV0Y2ggQWJvcnRDb250cm9sbGVycyBhY2Nlc3NlZCBieSB1bml0IHRlc3RzXG4gICAqL1xuICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW50ZXJuYWwgcGVuZGluZyBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGFjY2Vzc2VkIGJ5IHVuaXQgdGVzdHNcbiAgICovXG4gIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPjtcbn1cblxuLyoqXG4gKiBTdGF0ZSBtYWludGFpbmVkIGludGVybmFsbHkgYnkgdGhlIHJvdXRlci4gIER1cmluZyBhIG5hdmlnYXRpb24sIGFsbCBzdGF0ZXNcbiAqIHJlZmxlY3QgdGhlIHRoZSBcIm9sZFwiIGxvY2F0aW9uIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyU3RhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiBvZiB0aGUgbW9zdCByZWNlbnQgbmF2aWdhdGlvblxuICAgKi9cbiAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbG9jYXRpb24gcmVmbGVjdGVkIGJ5IHRoZSByb3V0ZXJcbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2V0IG9mIHJvdXRlIG1hdGNoZXNcbiAgICovXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcblxuICAvKipcbiAgICogVHJhY2tzIHdoZXRoZXIgd2UndmUgY29tcGxldGVkIG91ciBpbml0aWFsIGRhdGEgbG9hZFxuICAgKi9cbiAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHdlIHNob3VsZCBzdGFydCBhdCBmb3IgYSBuZXcgdmlld1xuICAgKiAgLSBudW1iZXIgLT4gc2Nyb2xsIHBvc2l0aW9uIHRvIHJlc3RvcmUgdG9cbiAgICogIC0gZmFsc2UgLT4gZG8gbm90IHJlc3RvcmUgc2Nyb2xsIGF0IGFsbCAodXNlZCBkdXJpbmcgc3VibWlzc2lvbnMpXG4gICAqICAtIG51bGwgLT4gZG9uJ3QgaGF2ZSBhIHNhdmVkIHBvc2l0aW9uLCBzY3JvbGwgdG8gaGFzaCBvciB0b3Agb2YgcGFnZVxuICAgKi9cbiAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBudW1iZXIgfCBmYWxzZSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhpcyBuYXZpZ2F0aW9uIHNob3VsZCBza2lwIHJlc2V0dGluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIGlmIHdlIGFyZSB1bmFibGUgdG8gcmVzdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqL1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgbmF2aWdhdGlvblxuICAgKi9cbiAgbmF2aWdhdGlvbjogTmF2aWdhdGlvbjtcblxuICAvKipcbiAgICogVHJhY2tzIGFueSBpbi1wcm9ncmVzcyByZXZhbGlkYXRpb25zXG4gICAqL1xuICByZXZhbGlkYXRpb246IFJldmFsaWRhdGlvblN0YXRlO1xuXG4gIC8qKlxuICAgKiBEYXRhIGZyb20gdGhlIGxvYWRlcnMgZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YTtcblxuICAvKipcbiAgICogRGF0YSBmcm9tIHRoZSBhY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGFjdGlvbkRhdGE6IFJvdXRlRGF0YSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEVycm9ycyBjYXVnaHQgZnJvbSBsb2FkZXJzIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBlcnJvcnM6IFJvdXRlRGF0YSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBjdXJyZW50IGZldGNoZXJzXG4gICAqL1xuICBmZXRjaGVyczogTWFwPHN0cmluZywgRmV0Y2hlcj47XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBjdXJyZW50IGJsb2NrZXJzXG4gICAqL1xuICBibG9ja2VyczogTWFwPHN0cmluZywgQmxvY2tlcj47XG59XG5cbi8qKlxuICogRGF0YSB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byBoeWRyYXRlIGEgUm91dGVyIGZyb20gU1NSXG4gKi9cbmV4cG9ydCB0eXBlIEh5ZHJhdGlvblN0YXRlID0gUGFydGlhbDxcbiAgUGljazxSb3V0ZXJTdGF0ZSwgXCJsb2FkZXJEYXRhXCIgfCBcImFjdGlvbkRhdGFcIiB8IFwiZXJyb3JzXCI+XG4+O1xuXG4vKipcbiAqIEZ1dHVyZSBmbGFncyB0byB0b2dnbGUgbmV3IGZlYXR1cmUgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGdXR1cmVDb25maWcge1xuICB2N19ub3JtYWxpemVGb3JtTWV0aG9kOiBib29sZWFuO1xuICB2N19wcmVwZW5kQmFzZW5hbWU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gb3B0aW9ucyBmb3IgY3JlYXRlUm91dGVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVySW5pdCB7XG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWFwUm91dGVQcm9wZXJ0aWVzYCBpbnN0ZWFkXG4gICAqL1xuICBkZXRlY3RFcnJvckJvdW5kYXJ5PzogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uO1xuICBtYXBSb3V0ZVByb3BlcnRpZXM/OiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbjtcbiAgZnV0dXJlPzogUGFydGlhbDxGdXR1cmVDb25maWc+O1xuICBoeWRyYXRpb25EYXRhPzogSHlkcmF0aW9uU3RhdGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBTdGF0ZSByZXR1cm5lZCBmcm9tIGEgc2VydmVyLXNpZGUgcXVlcnkoKSBjYWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlckNvbnRleHQge1xuICBiYXNlbmFtZTogUm91dGVyW1wiYmFzZW5hbWVcIl07XG4gIGxvY2F0aW9uOiBSb3V0ZXJTdGF0ZVtcImxvY2F0aW9uXCJdO1xuICBtYXRjaGVzOiBSb3V0ZXJTdGF0ZVtcIm1hdGNoZXNcIl07XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgYWN0aW9uRGF0YTogUm91dGVyU3RhdGVbXCJhY3Rpb25EYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+O1xuICBhY3Rpb25IZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aXZlRGVmZXJyZWRzOiBSZWNvcmQ8c3RyaW5nLCBEZWZlcnJlZERhdGE+IHwgbnVsbDtcbiAgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQ/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgU3RhdGljSGFuZGxlciBpbnN0YW5jZSBtYW5hZ2VzIGEgc2luZ3VsYXIgU1NSIG5hdmlnYXRpb24vZmV0Y2ggZXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNIYW5kbGVyIHtcbiAgZGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBvcHRzPzogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd24gfVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+O1xuICBxdWVyeVJvdXRlKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgb3B0cz86IHsgcm91dGVJZD86IHN0cmluZzsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH1cbiAgKTogUHJvbWlzZTxhbnk+O1xufVxuXG4vKipcbiAqIFN1YnNjcmliZXIgZnVuY3Rpb24gc2lnbmF0dXJlIGZvciBjaGFuZ2VzIHRvIHJvdXRlciBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN1YnNjcmliZXIge1xuICAoc3RhdGU6IFJvdXRlclN0YXRlKTogdm9pZDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBzaWduYXR1cmUgZm9yIGRldGVybWluaW5nIHRoZSBrZXkgdG8gYmUgdXNlZCBpbiBzY3JvbGwgcmVzdG9yYXRpb25cbiAqIGZvciBhIGdpdmVuIGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB7XG4gIChsb2NhdGlvbjogTG9jYXRpb24sIG1hdGNoZXM6IFVJTWF0Y2hbXSk6IHN0cmluZyB8IG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc2lnbmF0dXJlIGZvciBkZXRlcm1pbmluZyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uIHtcbiAgKCk6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgUmVsYXRpdmVSb3V0aW5nVHlwZSA9IFwicm91dGVcIiB8IFwicGF0aFwiO1xuXG4vLyBBbGxvd2VkIGZvciBhbnkgbmF2aWdhdGlvbiBvciBmZXRjaFxudHlwZSBCYXNlTmF2aWdhdGVPckZldGNoT3B0aW9ucyA9IHtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xufTtcblxuLy8gT25seSBhbGxvd2VkIGZvciBuYXZpZ2F0aW9uc1xudHlwZSBCYXNlTmF2aWdhdGVPcHRpb25zID0gQmFzZU5hdmlnYXRlT3JGZXRjaE9wdGlvbnMgJiB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgZnJvbVJvdXRlSWQ/OiBzdHJpbmc7XG59O1xuXG4vLyBPbmx5IGFsbG93ZWQgZm9yIHN1Ym1pc3Npb24gbmF2aWdhdGlvbnNcbnR5cGUgQmFzZVN1Ym1pc3Npb25PcHRpb25zID0ge1xuICBmb3JtTWV0aG9kPzogSFRNTEZvcm1NZXRob2Q7XG4gIGZvcm1FbmNUeXBlPzogRm9ybUVuY1R5cGU7XG59ICYgKFxuICB8IHsgZm9ybURhdGE6IEZvcm1EYXRhOyBib2R5PzogdW5kZWZpbmVkIH1cbiAgfCB7IGZvcm1EYXRhPzogdW5kZWZpbmVkOyBib2R5OiBhbnkgfVxuKTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIG5hdmlnYXRlKCkgY2FsbCBmb3IgYSBub3JtYWwgKG5vbi1zdWJtaXNzaW9uKSBuYXZpZ2F0aW9uXG4gKi9cbnR5cGUgTGlua05hdmlnYXRlT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9wdGlvbnM7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBuYXZpZ2F0ZSgpIGNhbGwgZm9yIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uXG4gKi9cbnR5cGUgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9wdGlvbnMgJiBCYXNlU3VibWlzc2lvbk9wdGlvbnM7XG5cbi8qKlxuICogT3B0aW9ucyB0byBwYXNzIHRvIG5hdmlnYXRlKCkgZm9yIGEgbmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMgPVxuICB8IExpbmtOYXZpZ2F0ZU9wdGlvbnNcbiAgfCBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgZmV0Y2goKSBsb2FkXG4gKi9cbnR5cGUgTG9hZEZldGNoT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgZmV0Y2goKSBzdWJtaXNzaW9uXG4gKi9cbnR5cGUgU3VibWl0RmV0Y2hPcHRpb25zID0gQmFzZU5hdmlnYXRlT3JGZXRjaE9wdGlvbnMgJiBCYXNlU3VibWlzc2lvbk9wdGlvbnM7XG5cbi8qKlxuICogT3B0aW9ucyB0byBwYXNzIHRvIGZldGNoKClcbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyRmV0Y2hPcHRpb25zID0gTG9hZEZldGNoT3B0aW9ucyB8IFN1Ym1pdEZldGNoT3B0aW9ucztcblxuLyoqXG4gKiBQb3RlbnRpYWwgc3RhdGVzIGZvciBzdGF0ZS5uYXZpZ2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb25TdGF0ZXMgPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgbG9jYXRpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgICBqc29uOiB1bmRlZmluZWQ7XG4gICAgdGV4dDogdW5kZWZpbmVkO1xuICB9O1xuICBMb2FkaW5nOiB7XG4gICAgc3RhdGU6IFwibG9hZGluZ1wiO1xuICAgIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl0gfCB1bmRlZmluZWQ7XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl0gfCB1bmRlZmluZWQ7XG4gICAgdGV4dDogU3VibWlzc2lvbltcInRleHRcIl0gfCB1bmRlZmluZWQ7XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIGZvcm1NZXRob2Q6IFN1Ym1pc3Npb25bXCJmb3JtTWV0aG9kXCJdO1xuICAgIGZvcm1BY3Rpb246IFN1Ym1pc3Npb25bXCJmb3JtQWN0aW9uXCJdO1xuICAgIGZvcm1FbmNUeXBlOiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl07XG4gICAgZm9ybURhdGE6IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXTtcbiAgICBqc29uOiBTdWJtaXNzaW9uW1wianNvblwiXTtcbiAgICB0ZXh0OiBTdWJtaXNzaW9uW1widGV4dFwiXTtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uU3RhdGVzW2tleW9mIE5hdmlnYXRpb25TdGF0ZXNdO1xuXG5leHBvcnQgdHlwZSBSZXZhbGlkYXRpb25TdGF0ZSA9IFwiaWRsZVwiIHwgXCJsb2FkaW5nXCI7XG5cbi8qKlxuICogUG90ZW50aWFsIHN0YXRlcyBmb3IgZmV0Y2hlcnNcbiAqL1xudHlwZSBGZXRjaGVyU3RhdGVzPFREYXRhID0gYW55PiA9IHtcbiAgSWRsZToge1xuICAgIHN0YXRlOiBcImlkbGVcIjtcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQ7XG4gICAgdGV4dDogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAganNvbjogdW5kZWZpbmVkO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICB9O1xuICBMb2FkaW5nOiB7XG4gICAgc3RhdGU6IFwibG9hZGluZ1wiO1xuICAgIGZvcm1NZXRob2Q6IFN1Ym1pc3Npb25bXCJmb3JtTWV0aG9kXCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IFN1Ym1pc3Npb25bXCJmb3JtQWN0aW9uXCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl0gfCB1bmRlZmluZWQ7XG4gICAgdGV4dDogU3VibWlzc2lvbltcInRleHRcIl0gfCB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXSB8IHVuZGVmaW5lZDtcbiAgICBqc29uOiBTdWJtaXNzaW9uW1wianNvblwiXSB8IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgU3VibWl0dGluZzoge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXTtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdO1xuICAgIHRleHQ6IFN1Ym1pc3Npb25bXCJ0ZXh0XCJdO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl07XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBGZXRjaGVyPFREYXRhID0gYW55PiA9XG4gIEZldGNoZXJTdGF0ZXM8VERhdGE+W2tleW9mIEZldGNoZXJTdGF0ZXM8VERhdGE+XTtcblxuaW50ZXJmYWNlIEJsb2NrZXJCbG9ja2VkIHtcbiAgc3RhdGU6IFwiYmxvY2tlZFwiO1xuICByZXNldCgpOiB2b2lkO1xuICBwcm9jZWVkKCk6IHZvaWQ7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuaW50ZXJmYWNlIEJsb2NrZXJVbmJsb2NrZWQge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIjtcbiAgcmVzZXQ6IHVuZGVmaW5lZDtcbiAgcHJvY2VlZDogdW5kZWZpbmVkO1xuICBsb2NhdGlvbjogdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgQmxvY2tlclByb2NlZWRpbmcge1xuICBzdGF0ZTogXCJwcm9jZWVkaW5nXCI7XG4gIHJlc2V0OiB1bmRlZmluZWQ7XG4gIHByb2NlZWQ6IHVuZGVmaW5lZDtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBCbG9ja2VyID0gQmxvY2tlclVuYmxvY2tlZCB8IEJsb2NrZXJCbG9ja2VkIHwgQmxvY2tlclByb2NlZWRpbmc7XG5cbmV4cG9ydCB0eXBlIEJsb2NrZXJGdW5jdGlvbiA9IChhcmdzOiB7XG4gIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gIG5leHRMb2NhdGlvbjogTG9jYXRpb247XG4gIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG59KSA9PiBib29sZWFuO1xuXG5pbnRlcmZhY2UgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBzdGFydE5hdmlnYXRpb24gZG9lcyBub3QgbmVlZCB0byBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvbiBiZWNhdXNlIHdlXG4gICAqIHJlZGlyZWN0ZWQgb3IgZ290IGludGVycnVwdGVkXG4gICAqL1xuICBzaG9ydENpcmN1aXRlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBIYW5kbGVBY3Rpb25SZXN1bHQgZXh0ZW5kcyBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIEVycm9yIHRocm93biBmcm9tIHRoZSBjdXJyZW50IGFjdGlvbiwga2V5ZWQgYnkgdGhlIHJvdXRlIGNvbnRhaW5pbmcgdGhlXG4gICAqIGVycm9yIGJvdW5kYXJ5IHRvIHJlbmRlciB0aGUgZXJyb3IuICBUbyBiZSBjb21taXR0ZWQgdG8gdGhlIHN0YXRlIGFmdGVyXG4gICAqIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWRcbiAgICovXG4gIHBlbmRpbmdBY3Rpb25FcnJvcj86IFJvdXRlRGF0YTtcbiAgLyoqXG4gICAqIERhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY3VycmVudCBhY3Rpb24sIGtleWVkIGJ5IHRoZSByb3V0ZSBvd25pbmcgdGhlIGFjdGlvbi5cbiAgICogVG8gYmUgY29tbWl0dGVkIHRvIHRoZSBzdGF0ZSBhZnRlciBsb2FkZXJzIGhhdmUgY29tcGxldGVkXG4gICAqL1xuICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YTtcbn1cblxuaW50ZXJmYWNlIEhhbmRsZUxvYWRlcnNSZXN1bHQgZXh0ZW5kcyBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIGxvYWRlckRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgbG9hZGVyRGF0YT86IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgLyoqXG4gICAqIGVycm9ycyB0aHJvd24gZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgZXJyb3JzPzogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl07XG59XG5cbi8qKlxuICogQ2FjaGVkIGluZm8gZm9yIGFjdGl2ZSBmZXRjaGVyLmxvYWQoKSBpbnN0YW5jZXMgc28gdGhleSBjYW4gcGFydGljaXBhdGVcbiAqIGluIHJldmFsaWRhdGlvblxuICovXG5pbnRlcmZhY2UgRmV0Y2hMb2FkTWF0Y2gge1xuICByb3V0ZUlkOiBzdHJpbmc7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJZGVudGlmaWVkIGZldGNoZXIubG9hZCgpIGNhbGxzIHRoYXQgbmVlZCB0byBiZSByZXZhbGlkYXRlZFxuICovXG5pbnRlcmZhY2UgUmV2YWxpZGF0aW5nRmV0Y2hlciBleHRlbmRzIEZldGNoTG9hZE1hdGNoIHtcbiAga2V5OiBzdHJpbmc7XG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgbnVsbDtcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdIHwgbnVsbDtcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBXcmFwcGVyIG9iamVjdCB0byBhbGxvdyB1cyB0byB0aHJvdyBhbnkgcmVzcG9uc2Ugb3V0IGZyb20gY2FsbExvYWRlck9yQWN0aW9uXG4gKiBmb3IgcXVlcnlSb3V0ZXIgd2hpbGUgcHJlc2VydmluZyB3aGV0aGVyIG9yIG5vdCBpdCB3YXMgdGhyb3duIG9yIHJldHVybmVkXG4gKiBmcm9tIHRoZSBsb2FkZXIvYWN0aW9uXG4gKi9cbmludGVyZmFjZSBRdWVyeVJvdXRlUmVzcG9uc2Uge1xuICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEgfCBSZXN1bHRUeXBlLmVycm9yO1xuICByZXNwb25zZTogUmVzcG9uc2U7XG59XG5cbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzQXJyOiBNdXRhdGlvbkZvcm1NZXRob2RbXSA9IFtcbiAgXCJwb3N0XCIsXG4gIFwicHV0XCIsXG4gIFwicGF0Y2hcIixcbiAgXCJkZWxldGVcIixcbl07XG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQ8TXV0YXRpb25Gb3JtTWV0aG9kPihcbiAgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnJcbik7XG5cbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHNBcnI6IEZvcm1NZXRob2RbXSA9IFtcbiAgXCJnZXRcIixcbiAgLi4udmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIsXG5dO1xuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kcyA9IG5ldyBTZXQ8Rm9ybU1ldGhvZD4odmFsaWRSZXF1ZXN0TWV0aG9kc0Fycik7XG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuY29uc3QgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzA3LCAzMDhdKTtcblxuZXhwb3J0IGNvbnN0IElETEVfTkFWSUdBVElPTjogTmF2aWdhdGlvblN0YXRlc1tcIklkbGVcIl0gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgbG9jYXRpb246IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gIGpzb246IHVuZGVmaW5lZCxcbiAgdGV4dDogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGNvbnN0IElETEVfRkVUQ0hFUjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgY29uc3QgSURMRV9CTE9DS0VSOiBCbG9ja2VyVW5ibG9ja2VkID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICByZXNldDogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxufTtcblxuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuXG5jb25zdCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbiA9IChyb3V0ZSkgPT4gKHtcbiAgaGFzRXJyb3JCb3VuZGFyeTogQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KSxcbn0pO1xuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVSb3V0ZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlIGEgcm91dGVyIGFuZCBsaXN0ZW4gdG8gaGlzdG9yeSBQT1AgbmF2aWdhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihpbml0OiBSb3V0ZXJJbml0KTogUm91dGVyIHtcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3dcbiAgICA/IGluaXQud2luZG93XG4gICAgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyB3aW5kb3dcbiAgICA6IHVuZGVmaW5lZDtcbiAgY29uc3QgaXNCcm93c2VyID1cbiAgICB0eXBlb2Ygcm91dGVyV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgaXNTZXJ2ZXIgPSAhaXNCcm93c2VyO1xuXG4gIGludmFyaWFudChcbiAgICBpbml0LnJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCJcbiAgKTtcblxuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbjtcbiAgaWYgKGluaXQubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAoaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gSWYgdGhleSBhcmUgc3RpbGwgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgdmVyc2lvbiwgd3JhcCBpdCB3aXRoIHRoZSBuZXcgQVBJXG4gICAgbGV0IGRldGVjdEVycm9yQm91bmRhcnkgPSBpbml0LmRldGVjdEVycm9yQm91bmRhcnk7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gKHJvdXRlKSA9PiAoe1xuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZGV0ZWN0RXJyb3JCb3VuZGFyeShyb3V0ZSksXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgfVxuXG4gIC8vIFJvdXRlcyBrZXllZCBieSBJRFxuICBsZXQgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QgPSB7fTtcbiAgLy8gUm91dGVzIGluIHRyZWUgZm9ybWF0IGZvciBtYXRjaGluZ1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgaW5pdC5yb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIHVuZGVmaW5lZCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBsZXQgaW5GbGlnaHREYXRhUm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdIHwgdW5kZWZpbmVkO1xuICBsZXQgYmFzZW5hbWUgPSBpbml0LmJhc2VuYW1lIHx8IFwiL1wiO1xuICAvLyBDb25maWcgZHJpdmVuIGJlaGF2aW9yIGZsYWdzXG4gIGxldCBmdXR1cmU6IEZ1dHVyZUNvbmZpZyA9IHtcbiAgICB2N19ub3JtYWxpemVGb3JtTWV0aG9kOiBmYWxzZSxcbiAgICB2N19wcmVwZW5kQmFzZW5hbWU6IGZhbHNlLFxuICAgIC4uLmluaXQuZnV0dXJlLFxuICB9O1xuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBoaXN0b3J5XG4gIGxldCB1bmxpc3Rlbkhpc3Rvcnk6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9ucyB0byBjYWxsIG9uIGFsbCBzdGF0ZSBjaGFuZ2VzXG4gIGxldCBzdWJzY3JpYmVycyA9IG5ldyBTZXQ8Um91dGVyU3Vic2NyaWJlcj4oKTtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBvYmplY3QgdG8gaG9sZCBzY3JvbGwgcmVzdG9yYXRpb24gbG9jYXRpb25zIGR1cmluZyByb3V0aW5nXG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBzY3JvbGwgcmVzdG9yYXRpb24ga2V5c1xuICBsZXQgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXk6IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIC8vIE9uZS10aW1lIGZsYWcgdG8gY29udHJvbCB0aGUgaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLiAgQmVjYXVzZVxuICAvLyB3ZSBkb24ndCBnZXQgdGhlIHNhdmVkIHBvc2l0aW9ucyBmcm9tIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB1bnRpbCBfYWZ0ZXJfXG4gIC8vIHRoZSBpbml0aWFsIHJlbmRlciwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VwYXJhdGUgdXBkYXRlU3RhdGUgdG9cbiAgLy8gc2VuZCBhbG9uZyB0aGUgcmVzdG9yZVNjcm9sbFBvc2l0aW9uXG4gIC8vIFNldCB0byB0cnVlIGlmIHdlIGhhdmUgYGh5ZHJhdGlvbkRhdGFgIHNpbmNlIHdlIGFzc3VtZSB3ZSB3ZXJlIFNTUidkIGFuZCB0aGF0XG4gIC8vIFNTUiBkaWQgdGhlIGluaXRpYWwgc2Nyb2xsIHJlc3RvcmF0aW9uLlxuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG5cbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGxldCBpbml0aWFsRXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsID0gbnVsbDtcblxuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBlcnJvciBib3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICB9KTtcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfVxuXG4gIGxldCBpbml0aWFsaXplZCA9XG4gICAgLy8gQWxsIGluaXRpYWxNYXRjaGVzIG5lZWQgdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSdyZSByZWFkeS4gIElmIHdlIGhhdmUgbGF6eVxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxuICAgICFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxhenkpICYmXG4gICAgLy8gQW5kIHdlIGhhdmUgdG8gZWl0aGVyIGhhdmUgbm8gbG9hZGVycyBvciBoYXZlIGJlZW4gcHJvdmlkZWQgaHlkcmF0aW9uRGF0YVxuICAgICghaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sb2FkZXIpIHx8IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsKTtcblxuICBsZXQgcm91dGVyOiBSb3V0ZXI7XG4gIGxldCBzdGF0ZTogUm91dGVyU3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSkgfHwge30sXG4gICAgYWN0aW9uRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSkgfHwgbnVsbCxcbiAgICBlcnJvcnM6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycykgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKCksXG4gIH07XG5cbiAgLy8gLS0gU3RhdGVmdWwgaW50ZXJuYWwgdmFyaWFibGVzIHRvIG1hbmFnZSBuYXZpZ2F0aW9ucyAtLVxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXG4gIGxldCBwZW5kaW5nQWN0aW9uOiBIaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG5cbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gcHJldmVudCB0aGUgc2Nyb2xsIHJlc2V0IGlmIHNjcm9sbCBjYW5ub3RcbiAgLy8gYmUgcmVzdG9yZWQ/XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG5cbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcblxuICAvLyBXZSB1c2UgdGhpcyB0byBhdm9pZCB0b3VjaGluZyBoaXN0b3J5IGluIGNvbXBsZXRlTmF2aWdhdGlvbiBpZiBhXG4gIC8vIHJldmFsaWRhdGlvbiBpcyBlbnRpcmVseSB1bmludGVycnVwdGVkXG4gIGxldCBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBmbGFnIHRvIGZvcmNlIHJldmFsaWRhdGlvbiBvZiBhbGwgbG9hZGVyczpcbiAgLy8gIC0gc3VibWlzc2lvbnMgKGNvbXBsZXRlZCBvciBpbnRlcnJ1cHRlZClcbiAgLy8gIC0gdXNlUmV2YWxpZGF0b3IoKVxuICAvLyAgLSBYLVJlbWl4LVJldmFsaWRhdGUgKGZyb20gcmVkaXJlY3QpXG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSByb3V0ZXMgdGhhdCByZXF1aXJlIHJldmFsaWRhdGlvbiBkdWVcbiAgLy8gdG8gYSBjYW5jZWxsZWQgZGVmZXJyZWQgb24gYWN0aW9uIHN1Ym1pc3Npb25cbiAgbGV0IGNhbmNlbGxlZERlZmVycmVkUm91dGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgZmV0Y2hlciBsb2FkcyB0aGF0IHdlcmUgY2FuY2VsbGVkIGJ5IGFuXG4gIC8vIGFjdGlvbiBuYXZpZ2F0aW9uIGFuZCByZXF1aXJlIHJldmFsaWRhdGlvblxuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIEFib3J0Q29udHJvbGxlcnMgZm9yIGFueSBpbi1mbGlnaHQgZmV0Y2hlcnNcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSBuZXcgTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPigpO1xuXG4gIC8vIFRyYWNrIGxvYWRzIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHN0YXJ0ZWRcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG5cbiAgLy8gVHJhY2sgdGhlIG91dHN0YW5kaW5nIHBlbmRpbmcgbmF2aWdhdGlvbiBkYXRhIGxvYWQgdG8gYmUgY29tcGFyZWQgYWdhaW5zdFxuICAvLyB0aGUgZ2xvYmFsbHkgaW5jcmVtZW50aW5nIGxvYWQgd2hlbiBhIGZldGNoZXIgbG9hZCBsYW5kcyBhZnRlciBhIGNvbXBsZXRlZFxuICAvLyBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuXG4gIC8vIEZldGNoZXJzIHRoYXQgdHJpZ2dlcmVkIGRhdGEgcmVsb2FkcyBhcyBhIHJlc3VsdCBvZiB0aGVpciBhY3Rpb25zXG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgcmVkaXJlY3QgbmF2aWdhdGlvbnNcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvLyBNb3N0IHJlY2VudCBocmVmL21hdGNoIGZvciBmZXRjaGVyLmxvYWQgY2FsbHMgZm9yIGZldGNoZXJzXG4gIGxldCBmZXRjaExvYWRNYXRjaGVzID0gbmV3IE1hcDxzdHJpbmcsIEZldGNoTG9hZE1hdGNoPigpO1xuXG4gIC8vIFN0b3JlIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgZm9yIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLiAgV2hlbiBhXG4gIC8vIHJvdXRlIGxvYWRlciByZXR1cm5zIGRlZmVyKCkgd2Ugc3RpY2sgb25lIGluIGhlcmUuICBUaGVuLCB3aGVuIGEgbmVzdGVkXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMgd2UgdXBkYXRlIGxvYWRlckRhdGEuICBJZiBhIG5ldyBuYXZpZ2F0aW9uIHN0YXJ0cyB3ZVxuICAvLyBjYW5jZWwgYWN0aXZlIGRlZmVycmVkcyBmb3IgZWxpbWluYXRlZCByb3V0ZXMuXG4gIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPigpO1xuXG4gIC8vIFN0b3JlIGJsb2NrZXIgZnVuY3Rpb25zIGluIGEgc2VwYXJhdGUgTWFwIG91dHNpZGUgb2Ygcm91dGVyIHN0YXRlIHNpbmNlXG4gIC8vIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIFVJIHN0YXRlIGlmIHRoZXkgY2hhbmdlXG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gbmV3IE1hcDxzdHJpbmcsIEJsb2NrZXJGdW5jdGlvbj4oKTtcblxuICAvLyBGbGFnIHRvIGlnbm9yZSB0aGUgbmV4dCBoaXN0b3J5IHVwZGF0ZSwgc28gd2UgY2FuIHJldmVydCB0aGUgVVJMIGNoYW5nZSBvblxuICAvLyBhIFBPUCBuYXZpZ2F0aW9uIHRoYXQgd2FzIGJsb2NrZWQgYnkgdGhlIHVzZXIgd2l0aG91dCB0b3VjaGluZyByb3V0ZXIgc3RhdGVcbiAgbGV0IGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBhbGwgc2lkZSBlZmZlY3RzIHNob3VsZCBiZSBraWNrZWQgb2ZmIGZyb20gaGVyZS5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgYSBGbHVlbnQgQVBJIGZvciBlYXNlIG9mOlxuICAvLyAgIGxldCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdCkuaW5pdGlhbGl6ZSgpO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIElmIGhpc3RvcnkgaW5mb3JtcyB1cyBvZiBhIFBPUCBuYXZpZ2F0aW9uLCBzdGFydCB0aGUgbmF2aWdhdGlvbiBidXQgZG8gbm90IHVwZGF0ZVxuICAgIC8vIHN0YXRlLiAgV2UnbGwgdXBkYXRlIG91ciBvd24gc3RhdGUgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKFxuICAgICAgKHsgYWN0aW9uOiBoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgZGVsdGEgfSkgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhpcyBldmVudCBpZiBpdCB3YXMganVzdCB1cyByZXNldHRpbmcgdGhlIFVSTCBmcm9tIGFcbiAgICAgICAgLy8gYmxvY2tlZCBQT1AgbmF2aWdhdGlvblxuICAgICAgICBpZiAoaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUpIHtcbiAgICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiBcIiArXG4gICAgICAgICAgICBcInRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArXG4gICAgICAgICAgICBcInByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIFwiICtcbiAgICAgICAgICAgIFwidmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyBcIiArXG4gICAgICAgICAgICBcInJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIFwiICtcbiAgICAgICAgICAgIFwiY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBoaXN0b3J5QWN0aW9uLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgVVJMIHRvIG1hdGNoIHRoZSBjdXJyZW50IFVJLCBidXQgZG9uJ3QgdXBkYXRlIHJvdXRlciBzdGF0ZVxuICAgICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG5cbiAgICAgICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5ISwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIFJlLWRvIHRoZSBzYW1lIFBPUCBuYXZpZ2F0aW9uIHdlIGp1c3QgYmxvY2tlZFxuICAgICAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXkhLCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgICAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gS2ljayBvZmYgaW5pdGlhbCBkYXRhIGxvYWQgaWYgbmVlZGVkLiAgVXNlIFBvcCB0byBhdm9pZCBtb2RpZnlpbmcgaGlzdG9yeVxuICAgIC8vIE5vdGUgd2UgZG9uJ3QgZG8gYW55IGhhbmRsaW5nIG9mIGxhenkgaGVyZS4gIEZvciBTUEEncyBpdCdsbCBnZXQgaGFuZGxlZFxuICAgIC8vIGluIHRoZSBub3JtYWwgbmF2aWdhdGlvbiBmbG93LiAgRm9yIFNTUiBpdCdzIGV4cGVjdGVkIHRoYXQgbGF6eSBtb2R1bGVzIGFyZVxuICAgIC8vIHJlc29sdmVkIHByaW9yIHRvIHJvdXRlciBjcmVhdGlvbiBzaW5jZSB3ZSBjYW4ndCBnbyBpbnRvIGEgZmFsbGJhY2tFbGVtZW50XG4gICAgLy8gVUkgZm9yIFNTUidkIGFwcHNcbiAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oSGlzdG9yeUFjdGlvbi5Qb3AsIHN0YXRlLmxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cblxuICAvLyBTdWJzY3JpYmUgdG8gc3RhdGUgdXBkYXRlcyBmb3IgdGhlIHJvdXRlclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm46IFJvdXRlclN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG5cbiAgLy8gVXBkYXRlIG91ciBzdGF0ZSBhbmQgbm90aWZ5IHRoZSBjYWxsaW5nIGNvbnRleHQgb2YgdGhlIGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZTogUGFydGlhbDxSb3V0ZXJTdGF0ZT4pOiB2b2lkIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ubmV3U3RhdGUsXG4gICAgfTtcbiAgICBzdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKHN0YXRlKSk7XG4gIH1cblxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxuICAvLyBhbmQgc2V0dGluZyBzdGF0ZS5baGlzdG9yeUFjdGlvbi9sb2NhdGlvbi9tYXRjaGVzXSB0byB0aGUgbmV3IHJvdXRlLlxuICAvLyAtIExvY2F0aW9uIGlzIGEgcmVxdWlyZWQgcGFyYW1cbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cbiAgLy8gLSBDYW4gcGFzcyBhbnkgb3RoZXIgc3RhdGUgaW4gbmV3U3RhdGVcbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBuZXdTdGF0ZTogUGFydGlhbDxPbWl0PFJvdXRlclN0YXRlLCBcImFjdGlvblwiIHwgXCJsb2NhdGlvblwiIHwgXCJuYXZpZ2F0aW9uXCI+PlxuICApOiB2b2lkIHtcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcbiAgICAvLyAtIFdlIGhhdmUgY29tbWl0dGVkIGFjdGlvbkRhdGEgaW4gdGhlIHN0b3JlXG4gICAgLy8gLSBUaGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcbiAgICAvLyAtIFRoZSBsb2NhdGlvbiBiZWluZyBsb2FkZWQgaXMgbm90IHRoZSByZXN1bHQgb2YgYSByZWRpcmVjdFxuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9XG4gICAgICBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmXG4gICAgICBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG5cbiAgICBsZXQgYWN0aW9uRGF0YTogUm91dGVEYXRhIHwgbnVsbDtcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG5ld1N0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbXB0eSBhY3Rpb25EYXRhIC0+IGNsZWFyIHByaW9yIGFjdGlvbkRhdGEgZHVlIHRvIGFuIGFjdGlvbiBlcnJvclxuICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWN0aW9uUmVsb2FkKSB7XG4gICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IGRhdGEgaWYgd2UncmUgd3JhcHBpbmcgdXAgdGhlIGFjdGlvbiByZWxvYWRcbiAgICAgIGFjdGlvbkRhdGEgPSBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGVhciBhY3Rpb25EYXRhIG9uIGFueSBvdGhlciBjb21wbGV0ZWQgbmF2aWdhdGlvbnNcbiAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSBhbnkgZXhpc3RpbmcgbG9hZGVyRGF0YSBmcm9tIHJlLXVzZWQgcm91dGVzXG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhXG4gICAgICA/IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIG5ld1N0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSxcbiAgICAgICAgICBuZXdTdGF0ZS5lcnJvcnNcbiAgICAgICAgKVxuICAgICAgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuXG4gICAgLy8gT24gYSBzdWNjZXNzZnVsIG5hdmlnYXRpb24gd2UgY2FuIGFzc3VtZSB3ZSBnb3QgdGhyb3VnaCBhbGwgYmxvY2tlcnNcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcbiAgICBsZXQgYmxvY2tlcnMgPSBzdGF0ZS5ibG9ja2VycztcbiAgICBpZiAoYmxvY2tlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XG4gICAgICBibG9ja2Vycy5mb3JFYWNoKChfLCBrKSA9PiBibG9ja2Vycy5zZXQoaywgSURMRV9CTE9DS0VSKSk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHJlc3BlY3QgdGhlIHVzZXIgZmxhZy4gIE90aGVyd2lzZSBkb24ndCByZXNldCBvbiBtdXRhdGlvblxuICAgIC8vIHN1Ym1pc3Npb24gbmF2aWdhdGlvbnMgdW5sZXNzIHRoZXkgcmVkaXJlY3RcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHxcbiAgICAgIChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJlxuICAgICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgICAgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlKTtcblxuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24gdGhlbiBkbyBub3QgdG91Y2ggaGlzdG9yeVxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIFBPUCAtIFVSTCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSkge1xuICAgICAgaW5pdC5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAuLi5uZXdTdGF0ZSwgLy8gbWF0Y2hlcywgZXJyb3JzLCBmZXRjaGVycyBnbyB0aHJvdWdoIGFzLWlzXG4gICAgICBhY3Rpb25EYXRhLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGhpc3RvcnlBY3Rpb246IHBlbmRpbmdBY3Rpb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlc1xuICAgICAgKSxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIGJsb2NrZXJzLFxuICAgIH0pO1xuXG4gICAgLy8gUmVzZXQgc3RhdGVmdWwgbmF2aWdhdGlvbiB2YXJzXG4gICAgcGVuZGluZ0FjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUG9wO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMgPSBbXTtcbiAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSBbXTtcbiAgfVxuXG4gIC8vIFRyaWdnZXIgYSBuYXZpZ2F0aW9uIGV2ZW50LCB3aGljaCBjYW4gZWl0aGVyIGJlIGEgbnVtZXJpY2FsIFBPUCBvciBhIFBVU0hcbiAgLy8gcmVwbGFjZSB3aXRoIGFuIG9wdGlvbmFsIHN1Ym1pc3Npb25cbiAgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGUoXG4gICAgdG86IG51bWJlciB8IFRvIHwgbnVsbCxcbiAgICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsXG4gICAgICB0byxcbiAgICAgIG9wdHM/LmZyb21Sb3V0ZUlkLFxuICAgICAgb3B0cz8ucmVsYXRpdmVcbiAgICApO1xuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICBmdXR1cmUudjdfbm9ybWFsaXplRm9ybU1ldGhvZCxcbiAgICAgIGZhbHNlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcblxuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG5cbiAgICAvLyBXaGVuIHVzaW5nIG5hdmlnYXRlIGFzIGEgUFVTSC9SRVBMQUNFIHdlIGFyZW4ndCByZWFkaW5nIGFuIGFscmVhZHktZW5jb2RlZFxuICAgIC8vIFVSTCBmcm9tIHdpbmRvdy5sb2NhdGlvbiwgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgaGVyZSBzbyB0aGUgYmVoYXZpb3JcbiAgICAvLyByZW1haW5zIHRoZSBzYW1lIGFzIFBPUCBhbmQgbm9uLWRhdGEtcm91dGVyIHVzYWdlcy4gIG5ldyBVUkwoKSBkb2VzIGFsbFxuICAgIC8vIHRoZSBzYW1lIGVuY29kaW5nIHdlJ2QgZ2V0IGZyb20gYSBoaXN0b3J5LnB1c2hTdGF0ZS93aW5kb3cubG9jYXRpb24gcmVhZFxuICAgIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHRvdWNoIGhpc3RvcnlcbiAgICBuZXh0TG9jYXRpb24gPSB7XG4gICAgICAuLi5uZXh0TG9jYXRpb24sXG4gICAgICAuLi5pbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24obmV4dExvY2F0aW9uKSxcbiAgICB9O1xuXG4gICAgbGV0IHVzZXJSZXBsYWNlID0gb3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCA/IG9wdHMucmVwbGFjZSA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBoaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5QdXNoO1xuXG4gICAgaWYgKHVzZXJSZXBsYWNlID09PSB0cnVlKSB7XG4gICAgICBoaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlO1xuICAgIH0gZWxzZSBpZiAodXNlclJlcGxhY2UgPT09IGZhbHNlKSB7XG4gICAgICAvLyBuby1vcFxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzdWJtaXNzaW9uICE9IG51bGwgJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSAmJlxuICAgICAgc3VibWlzc2lvbi5mb3JtQWN0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaFxuICAgICkge1xuICAgICAgLy8gQnkgZGVmYXVsdCBvbiBzdWJtaXNzaW9ucyB0byB0aGUgY3VycmVudCBsb2NhdGlvbiB3ZSBSRVBMQUNFIHNvIHRoYXRcbiAgICAgIC8vIHVzZXJzIGRvbid0IGhhdmUgdG8gZG91YmxlLWNsaWNrIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgdG8gdGhlIHByaW9yXG4gICAgICAvLyBsb2NhdGlvbi4gIElmIHRoZSB1c2VyIHJlZGlyZWN0cyB0byBhIGRpZmZlcmVudCBsb2NhdGlvbiBmcm9tIHRoZVxuICAgICAgLy8gYWN0aW9uL2xvYWRlciB0aGlzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIHJlZGlyZWN0IHdpbGwgYmUgYSBQVVNIXG4gICAgICBoaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlO1xuICAgIH1cblxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPVxuICAgICAgb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHNcbiAgICAgICAgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb24sXG4gICAgfSk7XG5cbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSEsIHtcbiAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNlbmQgdGhlIHNhbWUgbmF2aWdhdGlvbiB0aHJvdWdoXG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSEsIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmFsaWRhdGUgYWxsIGN1cnJlbnQgbG9hZGVycy4gIElmIGEgbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzcyBvciBpZiB0aGlzXG4gIC8vIGlzIGludGVycnVwdGVkIGJ5IGEgbmF2aWdhdGlvbiwgYWxsb3cgdGhpcyB0byBcInN1Y2NlZWRcIiBieSBjYWxsaW5nIGFsbFxuICAvLyBsb2FkZXJzIGR1cmluZyB0aGUgbmV4dCBsb2FkZXIgcm91bmRcbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIHVwZGF0ZVN0YXRlKHsgcmV2YWxpZGF0aW9uOiBcImxvYWRpbmdcIiB9KTtcblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBzdWJtaXR0aW5nIGFuIGFjdGlvbiwgd2UgZG9uJ3QgbmVlZCB0byBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24sIHdlJ2xsIGp1c3QgbGV0IHRoZSBmb2xsb3cgdXAgbG9hZGVyIGV4ZWN1dGlvbiBjYWxsIGFsbCBsb2FkZXJzXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihcbiAgICAgIHBlbmRpbmdBY3Rpb24gfHwgc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sXG4gICAgICB7IG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvbiB9XG4gICAgKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oXG4gICAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbixcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgb3B0cz86IHtcbiAgICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbjtcbiAgICAgIHBlbmRpbmdFcnJvcj86IEVycm9yUmVzcG9uc2VJbXBsO1xuICAgICAgc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uPzogYm9vbGVhbjtcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gICAgICByZXBsYWNlPzogYm9vbGVhbjtcbiAgICB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEFib3J0IGFueSBpbi1wcm9ncmVzcyBuYXZpZ2F0aW9ucyBhbmQgc3RhcnQgYSBuZXcgb25lLiBVbnNldCBhbnkgb25nb2luZ1xuICAgIC8vIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9ucyB1bmxlc3MgdG9sZCBvdGhlcndpc2UsIHNpbmNlIHdlIHdhbnQgdGhpc1xuICAgIC8vIG5ldyBuYXZpZ2F0aW9uIHRvIHVwZGF0ZSBoaXN0b3J5IG5vcm1hbGx5XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgcGVuZGluZ0FjdGlvbiA9IGhpc3RvcnlBY3Rpb247XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID1cbiAgICAgIChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGV2ZXJ5IHRpbWUgd2Ugc3RhcnQgYSBuZXcgbmF2aWdhdGlvbixcbiAgICAvLyBhbmQgdHJhY2sgd2hldGhlciB3ZSBzaG91bGQgcmVzZXQgc2Nyb2xsIG9uIGNvbXBsZXRpb25cbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG5cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXNUb1VzZSk7XG4gICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgZGVmZXJyZWQgb24gNDA0cyBzaW5jZSB3ZSBkb24ndCBrZWVwIGFueSByb3V0ZXNcbiAgICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcygpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBpdCdzIG9ubHkgYSBoYXNoIGNoYW5nZSBhbmQgbm90IGEgcmV2YWxpZGF0aW9uIG9yXG4gICAgLy8gbXV0YXRpb24gc3VibWlzc2lvbi5cbiAgICAvL1xuICAgIC8vIElnbm9yZSBvbiBpbml0aWFsIHBhZ2UgbG9hZHMgYmVjYXVzZSBzaW5jZSB0aGUgaW5pdGlhbCBsb2FkIHdpbGwgYWx3YXlzXG4gICAgLy8gYmUgXCJzYW1lIGhhc2hcIi4gIEZvciBleGFtcGxlLCBvbiAvcGFnZSNoYXNoIGFuZCBzdWJtaXQgYSA8Rm9ybSBtZXRob2Q9XCJwb3N0XCI+XG4gICAgLy8gd2hpY2ggd2lsbCBkZWZhdWx0IHRvIGEgbmF2aWdhdGlvbiB0byAvcGFnZVxuICAgIGlmIChcbiAgICAgIHN0YXRlLmluaXRpYWxpemVkICYmXG4gICAgICAhaXNSZXZhbGlkYXRpb25SZXF1aXJlZCAmJlxuICAgICAgaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pICYmXG4gICAgICAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKVxuICAgICkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7IG1hdGNoZXMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbCxcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvbkRhdGE6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgcGVuZGluZ0Vycm9yOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBlbmRpbmdFcnJvciwgaXQgbWVhbnMgdGhlIHVzZXIgYXR0ZW1wdGVkIGEgR0VUIHN1Ym1pc3Npb25cbiAgICAgIC8vIHdpdGggYmluYXJ5IEZvcm1EYXRhIHNvIGFzc2lnbiBoZXJlIGFuZCBza2lwIHRvIGhhbmRsZUxvYWRlcnMuICBUaGF0XG4gICAgICAvLyB3YXkgd2UgaGFuZGxlIGNhbGxpbmcgbG9hZGVycyBhYm92ZSB0aGUgYm91bmRhcnkgZXRjLiAgSXQncyBub3QgcmVhbGx5XG4gICAgICAvLyBkaWZmZXJlbnQgZnJvbSBhbiBhY3Rpb25FcnJvciBpbiB0aGF0IHNlbnNlLlxuICAgICAgcGVuZGluZ0Vycm9yID0ge1xuICAgICAgICBbZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzKS5yb3V0ZS5pZF06IG9wdHMucGVuZGluZ0Vycm9yLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgb3B0cyAmJlxuICAgICAgb3B0cy5zdWJtaXNzaW9uICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKVxuICAgICkge1xuICAgICAgLy8gQ2FsbCBhY3Rpb24gaWYgd2UgcmVjZWl2ZWQgYW4gYWN0aW9uIHN1Ym1pc3Npb25cbiAgICAgIGxldCBhY3Rpb25PdXRwdXQgPSBhd2FpdCBoYW5kbGVBY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHsgcmVwbGFjZTogb3B0cy5yZXBsYWNlIH1cbiAgICAgICk7XG5cbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSA9IGFjdGlvbk91dHB1dC5wZW5kaW5nQWN0aW9uRGF0YTtcbiAgICAgIHBlbmRpbmdFcnJvciA9IGFjdGlvbk91dHB1dC5wZW5kaW5nQWN0aW9uRXJyb3I7XG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBvcHRzLnN1Ym1pc3Npb24pO1xuXG4gICAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwgeyBzaWduYWw6IHJlcXVlc3Quc2lnbmFsIH0pO1xuICAgIH1cblxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7IHNob3J0Q2lyY3VpdGVkLCBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5mZXRjaGVyU3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEsXG4gICAgICBwZW5kaW5nRXJyb3JcbiAgICApO1xuXG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcbiAgICAvLyB3ZSBzaG9ydCBjaXJjdWl0ZWQgYmVjYXVzZSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IGNvbnRyb2xsZXIgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgLi4uKHBlbmRpbmdBY3Rpb25EYXRhID8geyBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB9IDoge30pLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGFjdGlvbiBtYXRjaGVkIGJ5IHRoZSBsZWFmIHJvdXRlIGZvciB0aGlzIG5hdmlnYXRpb24gYW5kIGhhbmRsZVxuICAvLyByZWRpcmVjdHMvZXJyb3JzXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBvcHRzOiB7IHJlcGxhY2U/OiBib29sZWFuIH0gPSB7fVxuICApOiBQcm9taXNlPEhhbmRsZUFjdGlvblJlc3VsdD4ge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG5cbiAgICAvLyBQdXQgdXMgaW4gYSBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IG5hdmlnYXRpb24gPSBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0pO1xuXG4gICAgLy8gQ2FsbCBvdXIgYWN0aW9uIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgIGxldCByZXN1bHQ6IERhdGFSZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWQsXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgICAgYmFzZW5hbWVcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2U6IGJvb2xlYW47XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXG4gICAgICAgIC8vIHdlIHJlZGlyZWN0ZWQgdG8gdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24gd2UncmUgY3VycmVudGx5IGF0IHRvIGF2b2lkXG4gICAgICAgIC8vIGRvdWJsZSBiYWNrLWJ1dHRvbnNcbiAgICAgICAgcmVwbGFjZSA9XG4gICAgICAgICAgcmVzdWx0LmxvY2F0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQsIHsgc3VibWlzc2lvbiwgcmVwbGFjZSB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU3RvcmUgb2ZmIHRoZSBwZW5kaW5nIGVycm9yIC0gd2UgdXNlIGl0IHRvIGRldGVybWluZSB3aGljaCBsb2FkZXJzXG4gICAgICAvLyB0byBjYWxsIGFuZCB3aWxsIGNvbW1pdCBpdCB3aGVuIHdlIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuXG4gICAgICAvLyBCeSBkZWZhdWx0LCBhbGwgc3VibWlzc2lvbnMgYXJlIFJFUExBQ0UgbmF2aWdhdGlvbnMsIGJ1dCBpZiB0aGVcbiAgICAgIC8vIGFjdGlvbiB0aHJldyBhbiBlcnJvciB0aGF0J2xsIGJlIHJlbmRlcmVkIGluIGFuIGVycm9yRWxlbWVudCwgd2UgZmFsbFxuICAgICAgLy8gYmFjayB0byBQVVNIIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0aGUgYmFjayBidXR0b24gdG8gZ2V0IGJhY2sgdG9cbiAgICAgIC8vIHRoZSBwcmUtc3VibWlzc2lvbiBmb3JtIGxvY2F0aW9uIHRvIHRyeSBhZ2FpblxuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUHVzaDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2VuZCBiYWNrIGFuIGVtcHR5IG9iamVjdCB3ZSBjYW4gdXNlIHRvIGNsZWFyIG91dCBhbnkgcHJpb3IgYWN0aW9uRGF0YVxuICAgICAgICBwZW5kaW5nQWN0aW9uRGF0YToge30sXG4gICAgICAgIHBlbmRpbmdBY3Rpb25FcnJvcjogeyBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvciB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YTogeyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSB9LFxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGFsbCBhcHBsaWNhYmxlIGxvYWRlcnMgZm9yIHRoZSBnaXZlbiBtYXRjaGVzLCBoYW5kbGluZyByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJzKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBvdmVycmlkZU5hdmlnYXRpb24/OiBOYXZpZ2F0aW9uLFxuICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uLFxuICAgIGZldGNoZXJTdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgICByZXBsYWNlPzogYm9vbGVhbixcbiAgICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YSxcbiAgICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGFcbiAgKTogUHJvbWlzZTxIYW5kbGVMb2FkZXJzUmVzdWx0PiB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID1cbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbiB8fCBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG5cbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlZGlyZWN0IGZyb20gYW4gYWN0aW9uIHdlIGRvbid0IGhhdmUgYSBcInN1Ym1pc3Npb25cIiBidXRcbiAgICAvLyB3ZSBoYXZlIGl0IG9uIHRoZSBsb2FkaW5nIG5hdmlnYXRpb24gc28gdXNlIHRoYXQgaWYgYXZhaWxhYmxlXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPVxuICAgICAgc3VibWlzc2lvbiB8fFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24gfHxcbiAgICAgIGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG5cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgZmV0Y2hSZWRpcmVjdElkcyxcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSxcbiAgICAgIHBlbmRpbmdFcnJvclxuICAgICk7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyBkZWZlcnJlZHMgZm9yIG5vLWxvbmdlci1tYXRjaGVkIHJvdXRlcyBvciByb3V0ZXMgd2UncmVcbiAgICAvLyBhYm91dCB0byByZWxvYWQuICBOb3RlIHRoYXQgaWYgdGhpcyBpcyBhbiBhY3Rpb24gcmVsb2FkIHdlIHdvdWxkIGhhdmVcbiAgICAvLyBhbHJlYWR5IGNhbmNlbGxlZCBhbGwgcGVuZGluZyBkZWZlcnJlZHMgc28gdGhpcyB3b3VsZCBiZSBhIG5vLW9wXG4gICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKFxuICAgICAgKHJvdXRlSWQpID0+XG4gICAgICAgICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKSB8fFxuICAgICAgICAobWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKVxuICAgICk7XG5cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgLy8gQ29tbWl0IHBlbmRpbmcgZXJyb3IgaWYgd2UncmUgc2hvcnQgY2lyY3VpdGluZ1xuICAgICAgICBlcnJvcnM6IHBlbmRpbmdFcnJvciB8fCBudWxsLFxuICAgICAgICAuLi4ocGVuZGluZ0FjdGlvbkRhdGEgPyB7IGFjdGlvbkRhdGE6IHBlbmRpbmdBY3Rpb25EYXRhIH0gOiB7fSksXG4gICAgICAgIC4uLih1cGRhdGVkRmV0Y2hlcnMgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge30pLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24sIHdlIHJlbWFpbiBpbiBvdXIgY3VycmVudCBpZGxlXG4gICAgLy8gc3RhdGUuICBJZiBub3QsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG91ciBsb2FkaW5nIHN0YXRlIGFuZCBsb2FkIGRhdGEsXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGEgcmV2YWxpZGF0aW9uIGludGVycnVwdGluZyBhbiBhY3Rpb25SZWxvYWQpXG4gICAgaWYgKCFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZldGNoZXIgPyBmZXRjaGVyLmRhdGEgOiB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICB9KTtcbiAgICAgIGxldCBhY3Rpb25EYXRhID0gcGVuZGluZ0FjdGlvbkRhdGEgfHwgc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICAgIC4uLihhY3Rpb25EYXRhXG4gICAgICAgICAgPyBPYmplY3Qua2V5cyhhY3Rpb25EYXRhKS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8geyBhY3Rpb25EYXRhOiBudWxsIH1cbiAgICAgICAgICAgIDogeyBhY3Rpb25EYXRhIH1cbiAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH1cbiAgICAgICAgICA6IHt9KSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMocmYua2V5KSkge1xuICAgICAgICBhYm9ydEZldGNoZXIocmYua2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZi5jb250cm9sbGVyKSB7XG4gICAgICAgIC8vIEZldGNoZXJzIHVzZSBhbiBpbmRlcGVuZGVudCBBYm9ydENvbnRyb2xsZXIgc28gdGhhdCBhYm9ydGluZyBhIGZldGNoZXJcbiAgICAgICAgLy8gKHZpYSBkZWxldGVGZXRjaGVyKSBkb2VzIG5vdCBhYm9ydCB0aGUgdHJpZ2dlcmluZyBuYXZpZ2F0aW9uIHRoYXRcbiAgICAgICAgLy8gdHJpZ2dlcmVkIHRoZSByZXZhbGlkYXRpb25cbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFByb3h5IG5hdmlnYXRpb24gYWJvcnQgdGhyb3VnaCB0byByZXZhbGlkYXRpb24gZmV0Y2hlcnNcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT5cbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKGYpID0+IGFib3J0RmV0Y2hlcihmLmtleSkpO1xuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHsgcmVzdWx0cywgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9XG4gICAgICBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgICByZXF1ZXN0XG4gICAgICApO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgX2FmdGVyXyBsb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWYgd2Ugc2hvcnRcbiAgICAvLyBjaXJjdWl0ZWQgYmVjYXVzZSBmZXRjaENvbnRyb2xsZXJzIHdvdWxkIGhhdmUgYmVlbiBhYm9ydGVkIGFuZFxuICAgIC8vIHJlYXNzaWduZWQgdG8gbmV3IGNvbnRyb2xsZXJzIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHJmLmtleSkpO1xuXG4gICAgLy8gSWYgYW55IGxvYWRlcnMgcmV0dXJuZWQgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgaWYgKHJlZGlyZWN0LmlkeCA+PSBtYXRjaGVzVG9Mb2FkLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJlZGlyZWN0IGNhbWUgZnJvbSBhIGZldGNoZXIgbWFrZSBzdXJlIHdlIG1hcmsgaXQgaW5cbiAgICAgICAgLy8gZmV0Y2hSZWRpcmVjdElkcyBzbyBpdCBkb2Vzbid0IGdldCByZXZhbGlkYXRlZCBvbiB0aGUgbmV4dCBzZXQgb2ZcbiAgICAgICAgLy8gbG9hZGVyIGV4ZWN1dGlvbnNcbiAgICAgICAgbGV0IGZldGNoZXJLZXkgPVxuICAgICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzW3JlZGlyZWN0LmlkeCAtIG1hdGNoZXNUb0xvYWQubGVuZ3RoXS5rZXk7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGZldGNoZXJLZXkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlZGlyZWN0LnJlc3VsdCwgeyByZXBsYWNlIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHBlbmRpbmdFcnJvcixcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gV2lyZSB1cCBzdWJzY3JpYmVycyB0byB1cGRhdGUgbG9hZGVyRGF0YSBhcyBwcm9taXNlcyBzZXR0bGVcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XG4gICAgICBkZWZlcnJlZERhdGEuc3Vic2NyaWJlKChhYm9ydGVkKSA9PiB7XG4gICAgICAgIC8vIE5vdGU6IE5vIG5lZWQgdG8gdXBkYXRlU3RhdGUgaGVyZSBzaW5jZSB0aGUgVHJhY2tlZFByb21pc2Ugb25cbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpcyBzdGFibGUgYWNyb3NzIHJlc29sdmUvcmVqZWN0XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGluc3RhbmNlIGlmIHdlIHdlcmUgYWJvcnRlZCBvciBpZiBwcm9taXNlcyBoYXZlIHNldHRsZWRcbiAgICAgICAgaWYgKGFib3J0ZWQgfHwgZGVmZXJyZWREYXRhLmRvbmUpIHtcbiAgICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcbiAgICBsZXQgc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPVxuICAgICAgdXBkYXRlZEZldGNoZXJzIHx8IGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgICAuLi4oc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge30pLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGZXRjaGVyPFREYXRhID0gYW55PihrZXk6IHN0cmluZyk6IEZldGNoZXI8VERhdGE+IHtcbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxuICBmdW5jdGlvbiBmZXRjaChcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgaHJlZjogc3RyaW5nIHwgbnVsbCxcbiAgICBvcHRzPzogUm91dGVyRmV0Y2hPcHRpb25zXG4gICkge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgK1xuICAgICAgICAgIFwiVHJ5IG1vdmluZyBpdCB0byBhIHVzZUVmZmVjdCBvciBhIGNhbGxiYWNrLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcblxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBmdXR1cmUudjdfcHJlcGVuZEJhc2VuYW1lLFxuICAgICAgaHJlZixcbiAgICAgIHJvdXRlSWQsXG4gICAgICBvcHRzPy5yZWxhdGl2ZVxuICAgICk7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbm9ybWFsaXplZFBhdGgsIGJhc2VuYW1lKTtcblxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBub3JtYWxpemVkUGF0aCB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uLCBlcnJvciB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICAgICAgZnV0dXJlLnY3X25vcm1hbGl6ZUZvcm1NZXRob2QsXG4gICAgICB0cnVlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuXG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcblxuICAgIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBvZmYgdGhlIG1hdGNoIHNvIHdlIGNhbiBjYWxsIGl0J3Mgc2hvdWxkUmV2YWxpZGF0ZSBvbiBzdWJzZXF1ZW50XG4gICAgLy8gcmV2YWxpZGF0aW9uc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwgeyByb3V0ZUlkLCBwYXRoIH0pO1xuICAgIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBtYXRjaGVkIGZldGNoZXIuc3VibWl0KCksIGFuZCB0aGVuIGhhbmRsZSByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcmVxdWVzdE1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uXG4gICkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcblxuICAgIGlmICghbWF0Y2gucm91dGUuYWN0aW9uICYmICFtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0gZ2V0U3VibWl0dGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuXG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICBcImFjdGlvblwiLFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgbWF0Y2gsXG4gICAgICByZXF1ZXN0TWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgYmFzZW5hbWVcbiAgICApO1xuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHdhcyBraWNrZWQgb2ZmIGFmdGVyIG91ciBhY3Rpb24gc3RhcnRlZCwgc28gdGhhdFxuICAgICAgICAvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhpcyByZWRpcmVjdCBuYXZpZ2F0aW9uLiAgV2UgYWxyZWFkeVxuICAgICAgICAvLyBzZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCBzbyBhbGwgbG9hZGVycyBmb3IgdGhlIG5ldyByb3V0ZSBzaG91bGRcbiAgICAgICAgLy8gZmlyZSB1bmxlc3Mgb3B0ZWQgb3V0IHZpYSBzaG91bGRSZXZhbGlkYXRlXG4gICAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCk7XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGxldCBsb2FkaW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkaW5nRmV0Y2hlcik7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgYWN0aW9uUmVzdWx0LCB7XG4gICAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb246IHN1Ym1pc3Npb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgYWN0aW9uUmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRoZSBkYXRhIGxvYWQgZm9yIGN1cnJlbnQgbWF0Y2hlcywgb3IgdGhlIG5leHQgbG9jYXRpb24gaWYgd2UncmVcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9XG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIlxuICAgICAgICA/IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBiYXNlbmFtZSlcbiAgICAgICAgOiBzdGF0ZS5tYXRjaGVzO1xuXG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG5cbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcblxuICAgIGxldCBsb2FkRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkRmV0Y2hlcik7XG5cbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgeyBbbWF0Y2gucm91dGUuaWRdOiBhY3Rpb25SZXN1bHQuZGF0YSB9LFxuICAgICAgdW5kZWZpbmVkIC8vIE5vIG5lZWQgdG8gc2VuZCB0aHJvdWdoIGVycm9ycyBzaW5jZSB3ZSBzaG9ydCBjaXJjdWl0IGFib3ZlXG4gICAgKTtcblxuICAgIC8vIFB1dCBhbGwgcmV2YWxpZGF0aW5nIGZldGNoZXJzIGludG8gdGhlIGxvYWRpbmcgc3RhdGUsIGV4Y2VwdCBmb3IgdGhlXG4gICAgLy8gY3VycmVudCBmZXRjaGVyIHdoaWNoIHdlIHdhbnQgdG8ga2VlcCBpbiBpdCdzIGN1cnJlbnQgbG9hZGluZyBzdGF0ZSB3aGljaFxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnNcbiAgICAgIC5maWx0ZXIoKHJmKSA9PiByZi5rZXkgIT09IGtleSlcbiAgICAgIC5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoc3RhbGVLZXkpKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKHN0YWxlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHN0YWxlS2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PlxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcblxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG5cbiAgICBsZXQgeyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcblxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGlmIChyZWRpcmVjdC5pZHggPj0gbWF0Y2hlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZWRpcmVjdCBjYW1lIGZyb20gYSBmZXRjaGVyIG1ha2Ugc3VyZSB3ZSBtYXJrIGl0IGluXG4gICAgICAgIC8vIGZldGNoUmVkaXJlY3RJZHMgc28gaXQgZG9lc24ndCBnZXQgcmV2YWxpZGF0ZWQgb24gdGhlIG5leHQgc2V0IG9mXG4gICAgICAgIC8vIGxvYWRlciBleGVjdXRpb25zXG4gICAgICAgIGxldCBmZXRjaGVyS2V5ID1cbiAgICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QucmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gU2luY2Ugd2UgbGV0IHJldmFsaWRhdGlvbnMgY29tcGxldGUgZXZlbiBpZiB0aGUgc3VibWl0dGluZyBmZXRjaGVyIHdhc1xuICAgIC8vIGRlbGV0ZWQsIG9ubHkgcHV0IGl0IGJhY2sgdG8gaWRsZSBpZiBpdCBoYXNuJ3QgYmVlbiBkZWxldGVkXG4gICAgaWYgKHN0YXRlLmZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuXG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKGxvYWRJZCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluIGEgbmF2aWdhdGlvbiBsb2FkaW5nIHN0YXRlIGFuZCB0aGlzIGZldGNoZXIgaXNcbiAgICAvLyBtb3JlIHJlY2VudCB0aGFuIHRoZSBuYXZpZ2F0aW9uLCB3ZSB3YW50IHRoZSBuZXdlciBkYXRhIHNvIGFib3J0IHRoZVxuICAgIC8vIG5hdmlnYXRpb24gYW5kIGNvbXBsZXRlIGl0IHdpdGggdGhlIGZldGNoZXIgZGF0YVxuICAgIGlmIChcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmXG4gICAgICBsb2FkSWQgPiBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZFxuICAgICkge1xuICAgICAgaW52YXJpYW50KHBlbmRpbmdBY3Rpb24sIFwiRXhwZWN0ZWQgcGVuZGluZyBhY3Rpb25cIik7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG5cbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHVwZGF0ZSB3aXRoIHRoZSBmZXRjaGVyIGRhdGEsIHByZXNlcnZpbmcgYW55IGV4aXN0aW5nXG4gICAgICAvLyBsb2FkZXJEYXRhIGZvciBsb2FkZXJzIHRoYXQgZGlkIG5vdCBuZWVkIHRvIHJlbG9hZC4gIFdlIGhhdmUgdG9cbiAgICAgIC8vIG1hbnVhbGx5IG1lcmdlIGhlcmUgc2luY2Ugd2UgYXJlbid0IGdvaW5nIHRocm91Z2ggY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICApLFxuICAgICAgICAuLi4oZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH1cbiAgICAgICAgICA6IHt9KSxcbiAgICAgIH0pO1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgdGhlIG1hdGNoZWQgbG9hZGVyIGZvciBmZXRjaGVyLmxvYWQoKSwgaGFuZGxpbmcgcmVkaXJlY3RzLCBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuICApIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3MgbG9hZGluZyBzdGF0ZVxuICAgIGxldCBsb2FkaW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXG4gICAgKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkaW5nRmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSBsb2FkZXIgZm9yIHRoaXMgZmV0Y2hlciByb3V0ZSBtYXRjaFxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcblxuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgYmFzZW5hbWVcbiAgICApO1xuXG4gICAgLy8gRGVmZXJyZWQgaXNuJ3Qgc3VwcG9ydGVkIGZvciBmZXRjaGVyIGxvYWRzLCBhd2FpdCBldmVyeXRoaW5nIGFuZCB0cmVhdCBpdFxuICAgIC8vIGFzIGEgbm9ybWFsIGxvYWQuICByZXNvbHZlRGVmZXJyZWREYXRhIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGlzXG4gICAgLy8gZmV0Y2hlciBnZXRzIGFib3J0ZWQsIHNvIHdlIGp1c3QgbGVhdmUgcmVzdWx0IHVudG91Y2hlZCBhbmQgc2hvcnQgY2lyY3VpdFxuICAgIC8vIGJlbG93IGlmIHRoYXQgaGFwcGVuc1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIChhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgZmV0Y2hSZXF1ZXN0LnNpZ25hbCwgdHJ1ZSkpIHx8XG4gICAgICAgIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4gZGVsZXRlIHRoaXMgc28gbG9uZyBhcyB3ZSB3ZXJlbid0IGFib3J0ZWQgYnkgb3VyIG91ciBvd24gZmV0Y2hlclxuICAgIC8vIHJlLWxvYWQgd2hpY2ggd291bGQgaGF2ZSBwdXQgX25ld18gY29udHJvbGxlciBpcyBpbiBmZXRjaENvbnRyb2xsZXJzXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvYWRlciB0aHJldyBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHdhcyBraWNrZWQgb2ZmIGFmdGVyIG91ciBsb2FkZXIgc3RhcnRlZCwgc28gdGhhdFxuICAgICAgICAvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhpcyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCk7XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIC8vIFRPRE86IEluIHJlbWl4LCB0aGlzIHdvdWxkIHJlc2V0IHRvIElETEVfTkFWSUdBVElPTiBpZiBpdCB3YXMgYSBjYXRjaCAtXG4gICAgICAvLyBkbyB3ZSBuZWVkIHRvIGJlaGF2ZSBhbnkgZGlmZmVyZW50bHkgd2l0aCBvdXIgbm9uLXJlZGlyZWN0IGVycm9ycz9cbiAgICAgIC8vIFdoYXQgaWYgaXQgd2FzIGEgbm9uLXJlZGlyZWN0IFJlc3BvbnNlP1xuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcblxuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxuICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgcmVkaXJlY3RzIHJldHVybmVkIGZyb20gYW4gYWN0aW9uIG9yIGxvYWRlci5cbiAgICogTm9ybWFsbHksIGEgcmVkaXJlY3QgXCJyZXBsYWNlc1wiIHRoZSBuYXZpZ2F0aW9uIHRoYXQgdHJpZ2dlcmVkIGl0LiAgU28sIGZvclxuICAgKiBleGFtcGxlOlxuICAgKlxuICAgKiAgLSB1c2VyIGlzIG9uIC9hXG4gICAqICAtIHVzZXIgY2xpY2tzIGEgbGluayB0byAvYlxuICAgKiAgLSBsb2FkZXIgZm9yIC9iIHJlZGlyZWN0cyB0byAvY1xuICAgKlxuICAgKiBJbiBhIG5vbi1KUyBhcHAgdGhlIGJyb3dzZXIgd291bGQgdHJhY2sgdGhlIGluLWZsaWdodCBuYXZpZ2F0aW9uIHRvIC9iIGFuZFxuICAgKiB0aGVuIHJlcGxhY2UgaXQgd2l0aCAvYyB3aGVuIGl0IGVuY291bnRlcmVkIHRoZSByZWRpcmVjdCByZXNwb25zZS4gIEluXG4gICAqIHRoZSBlbmQgaXQgd291bGQgb25seSBldmVyIHVwZGF0ZSB0aGUgVVJMIGJhciB3aXRoIC9jLlxuICAgKlxuICAgKiBJbiBjbGllbnQtc2lkZSByb3V0aW5nIHVzaW5nIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUsIHdlIGFpbSB0byBlbXVsYXRlXG4gICAqIHRoaXMgYmVoYXZpb3IgYW5kIHdlIGFsc28gZG8gbm90IHVwZGF0ZSBoaXN0b3J5IHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gICAqIG5hdmlnYXRpb24gKGluY2x1ZGluZyBwcm9jZXNzZWQgcmVkaXJlY3RzKS4gIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZXZlclxuICAgKiBhY3R1YWxseSB0b3VjaCBoaXN0b3J5IHVudGlsIHdlJ3ZlIHByb2Nlc3NlZCByZWRpcmVjdHMsIHNvIHdlIGp1c3QgdXNlXG4gICAqIHRoZSBoaXN0b3J5IGFjdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uIChQVVNIIG9yIFJFUExBQ0UpLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICAgIHJlZGlyZWN0OiBSZWRpcmVjdFJlc3VsdCxcbiAgICB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICByZXBsYWNlLFxuICAgIH06IHtcbiAgICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgfSA9IHt9XG4gICkge1xuICAgIGlmIChyZWRpcmVjdC5yZXZhbGlkYXRlKSB7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCByZWRpcmVjdC5sb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgIFwiRXhwZWN0ZWQgYSBsb2NhdGlvbiBvbiB0aGUgcmVkaXJlY3QgbmF2aWdhdGlvblwiXG4gICAgKTtcblxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG5cbiAgICAgIGlmIChyZWRpcmVjdC5yZWxvYWREb2N1bWVudCkge1xuICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiB0aGUgcmVzcG9uc2UgY29udGFpbmVkIFgtUmVtaXgtUmVsb2FkLURvY3VtZW50XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChBQlNPTFVURV9VUkxfUkVHRVgudGVzdChyZWRpcmVjdC5sb2NhdGlvbikpIHtcbiAgICAgICAgY29uc3QgdXJsID0gaW5pdC5oaXN0b3J5LmNyZWF0ZVVSTChyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPVxuICAgICAgICAgIC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRvIGEgbmV3IG9yaWdpblxuICAgICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHxcbiAgICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0aGF0IGRvZXMgbm90IG1hdGNoIG91ciBiYXNlbmFtZVxuICAgICAgICAgIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBhYm9ydCBvbiByZWRpcmVjdHMsIHNpbmNlIHdlIGRvbid0IGRldGVjdCB0aGVcbiAgICAvLyByZWRpcmVjdCB1bnRpbCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBzZXR0bGVkXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGxldCByZWRpcmVjdEhpc3RvcnlBY3Rpb24gPVxuICAgICAgcmVwbGFjZSA9PT0gdHJ1ZSA/IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSA6IEhpc3RvcnlBY3Rpb24uUHVzaDtcblxuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUgfSA9IHN0YXRlLm5hdmlnYXRpb247XG4gICAgaWYgKFxuICAgICAgIXN1Ym1pc3Npb24gJiZcbiAgICAgICFmZXRjaGVyU3VibWlzc2lvbiAmJlxuICAgICAgZm9ybU1ldGhvZCAmJlxuICAgICAgZm9ybUFjdGlvbiAmJlxuICAgICAgZm9ybUVuY1R5cGVcbiAgICApIHtcbiAgICAgIHN1Ym1pc3Npb24gPSBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKFxuICAgICAgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzLmhhcyhyZWRpcmVjdC5zdGF0dXMpICYmXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKGFjdGl2ZVN1Ym1pc3Npb24uZm9ybU1ldGhvZClcbiAgICApIHtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdEhpc3RvcnlBY3Rpb24sIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIC4uLmFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICAgICAgZm9ybUFjdGlvbjogcmVkaXJlY3QubG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXG4gICAgICAvLyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24oXG4gICAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgZmV0Y2hlcnNUb0xvYWQ6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSxcbiAgICByZXF1ZXN0OiBSZXF1ZXN0XG4gICkge1xuICAgIC8vIENhbGwgYWxsIG5hdmlnYXRpb24gbG9hZGVycyBhbmQgcmV2YWxpZGF0aW5nIGZldGNoZXIgbG9hZGVycyBpbiBwYXJhbGxlbCxcbiAgICAvLyB0aGVuIHNsaWNlIG9mZiB0aGUgcmVzdWx0cyBpbnRvIHNlcGFyYXRlIGFycmF5cyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW1cbiAgICAvLyBhY2NvcmRpbmdseVxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICAuLi5mZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IHtcbiAgICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICAgIHJldHVybiBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgICBcImxvYWRlclwiLFxuICAgICAgICAgICAgY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBmLnBhdGgsIGYuY29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgICAgZi5tYXRjaCxcbiAgICAgICAgICAgIGYubWF0Y2hlcyxcbiAgICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgYmFzZW5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBlcnJvcjogRXJyb3JSZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBmLnBhdGggfSksXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgIF0pO1xuICAgIGxldCBsb2FkZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZShtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICAgICAgICBjdXJyZW50TWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgICAgbG9hZGVyUmVzdWx0cy5tYXAoKCkgPT4gcmVxdWVzdC5zaWduYWwpLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YVxuICAgICAgKSxcbiAgICAgIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gICAgICAgIGN1cnJlbnRNYXRjaGVzLFxuICAgICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IGYubWF0Y2gpLFxuICAgICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgICAgZmV0Y2hlcnNUb0xvYWQubWFwKChmKSA9PiAoZi5jb250cm9sbGVyID8gZi5jb250cm9sbGVyLnNpZ25hbCA6IG51bGwpKSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSxcbiAgICBdKTtcblxuICAgIHJldHVybiB7IHJlc3VsdHMsIGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpIHtcbiAgICAvLyBFdmVyeSBpbnRlcnJ1cHRpb24gdHJpZ2dlcnMgYSByZXZhbGlkYXRpb25cbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcblxuICAgIC8vIENhbmNlbCBwZW5kaW5nIHJvdXRlLWxldmVsIGRlZmVycmVkcyBhbmQgbWFyayBjYW5jZWxsZWQgcm91dGVzIGZvclxuICAgIC8vIHJldmFsaWRhdGlvblxuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLnB1c2goLi4uY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCkpO1xuXG4gICAgLy8gQWJvcnQgaW4tZmxpZ2h0IGZldGNoZXIgbG9hZHNcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLnB1c2goa2V5KTtcbiAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5OiBzdHJpbmcsIHJvdXRlSWQ6IHN0cmluZywgZXJyb3I6IGFueSkge1xuICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCByb3V0ZUlkKTtcbiAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZXJyb3JzOiB7XG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3IsXG4gICAgICB9LFxuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgLy8gRG9uJ3QgYWJvcnQgdGhlIGNvbnRyb2xsZXIgaWYgdGhpcyBpcyBhIGRlbGV0aW9uIG9mIGEgZmV0Y2hlci5zdWJtaXQoKVxuICAgIC8vIGluIGl0J3MgbG9hZGluZyBwaGFzZSBzaW5jZSAtIHdlIGRvbid0IHdhbnQgdG8gYWJvcnQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAvLyByZXZhbGlkYXRpb24gYW5kIHdhbnQgdGhlbSB0byBjb21wbGV0ZSBhbmQgbGFuZFxuICAgIGlmIChcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiZcbiAgICAgICEoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBmZXRjaFJlbG9hZElkcy5oYXMoa2V5KSlcbiAgICApIHtcbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydEZldGNoZXIoa2V5OiBzdHJpbmcpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIGBFeHBlY3RlZCBmZXRjaCBjb250cm9sbGVyOiAke2tleX1gKTtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5czogc3RyaW5nW10pIHtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgbGV0IGZldGNoZXIgPSBnZXRGZXRjaGVyKGtleSk7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihmZXRjaGVyLmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTogYm9vbGVhbiB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICBkb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHVwZGF0ZWRGZXRjaGVycyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoZG9uZUtleXMpO1xuICAgIHJldHVybiB1cGRhdGVkRmV0Y2hlcnM7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJsb2NrZXIoa2V5OiBzdHJpbmcsIGZuOiBCbG9ja2VyRnVuY3Rpb24pIHtcbiAgICBsZXQgYmxvY2tlcjogQmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcblxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLmdldChrZXkpICE9PSBmbikge1xuICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zZXQoa2V5LCBmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrZXI7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleTogc3RyaW5nKSB7XG4gICAgc3RhdGUuYmxvY2tlcnMuZGVsZXRlKGtleSk7XG4gICAgYmxvY2tlckZ1bmN0aW9ucy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gdXBkYXRlIGJsb2NrZXJzLCBlbnN1cmluZyB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9uc1xuICBmdW5jdGlvbiB1cGRhdGVCbG9ja2VyKGtleTogc3RyaW5nLCBuZXdCbG9ja2VyOiBCbG9ja2VyKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG5cbiAgICAvLyBQb29yIG1hbnMgc3RhdGUgbWFjaGluZSA6KVxuICAgIC8vIGh0dHBzOi8vbWVybWFpZC5saXZlL2VkaXQjcGFrbzplTnFWa2M5T3d6QU14bDhsOG5uakFZckV0RElPSEVCSWd3dktKVFJlR3kzX2xEcElxTzI3azZhd01HMFhjckxsbno4N253ZG9uRVNvZ0tYWEJ1RTc5cnE3NVhaTzMteUhkczBSSlZ1djcwWXJQbFVyQ0VlMkhmck9SUzNydWJxWmZ1aHRwZzVDOXdrNXRaNFZLY1JVcTg4cTlaOFJTMC00OGNFMWlISmtMMHVnYkh1Rkx1czlMNnNwWnk4blg5TVAyQ05kb21WYXBvc3F1M2ZHYXlUOFQ4LWpKUXdoZXBvX1V0cGdCUWFERVVvbTA0ZFpoQU4xYUpCRGxVS0pCeEUxY2VCMlNtajBNbG4tSUJXNUFGVTJkd1Vpa3R0XzJRYXEyZEJmYUtkRXVwODVVVjdZZC1kS2psbmthYmwyUHZyMERUa1RyZU1cbiAgICBpbnZhcmlhbnQoXG4gICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiksXG4gICAgICBgSW52YWxpZCBibG9ja2VyIHN0YXRlIHRyYW5zaXRpb246ICR7YmxvY2tlci5zdGF0ZX0gLT4gJHtuZXdCbG9ja2VyLnN0YXRlfWBcbiAgICApO1xuXG4gICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgYmxvY2tlcnMuc2V0KGtleSwgbmV3QmxvY2tlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgY3VycmVudExvY2F0aW9uLFxuICAgIG5leHRMb2NhdGlvbixcbiAgICBoaXN0b3J5QWN0aW9uLFxuICB9OiB7XG4gICAgY3VycmVudExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICAgIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG4gIH0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuXG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG5cbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgLy8gSWYgdGhlIGJsb2NrZXIgaXMgY3VycmVudGx5IHByb2NlZWRpbmcsIHdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2tcbiAgICAgIC8vIGl0IGFuZCBjYW4gbGV0IHRoaXMgbmF2aWdhdGlvbiBjb250aW51ZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhcbiAgICBwcmVkaWNhdGU/OiAocm91dGVJZDogc3RyaW5nKSA9PiBib29sZWFuXG4gICk6IHN0cmluZ1tdIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHM6IHN0cmluZ1tdID0gW107XG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRmZCwgcm91dGVJZCkgPT4ge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHJvdXRlSWQpKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVmZXJyZWQgLSBidXQgZG8gbm90IHJlbW92ZSBmcm9tIGFjdGl2ZURlZmVycmVkcyBoZXJlIC1cbiAgICAgICAgLy8gd2UgcmVseSBvbiB0aGUgc3Vic2NyaWJlcnMgdG8gZG8gdGhhdCBzbyBvdXIgdGVzdHMgY2FuIGFzc2VydCBwcm9wZXJcbiAgICAgICAgLy8gY2xlYW51cCB2aWEgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzXG4gICAgICAgIGRmZC5jYW5jZWwoKTtcbiAgICAgICAgY2FuY2VsbGVkUm91dGVJZHMucHVzaChyb3V0ZUlkKTtcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsbGVkUm91dGVJZHM7XG4gIH1cblxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgIHBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBnZXRQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbixcbiAgICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uXG4gICkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgbnVsbDtcblxuICAgIC8vIFBlcmZvcm0gaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLCBzaW5jZSB3ZSBtaXNzIHRoZSBib2F0IG9uXG4gICAgLy8gdGhlIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBiZWNhdXNlIHdlJ3ZlIG5vdCB5ZXQgcmVuZGVyZWQgPFNjcm9sbFJlc3RvcmF0aW9uLz5cbiAgICAvLyBhbmQgdGhlcmVmb3JlIGhhdmUgbm8gc2F2ZWRTY3JvbGxQb3NpdGlvbnMgYXZhaWxhYmxlXG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHkgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uOiBMb2NhdGlvbiwgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdKSB7XG4gICAgaWYgKGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLm1hcCgobSkgPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cblxuICBmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24oXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXVxuICApOiB2b2lkIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMgJiYgZ2V0U2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdXG4gICk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucykge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBsZXQgeSA9IHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV07XG4gICAgICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gX2ludGVybmFsU2V0Um91dGVzKG5ld1JvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSkge1xuICAgIG1hbmlmZXN0ID0ge307XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICAgIG5ld1JvdXRlcyxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIG1hbmlmZXN0XG4gICAgKTtcbiAgfVxuXG4gIHJvdXRlciA9IHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaCxcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiAodG86IFRvKSA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXG4gICAgZW5jb2RlTG9jYXRpb246ICh0bzogVG8pID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyLFxuICAgIGRpc3Bvc2UsXG4gICAgZ2V0QmxvY2tlcixcbiAgICBkZWxldGVCbG9ja2VyLFxuICAgIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IGZldGNoQ29udHJvbGxlcnMsXG4gICAgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzOiBhY3RpdmVEZWZlcnJlZHMsXG4gICAgLy8gVE9ETzogUmVtb3ZlIHNldFJvdXRlcywgaXQncyB0ZW1wb3JhcnkgdG8gYXZvaWQgZGVhbGluZyB3aXRoXG4gICAgLy8gdXBkYXRpbmcgdGhlIHRyZWUgd2hpbGUgdmFsaWRhdGluZyB0aGUgdXBkYXRlIGFsZ29yaXRobS5cbiAgICBfaW50ZXJuYWxTZXRSb3V0ZXMsXG4gIH07XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBVTlNBRkVfREVGRVJSRURfU1lNQk9MID0gU3ltYm9sKFwiZGVmZXJyZWRcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU3RhdGljSGFuZGxlck9wdGlvbnMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWFwUm91dGVQcm9wZXJ0aWVzYCBpbnN0ZWFkXG4gICAqL1xuICBkZXRlY3RFcnJvckJvdW5kYXJ5PzogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uO1xuICBtYXBSb3V0ZVByb3BlcnRpZXM/OiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIoXG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzogQ3JlYXRlU3RhdGljSGFuZGxlck9wdGlvbnNcbik6IFN0YXRpY0hhbmRsZXIge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCJcbiAgKTtcblxuICBsZXQgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QgPSB7fTtcbiAgbGV0IGJhc2VuYW1lID0gKG9wdHMgPyBvcHRzLmJhc2VuYW1lIDogbnVsbCkgfHwgXCIvXCI7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uO1xuICBpZiAob3B0cz8ubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAob3B0cz8uZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IChyb3V0ZSkgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cblxuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICB1bmRlZmluZWQsXG4gICAgbWFuaWZlc3RcbiAgKTtcblxuICAvKipcbiAgICogVGhlIHF1ZXJ5KCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkb2N1bWVudCByZXF1ZXN0cywgaW4gd2hpY2ggd2Ugd2FudCB0b1xuICAgKiBjYWxsIGFuIG9wdGlvbmFsIGFjdGlvbiBhbmQgcG90ZW50aWFsbHkgbXVsdGlwbGUgbG9hZGVycyBmb3IgYWxsIG5lc3RlZFxuICAgKiByb3V0ZXMuICBJdCByZXR1cm5zIGEgU3RhdGljSGFuZGxlckNvbnRleHQgb2JqZWN0LCB3aGljaCBpcyB2ZXJ5IHNpbWlsYXJcbiAgICogdG8gdGhlIHJvdXRlciBzdGF0ZSAobG9jYXRpb24sIGxvYWRlckRhdGEsIGFjdGlvbkRhdGEsIGVycm9ycywgZXRjLikgYW5kXG4gICAqIGFsc28gYWRkcyBTU1Itc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgc3RhdHVzQ29kZSBhbmQgaGVhZGVyc1xuICAgKiBmcm9tIGFjdGlvbi9sb2FkZXJzIFJlc3BvbnNlcy5cbiAgICpcbiAgICogSXQgX3Nob3VsZF8gbmV2ZXIgdGhyb3cgYW5kIHNob3VsZCByZXBvcnQgYWxsIGVycm9ycyB0aHJvdWdoIHRoZVxuICAgKiByZXR1cm5lZCBjb250ZXh0LmVycm9ycyBvYmplY3QsIHByb3Blcmx5IGFzc29jaWF0aW5nIGVycm9ycyB0byB0aGVpciBlcnJvclxuICAgKiBib3VuZGFyeS4gIEFkZGl0aW9uYWxseSwgaXQgdHJhY2tzIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHdoaWNoIGNhbiBiZVxuICAgKiB1c2VkIHRvIGVtdWxhdGUgUmVhY3QgZXJyb3IgYm91bmRhcmllcyBkdXJpbmcgU1NyIGJ5IHBlcmZvcm1pbmcgYSBzZWNvbmRcbiAgICogcGFzcyBvbmx5IGRvd24gdG8gdGhlIGJvdW5kYXJ5SWQuXG4gICAqXG4gICAqIFRoZSBvbmUgZXhjZXB0aW9uIHdoZXJlIHdlIGRvIG5vdCByZXR1cm4gYSBTdGF0aWNIYW5kbGVyQ29udGV4dCBpcyB3aGVuIGFcbiAgICogcmVkaXJlY3QgcmVzcG9uc2UgaXMgcmV0dXJuZWQgb3IgdGhyb3duIGZyb20gYW55IGFjdGlvbi9sb2FkZXIuICBXZVxuICAgKiBwcm9wYWdhdGUgdGhhdCBvdXQgYW5kIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIHNvIHRoZSBIVFRQIHNlcnZlciBjYW5cbiAgICogcmV0dXJuIGl0IGRpcmVjdGx5LlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICB7IHJlcXVlc3RDb250ZXh0IH06IHsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH0gPSB7fVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcblxuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gV2hlbiByZXR1cm5pbmcgU3RhdGljSGFuZGxlckNvbnRleHQsIHdlIHBhdGNoIGJhY2sgaW4gdGhlIGxvY2F0aW9uIGhlcmVcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIGl0IGZvciBSZWFjdCBDb250ZXh0LiAgQnV0IHRoaXMgaGVscHMga2VlcCBvdXIgc3VibWl0IGFuZFxuICAgIC8vIGxvYWRSb3V0ZURhdGEgb3BlcmF0aW5nIG9uIGEgUmVxdWVzdCBpbnN0ZWFkIG9mIGEgTG9jYXRpb25cbiAgICByZXR1cm4geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeVJvdXRlKCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciB0YXJnZXRlZCByb3V0ZSByZXF1ZXN0cywgZWl0aGVyXG4gICAqIGZvciBmZXRjaCA/X2RhdGEgcmVxdWVzdHMgb3IgcmVzb3VyY2Ugcm91dGUgcmVxdWVzdHMuICBJbiB0aGlzIGNhc2UsIHdlXG4gICAqIGFyZSBvbmx5IGV2ZXIgY2FsbGluZyBhIHNpbmdsZSBhY3Rpb24gb3IgbG9hZGVyLCBhbmQgd2UgYXJlIHJldHVybmluZyB0aGVcbiAgICogcmV0dXJuZWQgdmFsdWUgZGlyZWN0bHkuICBJbiBtb3N0IGNhc2VzLCB0aGlzIHdpbGwgYmUgYSBSZXNwb25zZSByZXR1cm5lZFxuICAgKiBmcm9tIHRoZSBhY3Rpb24vbG9hZGVyLCBidXQgaXQgbWF5IGJlIGEgcHJpbWl0aXZlIG9yIG90aGVyIHZhbHVlIGFzIHdlbGwgLVxuICAgKiBhbmQgaW4gc3VjaCBjYXNlcyB0aGUgY2FsbGluZyBjb250ZXh0IHNob3VsZCBoYW5kbGUgdGhhdCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogV2UgZG8gcmVzcGVjdCB0aGUgdGhyb3cvcmV0dXJuIGRpZmZlcmVudGlhdGlvbiwgc28gaWYgYW4gYWN0aW9uL2xvYWRlclxuICAgKiB0aHJvd3MsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB0aHJvdyB0aGUgdmFsdWUuICBUaGlzIGlzIGltcG9ydGFudCBzbyB3ZVxuICAgKiBjYW4gZG8gcHJvcGVyIGJvdW5kYXJ5IGlkZW50aWZpY2F0aW9uIGluIFJlbWl4IHdoZXJlIGEgdGhyb3duIFJlc3BvbnNlXG4gICAqIG11c3QgZ28gdG8gdGhlIENhdGNoIEJvdW5kYXJ5IGJ1dCBhIHJldHVybmVkIFJlc3BvbnNlIGlzIGhhcHB5LXBhdGguXG4gICAqXG4gICAqIE9uZSB0aGluZyB0byBub3RlIGlzIHRoYXQgYW55IFJvdXRlci1pbml0aWF0ZWQgRXJyb3JzIHRoYXQgbWFrZSBzZW5zZVxuICAgKiB0byBhc3NvY2lhdGUgd2l0aCBhIHN0YXR1cyBjb2RlIHdpbGwgYmUgdGhyb3duIGFzIGFuIEVycm9yUmVzcG9uc2VcbiAgICogaW5zdGFuY2Ugd2hpY2ggaW5jbHVkZSB0aGUgcmF3IEVycm9yLCBzdWNoIHRoYXQgdGhlIGNhbGxpbmcgY29udGV4dCBjYW5cbiAgICogc2VyaWFsaXplIHRoZSBlcnJvciBhcyB0aGV5IHNlZSBmaXQgd2hpbGUgaW5jbHVkaW5nIHRoZSBwcm9wZXIgcmVzcG9uc2VcbiAgICogY29kZS4gIEV4YW1wbGVzIGhlcmUgYXJlIDQwNCBhbmQgNDA1IGVycm9ycyB0aGF0IG9jY3VyIHByaW9yIHRvIHJlYWNoaW5nXG4gICAqIGFueSB1c2VyLWRlZmluZWQgbG9hZGVycy5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5Um91dGUoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgfTogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd247IHJvdXRlSWQ/OiBzdHJpbmcgfSA9IHt9XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG5cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkXG4gICAgICA/IG1hdGNoZXMuZmluZCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZClcbiAgICAgIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIG1hdGNoXG4gICAgKTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XG4gICAgICAvLyBfc29tZXRoaW5nXyB0aGF0IHdhc24ndCBhIFJlc3BvbnNlLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZC9yZXF1aXJlZFxuICAgICAgLy8gdG8gYmUgYW4gYGluc3RhbmNlb2YgRXJyb3JgIGVpdGhlciwgc28gd2UgaGF2ZSB0byB1c2UgdGhyb3cgaGVyZSB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIFBpY2sgb2ZmIHRoZSByaWdodCBzdGF0ZSB2YWx1ZSB0byByZXR1cm5cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmxvYWRlckRhdGEpIHtcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgICBpZiAocmVzdWx0LmFjdGl2ZURlZmVycmVkcz8uW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICBkYXRhW1VOU0FGRV9ERUZFUlJFRF9TWU1CT0xdID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbXBsKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICByZXF1ZXN0Q29udGV4dDogdW5rbm93bixcbiAgICByb3V0ZU1hdGNoPzogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICApOiBQcm9taXNlPE9taXQ8U3RhdGljSGFuZGxlckNvbnRleHQsIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIj4gfCBSZXNwb25zZT4ge1xuICAgIGludmFyaWFudChcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSByZXF1ZXN0cyBtdXN0IGNvbnRhaW4gYW4gQWJvcnRDb250cm9sbGVyIHNpZ25hbFwiXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByb3V0ZU1hdGNoIHx8IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICByb3V0ZU1hdGNoICE9IG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICByb3V0ZU1hdGNoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KVxuICAgICAgICA/IHJlc3VsdFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHRocmV3L3JldHVybmVkIGEgUmVzcG9uc2UgaW4gY2FsbExvYWRlck9yQWN0aW9uLCB3ZSB0aHJvd1xuICAgICAgLy8gaXQgdG8gYmFpbCBvdXQgYW5kIHRoZW4gcmV0dXJuIG9yIHRocm93IGhlcmUgYmFzZWQgb24gd2hldGhlciB0aGUgdXNlclxuICAgICAgLy8gcmV0dXJuZWQgb3IgdGhyZXdcbiAgICAgIGlmIChpc1F1ZXJ5Um91dGVSZXNwb25zZShlKSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIC8vIFJlZGlyZWN0cyBhcmUgYWx3YXlzIHJldHVybmVkIHNpbmNlIHRoZXkgZG9uJ3QgcHJvcGFnYXRlIHRvIGNhdGNoXG4gICAgICAvLyBib3VuZGFyaWVzXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgYWN0aW9uTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgaXNSb3V0ZVJlcXVlc3Q6IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxPbWl0PFN0YXRpY0hhbmRsZXJDb250ZXh0LCBcImxvY2F0aW9uXCIgfCBcImJhc2VuYW1lXCI+IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWQsXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgeyBpc1N0YXRpY1JlcXVlc3Q6IHRydWUsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCB9XG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWQ6ICR7cmVxdWVzdC5tZXRob2R9ICR7cmVxdWVzdC51cmx9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFVoaGhoIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB3ZSBzaG91bGQgYWx3YXlzIHRocm93IHRoZXNlIGZyb21cbiAgICAgIC8vIGNhbGxMb2FkZXJPckFjdGlvbiwgYnV0IHRoZSB0eXBlIG5hcnJvd2luZyBoZXJlIGtlZXBzIFRTIGhhcHB5IGFuZCB3ZVxuICAgICAgLy8gY2FuIGdldCBiYWNrIG9uIHRoZSBcInRocm93IGFsbCByZWRpcmVjdCByZXNwb25zZXNcIiB0cmFpbiBoZXJlIHNob3VsZFxuICAgICAgLy8gdGhpcyBldmVyIGhhcHBlbiA6L1xuICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IHJlc3VsdC5sb2NhdGlvbixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7IHR5cGU6IFwiZGVmZXItYWN0aW9uXCIgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIC8vIE5vdGU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgbm9uLVJlc3BvbnNlIHZhbHVlcyBpZiB3ZSBnZXQgaGVyZSwgc2luY2VcbiAgICAgIC8vIGlzUm91dGVSZXF1ZXN0IHNob3VsZCB0aHJvdyBhbnkgUmVzcG9uc2UgcmVjZWl2ZWQgaW4gY2FsbExvYWRlck9yQWN0aW9uXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAvLyBOb3RlOiBzdGF0dXNDb2RlICsgaGVhZGVycyBhcmUgdW51c2VkIGhlcmUgc2luY2UgcXVlcnlSb3V0ZSB3aWxsXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIG9yIHZhbHVlXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICA/IHJlc3VsdC5lcnJvci5zdGF0dXNcbiAgICAgICAgICA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAgIC4uLihyZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9KSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgbGV0IGxvYWRlclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxuICAgIH0pO1xuICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShsb2FkZXJSZXF1ZXN0LCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgLi4uKHJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30pLFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSxcbiAgICAgIH0sXG4gICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgIC4uLihyZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZURhdGEoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgcm91dGVNYXRjaD86IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcGVuZGluZ0FjdGlvbkVycm9yPzogUm91dGVEYXRhXG4gICk6IFByb21pc2U8XG4gICAgfCBPbWl0PFxuICAgICAgICBTdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgICAgICAgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImFjdGlvbkhlYWRlcnNcIlxuICAgICAgPlxuICAgIHwgUmVzcG9uc2VcbiAgPiB7XG4gICAgbGV0IGlzUm91dGVSZXF1ZXN0ID0gcm91dGVNYXRjaCAhPSBudWxsO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKFxuICAgICAgaXNSb3V0ZVJlcXVlc3QgJiZcbiAgICAgICFyb3V0ZU1hdGNoPy5yb3V0ZS5sb2FkZXIgJiZcbiAgICAgICFyb3V0ZU1hdGNoPy5yb3V0ZS5sYXp5XG4gICAgKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3RNYXRjaGVzID0gcm91dGVNYXRjaFxuICAgICAgPyBbcm91dGVNYXRjaF1cbiAgICAgIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBPYmplY3Qua2V5cyhwZW5kaW5nQWN0aW9uRXJyb3IgfHwge30pWzBdXG4gICAgICAgICk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5sb2FkZXIgfHwgbS5yb3V0ZS5sYXp5XG4gICAgKTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFttLnJvdXRlLmlkXTogbnVsbCB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApLFxuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25FcnJvciB8fCBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgIHsgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLCBpc1JvdXRlUmVxdWVzdCwgcmVxdWVzdENvbnRleHQgfVxuICAgICAgICApXG4gICAgICApLFxuICAgIF0pO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHttZXRob2R9KCkgY2FsbCBhYm9ydGVkOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT4oKTtcbiAgICBsZXQgY29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIHJlc3VsdHMsXG4gICAgICBwZW5kaW5nQWN0aW9uRXJyb3IsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gQWRkIGEgbnVsbCBmb3IgYW55IG5vbi1sb2FkZXIgbWF0Y2hlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgbGV0IGV4ZWN1dGVkTG9hZGVycyA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICAgIG1hdGNoZXNUb0xvYWQubWFwKChtYXRjaCkgPT4gbWF0Y2gucm91dGUuaWQpXG4gICAgKTtcbiAgICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBpZiAoIWV4ZWN1dGVkTG9hZGVycy5oYXMobWF0Y2gucm91dGUuaWQpKSB7XG4gICAgICAgIGNvbnRleHQubG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzOlxuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2l6ZSA+IDBcbiAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhhY3RpdmVEZWZlcnJlZHMuZW50cmllcygpKVxuICAgICAgICAgIDogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhUm91dGVzLFxuICAgIHF1ZXJ5LFxuICAgIHF1ZXJ5Um91dGUsXG4gIH07XG59XG5cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhlbHBlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogR2l2ZW4gYW4gZXhpc3RpbmcgU3RhdGljSGFuZGxlckNvbnRleHQgYW5kIGFuIGVycm9yIHRocm93biBhdCByZW5kZXIgdGltZSxcbiAqIHByb3ZpZGUgYW4gdXBkYXRlZCBTdGF0aWNIYW5kbGVyQ29udGV4dCBzdWl0YWJsZSBmb3IgYSBzZWNvbmQgU1NSIHJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgcm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdLFxuICBjb250ZXh0OiBTdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgZXJyb3I6IGFueVxuKSB7XG4gIGxldCBuZXdDb250ZXh0OiBTdGF0aWNIYW5kbGVyQ29udGV4dCA9IHtcbiAgICAuLi5jb250ZXh0LFxuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBlcnJvcnM6IHtcbiAgICAgIFtjb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZF06IGVycm9yLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiBuZXdDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKFxuICBvcHRzOiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnNcbik6IG9wdHMgaXMgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucyB7XG4gIHJldHVybiAoXG4gICAgb3B0cyAhPSBudWxsICYmXG4gICAgKChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwpIHx8XG4gICAgICAoXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvKFxuICBsb2NhdGlvbjogUGF0aCxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBiYXNlbmFtZTogc3RyaW5nLFxuICBwcmVwZW5kQmFzZW5hbWU6IGJvb2xlYW4sXG4gIHRvOiBUbyB8IG51bGwsXG4gIGZyb21Sb3V0ZUlkPzogc3RyaW5nLFxuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGVcbikge1xuICBsZXQgY29udGV4dHVhbE1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcbiAgbGV0IGFjdGl2ZVJvdXRlTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2ggfCB1bmRlZmluZWQ7XG4gIGlmIChmcm9tUm91dGVJZCAhPSBudWxsICYmIHJlbGF0aXZlICE9PSBcInBhdGhcIikge1xuICAgIC8vIEdyYWIgbWF0Y2hlcyB1cCB0byB0aGUgY2FsbGluZyByb3V0ZSBzbyBvdXIgcm91dGUtcmVsYXRpdmUgbG9naWMgaXNcbiAgICAvLyByZWxhdGl2ZSB0byB0aGUgY29ycmVjdCBzb3VyY2Ugcm91dGUuICBXaGVuIHVzaW5nIHJlbGF0aXZlOnBhdGgsXG4gICAgLy8gZnJvbVJvdXRlSWQgaXMgaWdub3JlZCBzaW5jZSB0aGF0IGlzIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgIC8vIGxvY2F0aW9uIHBhdGhcbiAgICBjb250ZXh0dWFsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgIGNvbnRleHR1YWxNYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkID09PSBmcm9tUm91dGVJZCkge1xuICAgICAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0dWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgYWN0aXZlUm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgdGhlIHJlbGF0aXZlIHBhdGhcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8gPyB0byA6IFwiLlwiLFxuICAgIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzKS5tYXAoKG0pID0+IG0ucGF0aG5hbWVCYXNlKSxcbiAgICBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG5cbiAgLy8gV2hlbiBgdG9gIGlzIG5vdCBzcGVjaWZpZWQgd2UgaW5oZXJpdCBzZWFyY2gvaGFzaCBmcm9tIHRoZSBjdXJyZW50XG4gIC8vIGxvY2F0aW9uLCB1bmxpa2Ugd2hlbiB0bz1cIi5cIiBhbmQgd2UganVzdCBpbmhlcml0IHRoZSBwYXRoLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuXG4gIC8vIEFkZCBhbiA/aW5kZXggcGFyYW0gZm9yIG1hdGNoZWQgaW5kZXggcm91dGVzIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKFxuICAgICh0byA9PSBudWxsIHx8IHRvID09PSBcIlwiIHx8IHRvID09PSBcIi5cIikgJiZcbiAgICBhY3RpdmVSb3V0ZU1hdGNoICYmXG4gICAgYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJlxuICAgICFoYXNOYWtlZEluZGV4UXVlcnkocGF0aC5zZWFyY2gpXG4gICkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2hcbiAgICAgID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKVxuICAgICAgOiBcIj9pbmRleFwiO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZS4gIElmXG4gIC8vIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3NcbiAgLy8gdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2hcbiAgLy8gb24gcm9vdCBhY3Rpb25zXG4gIGlmIChwcmVwZW5kQmFzZW5hbWUgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9XG4gICAgICBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG5cbi8vIE5vcm1hbGl6ZSBuYXZpZ2F0aW9uIG9wdGlvbnMgYnkgY29udmVydGluZyBmb3JtTWV0aG9kPUdFVCBmb3JtRGF0YSBvYmplY3RzIHRvXG4vLyBVUkxTZWFyY2hQYXJhbXMgc28gdGhleSBiZWhhdmUgaWRlbnRpY2FsbHkgdG8gbGlua3Mgd2l0aCBxdWVyeSBwYXJhbXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgbm9ybWFsaXplRm9ybU1ldGhvZDogYm9vbGVhbixcbiAgaXNGZXRjaGVyOiBib29sZWFuLFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnNcbik6IHtcbiAgcGF0aDogc3RyaW5nO1xuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgZXJyb3I/OiBFcnJvclJlc3BvbnNlSW1wbDtcbn0ge1xuICAvLyBSZXR1cm4gbG9jYXRpb24gdmVyYmF0aW0gb24gbm9uLXN1Ym1pc3Npb24gbmF2aWdhdGlvbnNcbiAgaWYgKCFvcHRzIHx8ICFpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCB9O1xuICB9XG5cbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kOiBvcHRzLmZvcm1NZXRob2QgfSksXG4gICAgfTtcbiAgfVxuXG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImludmFsaWQtYm9keVwiIH0pLFxuICB9KTtcblxuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSBub3JtYWxpemVGb3JtTWV0aG9kXG4gICAgPyAocmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIGFzIFY3X0Zvcm1NZXRob2QpXG4gICAgOiAocmF3Rm9ybU1ldGhvZC50b0xvd2VyQ2FzZSgpIGFzIEZvcm1NZXRob2QpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpO1xuXG4gIGlmIChvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgLy8gdGV4dCBvbmx5IHN1cHBvcnQgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRleHQgPVxuICAgICAgICB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgPyBvcHRzLmJvZHlcbiAgICAgICAgICA6IG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8XG4gICAgICAgICAgICBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXNcbiAgICAgICAgICA/IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI3BsYWluLXRleHQtZm9ybS1kYXRhXG4gICAgICAgICAgICBBcnJheS5mcm9tKG9wdHMuYm9keS5lbnRyaWVzKCkpLnJlZHVjZShcbiAgICAgICAgICAgICAgKGFjYywgW25hbWUsIHZhbHVlXSkgPT4gYCR7YWNjfSR7bmFtZX09JHt2YWx1ZX1cXG5gLFxuICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBTdHJpbmcob3B0cy5ib2R5KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICAvLyBqc29uIG9ubHkgc3VwcG9ydHMgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPVxuICAgICAgICAgIHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG9wdHMuYm9keSkgOiBvcHRzLmJvZHk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGludmFyaWFudChcbiAgICB0eXBlb2YgRm9ybURhdGEgPT09IFwiZnVuY3Rpb25cIixcbiAgICBcIkZvcm1EYXRhIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiXG4gICk7XG5cbiAgbGV0IHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zO1xuICBsZXQgZm9ybURhdGE6IEZvcm1EYXRhO1xuXG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmZvcm1EYXRhO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuYm9keTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBvcHRzLmJvZHk7XG4gICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uID0ge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTpcbiAgICAgIChvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUpIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgZm9ybURhdGEsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgfTtcblxuICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCwgc3VibWlzc2lvbiB9O1xuICB9XG5cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIC8vIE9uIEdFVCBuYXZpZ2F0aW9uIHN1Ym1pc3Npb25zIHdlIGNhbiBkcm9wIHRoZSA/aW5kZXggcGFyYW0gZnJvbSB0aGVcbiAgLy8gcmVzdWx0aW5nIGxvY2F0aW9uIHNpbmNlIGFsbCBsb2FkZXJzIHdpbGwgcnVuLiAgQnV0IGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zXG4gIC8vIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciBzbyB3ZSBuZWVkIHRvIHByZXNlcnZlIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcblxuICByZXR1cm4geyBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLCBzdWJtaXNzaW9uIH07XG59XG5cbi8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyBhbnkgY2F1Z2h0IGVycm9yIGFzIHRoZXkgYXJlbid0IGdvaW5nIHRvXG4vLyByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGJvdW5kYXJ5SWQ/OiBzdHJpbmdcbikge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRhcnlNYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKFxuICBoaXN0b3J5OiBIaXN0b3J5LFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgc3VibWlzc2lvbjogU3VibWlzc2lvbiB8IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBpc1JldmFsaWRhdGlvblJlcXVpcmVkOiBib29sZWFuLFxuICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlczogc3RyaW5nW10sXG4gIGNhbmNlbGxlZEZldGNoZXJMb2Fkczogc3RyaW5nW10sXG4gIGZldGNoTG9hZE1hdGNoZXM6IE1hcDxzdHJpbmcsIEZldGNoTG9hZE1hdGNoPixcbiAgZmV0Y2hSZWRpcmVjdElkczogU2V0PHN0cmluZz4sXG4gIHJvdXRlc1RvVXNlOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdLFxuICBiYXNlbmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YSxcbiAgcGVuZGluZ0Vycm9yPzogUm91dGVEYXRhXG4pOiBbQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLCBSZXZhbGlkYXRpbmdGZXRjaGVyW11dIHtcbiAgbGV0IGFjdGlvblJlc3VsdCA9IHBlbmRpbmdFcnJvclxuICAgID8gT2JqZWN0LnZhbHVlcyhwZW5kaW5nRXJyb3IpWzBdXG4gICAgOiBwZW5kaW5nQWN0aW9uRGF0YVxuICAgID8gT2JqZWN0LnZhbHVlcyhwZW5kaW5nQWN0aW9uRGF0YSlbMF1cbiAgICA6IHVuZGVmaW5lZDtcblxuICBsZXQgY3VycmVudFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0YXRlLmxvY2F0aW9uKTtcbiAgbGV0IG5leHRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChsb2NhdGlvbik7XG5cbiAgLy8gUGljayBuYXZpZ2F0aW9uIG1hdGNoZXMgdGhhdCBhcmUgbmV0LW5ldyBvciBxdWFsaWZ5IGZvciByZXZhbGlkYXRpb25cbiAgbGV0IGJvdW5kYXJ5SWQgPSBwZW5kaW5nRXJyb3IgPyBPYmplY3Qua2V5cyhwZW5kaW5nRXJyb3IpWzBdIDogdW5kZWZpbmVkO1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCk7XG5cbiAgbGV0IG5hdmlnYXRpb25NYXRjaGVzID0gYm91bmRhcnlNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIC8vIFdlIGhhdmVuJ3QgbG9hZGVkIHRoaXMgcm91dGUgeWV0IHNvIHdlIGRvbid0IGtub3cgaWYgaXQncyBnb3QgYSBsb2FkZXIhXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxvYWRlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGNhbGwgdGhlIGxvYWRlciBvbiBuZXcgcm91dGUgaW5zdGFuY2VzIGFuZCBwZW5kaW5nIGRlZmVyIGNhbmNlbGxhdGlvbnNcbiAgICBpZiAoXG4gICAgICBpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8XG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5zb21lKChpZCkgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igd2hlbiB3ZSByZXZhbGlkYXRlLiAgSWYgdGhlIHJvdXRlXG4gICAgLy8gcHJvdmlkZXMgaXQncyBvd24gaW1wbGVtZW50YXRpb24sIHRoZW4gd2UgZ2l2ZSB0aGVtIGZ1bGwgY29udHJvbCBidXRcbiAgICAvLyBwcm92aWRlIHRoaXMgdmFsdWUgc28gdGhleSBjYW4gbGV2ZXJhZ2UgaXQgaWYgbmVlZGVkIGFmdGVyIHRoZXkgY2hlY2tcbiAgICAvLyB0aGVpciBvd24gc3BlY2lmaWMgdXNlIGNhc2VzXG4gICAgbGV0IGN1cnJlbnRSb3V0ZU1hdGNoID0gc3RhdGUubWF0Y2hlc1tpbmRleF07XG4gICAgbGV0IG5leHRSb3V0ZU1hdGNoID0gbWF0Y2g7XG5cbiAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwge1xuICAgICAgY3VycmVudFVybCxcbiAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6XG4gICAgICAgIC8vIEZvcmNlZCByZXZhbGlkYXRpb24gZHVlIHRvIHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGVcbiAgICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fFxuICAgICAgICAvLyBDbGlja2VkIHRoZSBzYW1lIGxpbmssIHJlc3VibWl0dGVkIGEgR0VUIGZvcm1cbiAgICAgICAgY3VycmVudFVybC5wYXRobmFtZSArIGN1cnJlbnRVcmwuc2VhcmNoID09PVxuICAgICAgICAgIG5leHRVcmwucGF0aG5hbWUgKyBuZXh0VXJsLnNlYXJjaCB8fFxuICAgICAgICAvLyBTZWFyY2ggcGFyYW1zIGFmZmVjdCBhbGwgbG9hZGVyc1xuICAgICAgICBjdXJyZW50VXJsLnNlYXJjaCAhPT0gbmV4dFVybC5zZWFyY2ggfHxcbiAgICAgICAgaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRSb3V0ZU1hdGNoLCBuZXh0Um91dGVNYXRjaCksXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFBpY2sgZmV0Y2hlci5sb2FkcyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzOiBSZXZhbGlkYXRpbmdGZXRjaGVyW10gPSBbXTtcbiAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChmLCBrZXkpID0+IHtcbiAgICAvLyBEb24ndCByZXZhbGlkYXRlIGlmIGZldGNoZXIgd29uJ3QgYmUgcHJlc2VudCBpbiB0aGUgc3Vic2VxdWVudCByZW5kZXJcbiAgICBpZiAoIW1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBmZXRjaGVyTWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBmLnBhdGgsIGJhc2VuYW1lKTtcblxuICAgIC8vIElmIHRoZSBmZXRjaGVyIHBhdGggbm8gbG9uZ2VyIG1hdGNoZXMsIHB1c2ggaXQgaW4gd2l0aCBudWxsIG1hdGNoZXMgc29cbiAgICAvLyB3ZSBjYW4gdHJpZ2dlciBhIDQwNCBpbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEuICBOb3RlIHRoaXMgaXNcbiAgICAvLyBjdXJyZW50bHkgb25seSBhIHVzZS1jYXNlIGZvciBSZW1peCBITVIgd2hlcmUgdGhlIHJvdXRlIHRyZWUgY2FuIGNoYW5nZVxuICAgIC8vIGF0IHJ1bnRpbWUgYW5kIHJlbW92ZSBhIHJvdXRlIHByZXZpb3VzbHkgbG9hZGVkIHZpYSBhIGZldGNoZXJcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogbnVsbCxcbiAgICAgICAgbWF0Y2g6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXZhbGlkYXRpbmcgZmV0Y2hlcnMgYXJlIGRlY291cGxlZCBmcm9tIHRoZSByb3V0ZSBtYXRjaGVzIHNpbmNlIHRoZXlcbiAgICAvLyBsb2FkIGZyb20gYSBzdGF0aWMgaHJlZi4gIFRoZXkgcmV2YWxpZGF0ZSBiYXNlZCBvbiBleHBsaWNpdCByZXZhbGlkYXRpb25cbiAgICAvLyAoc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZSlcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcblxuICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgaWYgKGZldGNoUmVkaXJlY3RJZHMuaGFzKGtleSkpIHtcbiAgICAgIC8vIE5ldmVyIHRyaWdnZXIgYSByZXZhbGlkYXRpb24gb2YgYW4gYWN0aXZlbHkgcmVkaXJlY3RpbmcgZmV0Y2hlclxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIC8vIEFsd2F5cyByZXZhbGlkYXRlIGlmIHRoZSBmZXRjaGVyIHdhcyBjYW5jZWxsZWRcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBmZXRjaGVyICYmXG4gICAgICBmZXRjaGVyLnN0YXRlICE9PSBcImlkbGVcIiAmJlxuICAgICAgZmV0Y2hlci5kYXRhID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIC8vIElmIHRoZSBmZXRjaGVyIGhhc24ndCBldmVyIGNvbXBsZXRlZCBsb2FkaW5nIHlldCwgdGhlbiB0aGlzIGlzbid0IGFcbiAgICAgIC8vIHJldmFsaWRhdGlvbiwgaXQgd291bGQganVzdCBiZSBhIGJyYW5kIG5ldyBsb2FkIGlmIGFuIGV4cGxpY2l0XG4gICAgICAvLyByZXZhbGlkYXRpb24gaXMgcmVxdWlyZWRcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBpc1JldmFsaWRhdGlvblJlcXVpcmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIG9uIGFueSB1c2VyLWRlZmluZWQgc2hvdWxkUmV2YWxpZGF0ZSwgZGVmYXVsdGluZ1xuICAgICAgLy8gdG8gZXhwbGljaXQgcmV2YWxpZGF0aW9ucyBvbmx5XG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihmZXRjaGVyTWF0Y2gsIHtcbiAgICAgICAgY3VycmVudFVybCxcbiAgICAgICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1tzdGF0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgICAgbmV4dFVybCxcbiAgICAgICAgbmV4dFBhcmFtczogbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFtuYXZpZ2F0aW9uTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdO1xufVxuXG5mdW5jdGlvbiBpc05ld0xvYWRlcihcbiAgY3VycmVudExvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgY3VycmVudE1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuKSB7XG4gIGxldCBpc05ldyA9XG4gICAgLy8gW2FdIC0+IFthLCBiXVxuICAgICFjdXJyZW50TWF0Y2ggfHxcbiAgICAvLyBbYSwgYl0gLT4gW2EsIGNdXG4gICAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZDtcblxuICAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBoYXZlIGRhdGEgZm9yIGEgcmUtdXNlZCByb3V0ZSwgcG90ZW50aWFsbHlcbiAgLy8gZnJvbSBhIHByaW9yIGVycm9yIG9yIGZyb20gYSBjYW5jZWxsZWQgcGVuZGluZyBkZWZlcnJlZFxuICBsZXQgaXNNaXNzaW5nRGF0YSA9IGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkO1xuXG4gIC8vIEFsd2F5cyBsb2FkIGlmIHRoaXMgaXMgYSBuZXQtbmV3IHJvdXRlIG9yIHdlIGRvbid0IHlldCBoYXZlIGRhdGFcbiAgcmV0dXJuIGlzTmV3IHx8IGlzTWlzc2luZ0RhdGE7XG59XG5cbmZ1bmN0aW9uIGlzTmV3Um91dGVJbnN0YW5jZShcbiAgY3VycmVudE1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xuICByZXR1cm4gKFxuICAgIC8vIHBhcmFtIGNoYW5nZSBmb3IgdGhpcyBtYXRjaCwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fFxuICAgIC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICAoY3VycmVudFBhdGggIT0gbnVsbCAmJlxuICAgICAgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmXG4gICAgICBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihcbiAgbG9hZGVyTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGFyZzogU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJnc1xuKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIHJvdXRlLmxhenkoKSBtZXRob2RzIHRvIGxhemlseSBsb2FkIHJvdXRlIG1vZHVsZXMgKGxvYWRlciwgYWN0aW9uLFxuICogc2hvdWxkUmV2YWxpZGF0ZSkgYW5kIHVwZGF0ZSB0aGUgcm91dGVNYW5pZmVzdCBpbiBwbGFjZSB3aGljaCBzaGFyZXMgb2JqZWN0c1xuICogd2l0aCBkYXRhUm91dGVzIHNvIHRob3NlIGdldCB1cGRhdGVkIGFzIHdlbGwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRMYXp5Um91dGVNb2R1bGUoXG4gIHJvdXRlOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3Rcbikge1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuXG4gIC8vIElmIHRoZSBsYXp5IHJvdXRlIGZ1bmN0aW9uIHdhcyBleGVjdXRlZCBhbmQgcmVtb3ZlZCBieSBhbm90aGVyIHBhcmFsbGVsXG4gIC8vIGNhbGwgdGhlbiB3ZSBjYW4gcmV0dXJuIC0gZmlyc3QgbGF6eSgpIHRvIGZpbmlzaCB3aW5zIGJlY2F1c2UgdGhlIHJldHVyblxuICAvLyB2YWx1ZSBvZiBsYXp5IGlzIGV4cGVjdGVkIHRvIGJlIHN0YXRpY1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG5cbiAgLy8gVXBkYXRlIHRoZSByb3V0ZSBpbiBwbGFjZS4gIFRoaXMgc2hvdWxkIGJlIHNhZmUgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxuICAvLyB3ZSBjb3VsZCB5ZXQgYmUgc2l0dGluZyBvbiB0aGlzIHJvdXRlIGFzIHdlIGNhbid0IGdldCB0aGVyZSB3aXRob3V0XG4gIC8vIHJlc29sdmluZyBsYXp5KCkgZmlyc3QuXG4gIC8vXG4gIC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIEhNUiBcInVwZGF0ZVwiIHVzZS1jYXNlIHdoZXJlIHdlIG1heSBhY3RpdmVseSBiZVxuICAvLyBvbiB0aGUgcm91dGUgYmVpbmcgdXBkYXRlZC4gIFRoZSBtYWluIGNvbmNlcm4gYm9pbHMgZG93biB0byBcImRvZXMgdGhpc1xuICAvLyBtdXRhdGlvbiBhZmZlY3QgYW55IG9uZ29pbmcgbmF2aWdhdGlvbnMgb3IgYW55IGN1cnJlbnQgc3RhdGUubWF0Y2hlc1xuICAvLyB2YWx1ZXM/XCIuICBJZiBub3QsIGl0IHNob3VsZCBiZSBzYWZlIHRvIHVwZGF0ZSBpbiBwbGFjZS5cbiAgbGV0IHJvdXRlVXBkYXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9XG4gICAgICByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5IGFzIGtleW9mIHR5cGVvZiByb3V0ZVRvVXBkYXRlXTtcblxuICAgIGxldCBpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgPVxuICAgICAgc3RhdGljUm91dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAgIC8vIG9uIHRoZSByb3V0ZSB1cGRhdGVzXG4gICAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG5cbiAgICB3YXJuaW5nKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCxcbiAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIGAgK1xuICAgICAgICBgZGVmaW5lZCBidXQgaXRzIGxhenkgZnVuY3Rpb24gaXMgYWxzbyByZXR1cm5pbmcgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eS4gYCArXG4gICAgICAgIGBUaGUgbGF6eSByb3V0ZSBwcm9wZXJ0eSBcIiR7bGF6eVJvdXRlUHJvcGVydHl9XCIgd2lsbCBiZSBpZ25vcmVkLmBcbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCAmJlxuICAgICAgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkgYXMgSW1tdXRhYmxlUm91dGVLZXkpXG4gICAgKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID1cbiAgICAgICAgbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5IGFzIGtleW9mIHR5cGVvZiBsYXp5Um91dGVdO1xuICAgIH1cbiAgfVxuXG4gIC8vIE11dGF0ZSB0aGUgcm91dGUgd2l0aCB0aGUgcHJvdmlkZWQgdXBkYXRlcy4gIERvIHRoaXMgZmlyc3Qgc28gd2UgcGFzc1xuICAvLyB0aGUgdXBkYXRlZCB2ZXJzaW9uIHRvIG1hcFJvdXRlUHJvcGVydGllc1xuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHJvdXRlVXBkYXRlcyk7XG5cbiAgLy8gTXV0YXRlIHRoZSBgaGFzRXJyb3JCb3VuZGFyeWAgcHJvcGVydHkgb24gdGhlIHJvdXRlIGJhc2VkIG9uIHRoZSByb3V0ZVxuICAvLyB1cGRhdGVzIGFuZCByZW1vdmUgdGhlIGBsYXp5YCBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNvbHZlIHRoZSBsYXp5XG4gIC8vIHJvdXRlIGFnYWluLlxuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHtcbiAgICAvLyBUbyBrZWVwIHRoaW5ncyBmcmFtZXdvcmsgYWdub3N0aWMsIHdlIHVzZSB0aGUgcHJvdmlkZWRcbiAgICAvLyBgbWFwUm91dGVQcm9wZXJ0aWVzYCAob3Igd3JhcHBlZCBgZGV0ZWN0RXJyb3JCb3VuZGFyeWApIGZ1bmN0aW9uIHRvXG4gICAgLy8gc2V0IHRoZSBmcmFtZXdvcmstYXdhcmUgcHJvcGVydGllcyAoYGVsZW1lbnRgL2BoYXNFcnJvckJvdW5kYXJ5YCkgc2luY2VcbiAgICAvLyB0aGUgbG9naWMgd2lsbCBkaWZmZXIgYmV0d2VlbiBmcmFtZXdvcmtzLlxuICAgIC4uLm1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZVRvVXBkYXRlKSxcbiAgICBsYXp5OiB1bmRlZmluZWQsXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gIHR5cGU6IFwibG9hZGVyXCIgfCBcImFjdGlvblwiLFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYW5pZmVzdDogUm91dGVNYW5pZmVzdCxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgYmFzZW5hbWU6IHN0cmluZyxcbiAgb3B0czoge1xuICAgIGlzU3RhdGljUmVxdWVzdD86IGJvb2xlYW47XG4gICAgaXNSb3V0ZVJlcXVlc3Q/OiBib29sZWFuO1xuICAgIHJlcXVlc3RDb250ZXh0PzogdW5rbm93bjtcbiAgfSA9IHt9XG4pOiBQcm9taXNlPERhdGFSZXN1bHQ+IHtcbiAgbGV0IHJlc3VsdFR5cGU7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBvblJlamVjdDogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuXG4gIGxldCBydW5IYW5kbGVyID0gKGhhbmRsZXI6IEFjdGlvbkZ1bmN0aW9uIHwgTG9hZGVyRnVuY3Rpb24pID0+IHtcbiAgICAvLyBTZXR1cCBhIHByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCBzbyB0aGF0IGFib3J0IHNpZ25hbHMgc2hvcnQgY2lyY3VpdFxuICAgIGxldCByZWplY3Q6ICgpID0+IHZvaWQ7XG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiAocmVqZWN0ID0gcikpO1xuICAgIG9uUmVqZWN0ID0gKCkgPT4gcmVqZWN0KCk7XG4gICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIGhhbmRsZXIoe1xuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgY29udGV4dDogb3B0cy5yZXF1ZXN0Q29udGV4dCxcbiAgICAgIH0pLFxuICAgICAgYWJvcnRQcm9taXNlLFxuICAgIF0pO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcblxuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBSdW4gc3RhdGljYWxseSBkZWZpbmVkIGhhbmRsZXIgaW4gcGFyYWxsZWwgd2l0aCBsYXp5KClcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAvLyBJZiB0aGUgaGFuZGxlciB0aHJvd3MsIGRvbid0IGxldCBpdCBpbW1lZGlhdGVseSBidWJibGUgb3V0LFxuICAgICAgICAgIC8vIHNpbmNlIHdlIG5lZWQgdG8gbGV0IHRoZSBsYXp5KCkgZXhlY3V0aW9uIGZpbmlzaCBzbyB3ZSBrbm93IGlmIHRoaXNcbiAgICAgICAgICAvLyByb3V0ZSBoYXMgYSBib3VuZGFyeSB0aGF0IGNhbiBoYW5kbGUgdGhlIGVycm9yXG4gICAgICAgICAgcnVuSGFuZGxlcihoYW5kbGVyKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlckVycm9yID0gZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBsb2FkTGF6eVJvdXRlTW9kdWxlKG1hdGNoLnJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KSxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChoYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBoYW5kbGVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9hZCBsYXp5IHJvdXRlIG1vZHVsZSwgdGhlbiBydW4gYW55IHJldHVybmVkIGhhbmRsZXJcbiAgICAgICAgYXdhaXQgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCk7XG5cbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIC8vIEhhbmRsZXIgc3RpbGwgcnVuIGV2ZW4gaWYgd2UgZ290IGludGVycnVwdGVkIHRvIG1haW50YWluIGNvbnNpc3RlbmN5XG4gICAgICAgICAgLy8gd2l0aCB1bi1hYm9ydGFibGUgYmVoYXZpb3Igb2YgaGFuZGxlciBleGVjdXRpb24gb24gbm9uLWxhenkgb3JcbiAgICAgICAgICAvLyBwcmV2aW91c2x5LWxhenktbG9hZGVkIHJvdXRlc1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICByb3V0ZUlkOiBtYXRjaC5yb3V0ZS5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXp5KCkgcm91dGUgaGFzIG5vIGxvYWRlciB0byBydW4uICBTaG9ydCBjaXJjdWl0IGhlcmUgc28gd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoaXQgdGhlIGludmFyaWFudCBiZWxvdyB0aGF0IGVycm9ycyBvbiByZXR1cm5pbmcgdW5kZWZpbmVkLlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGF0YSwgZGF0YTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXN1bHQgIT09IHVuZGVmaW5lZCxcbiAgICAgIGBZb3UgZGVmaW5lZCAke3R5cGUgPT09IFwiYWN0aW9uXCIgPyBcImFuIGFjdGlvblwiIDogXCJhIGxvYWRlclwifSBmb3Igcm91dGUgYCArXG4gICAgICAgIGBcIiR7bWF0Y2gucm91dGUuaWR9XCIgYnV0IGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZnJvbSB5b3VyIFxcYCR7dHlwZX1cXGAgYCArXG4gICAgICAgIGBmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHRUeXBlID0gUmVzdWx0VHlwZS5lcnJvcjtcbiAgICByZXN1bHQgPSBlO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG5cbiAgICAvLyBQcm9jZXNzIHJlZGlyZWN0c1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXMpKSB7XG4gICAgICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIFwiUmVkaXJlY3RzIHJldHVybmVkL3Rocm93biBmcm9tIGxvYWRlcnMvYWN0aW9ucyBtdXN0IGhhdmUgYSBMb2NhdGlvbiBoZWFkZXJcIlxuICAgICAgKTtcblxuICAgICAgLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuICAgICAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgbG9jYXRpb24gPSBub3JtYWxpemVUbyhcbiAgICAgICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgICAgICBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuaW5kZXhPZihtYXRjaCkgKyAxKSxcbiAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIGxvY2F0aW9uXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIHByb3RvY29sK29yaWdpbiBmb3Igc2FtZS1vcmlnaW4gKyBzYW1lLWJhc2VuYW1lIGFic29sdXRlXG4gICAgICAgIC8vIHJlZGlyZWN0cy4gSWYgdGhpcyBpcyBhIHN0YXRpYyByZXF1ZXN0LCB3ZSBjYW4gbGV0IGl0IGdvIGJhY2sgdG8gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIgYXMtaXNcbiAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgbGV0IHVybCA9IGxvY2F0aW9uLnN0YXJ0c1dpdGgoXCIvL1wiKVxuICAgICAgICAgID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgbG9jYXRpb24pXG4gICAgICAgICAgOiBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBwcm9jZXNzIHJlZGlyZWN0cyBpbiB0aGUgcm91dGVyIGR1cmluZyBzdGF0aWMgcmVxdWVzdHMgcmVxdWVzdHMuXG4gICAgICAvLyBJbnN0ZWFkLCB0aHJvdyB0aGUgUmVzcG9uc2UgYW5kIGxldCB0aGUgc2VydmVyIGhhbmRsZSBpdCB3aXRoIGFuIEhUVFBcbiAgICAgIC8vIHJlZGlyZWN0LiAgV2UgYWxzbyB1cGRhdGUgdGhlIExvY2F0aW9uIGhlYWRlciBpbiBwbGFjZSBpbiB0aGlzIGZsb3cgc29cbiAgICAgIC8vIGJhc2VuYW1lIGFuZCByZWxhdGl2ZSByb3V0aW5nIGlzIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgaWYgKG9wdHMuaXNTdGF0aWNSZXF1ZXN0KSB7XG4gICAgICAgIHJlc3VsdC5oZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLnJlZGlyZWN0LFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRlOiByZXN1bHQuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikgIT09IG51bGwsXG4gICAgICAgIHJlbG9hZERvY3VtZW50OiByZXN1bHQuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSAhPT0gbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRm9yIFNTUiBzaW5nbGUtcm91dGUgcmVxdWVzdHMsIHdlIHdhbnQgdG8gaGFuZCBSZXNwb25zZXMgYmFjayBkaXJlY3RseVxuICAgIC8vIHdpdGhvdXQgdW53cmFwcGluZy4gIFdlIGRvIHRoaXMgd2l0aCB0aGUgUXVlcnlSb3V0ZVJlc3BvbnNlIHdyYXBwZXJcbiAgICAvLyBpbnRlcmZhY2Ugc28gd2UgY2FuIGtub3cgd2hldGhlciBpdCB3YXMgcmV0dXJuZWQgb3IgdGhyb3duXG4gICAgaWYgKG9wdHMuaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIGxldCBxdWVyeVJvdXRlUmVzcG9uc2U6IFF1ZXJ5Um91dGVSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTpcbiAgICAgICAgICByZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yID8gUmVzdWx0VHlwZS5lcnJvciA6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgIH07XG4gICAgICB0aHJvdyBxdWVyeVJvdXRlUmVzcG9uc2U7XG4gICAgfVxuXG4gICAgbGV0IGRhdGE6IGFueTtcbiAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgLy8gQ2hlY2sgYmV0d2VlbiB3b3JkIGJvdW5kYXJpZXMgaW5zdGVhZCBvZiBzdGFydHNXaXRoKCkgZHVlIHRvIHRoZSBsYXN0XG4gICAgLy8gcGFyYWdyYXBoIG9mIGh0dHBzOi8vaHR0cHdnLm9yZy9zcGVjcy9yZmM5MTEwLmh0bWwjZmllbGQuY29udGVudC10eXBlXG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC50ZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHJlc3VsdFR5cGUsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YSksXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgZGF0YSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICByZXR1cm4geyB0eXBlOiByZXN1bHRUeXBlLCBlcnJvcjogcmVzdWx0IH07XG4gIH1cblxuICBpZiAoaXNEZWZlcnJlZERhdGEocmVzdWx0KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkLFxuICAgICAgZGVmZXJyZWREYXRhOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmluaXQ/LmhlYWRlcnMgJiYgbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycyksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGF0YSwgZGF0YTogcmVzdWx0IH07XG59XG5cbi8vIFV0aWxpdHkgbWV0aG9kIGZvciBjcmVhdGluZyB0aGUgUmVxdWVzdCBpbnN0YW5jZXMgZm9yIGxvYWRlcnMvYWN0aW9ucyBkdXJpbmdcbi8vIGNsaWVudC1zaWRlIG5hdmlnYXRpb25zIGFuZCBmZXRjaGVzLiAgRHVyaW5nIFNTUiB3ZSB3aWxsIGFsd2F5cyBoYXZlIGFcbi8vIFJlcXVlc3QgaW5zdGFuY2UgZnJvbSB0aGUgc3RhdGljIGhhbmRsZXIgKHF1ZXJ5L3F1ZXJ5Um91dGUpXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgaGlzdG9yeTogSGlzdG9yeSxcbiAgbG9jYXRpb246IHN0cmluZyB8IExvY2F0aW9uLFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuKTogUmVxdWVzdCB7XG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XG4gIGxldCBpbml0OiBSZXF1ZXN0SW5pdCA9IHsgc2lnbmFsIH07XG5cbiAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUVuY1R5cGUgfSA9IHN1Ym1pc3Npb247XG4gICAgLy8gRGlkbid0IHRoaW5rIHdlIG5lZWRlZCB0aGlzIGJ1dCBpdCB0dXJucyBvdXQgdW5saWtlIG90aGVyIG1ldGhvZHMsIHBhdGNoXG4gICAgLy8gd29uJ3QgYmUgcHJvcGVybHkgbm9ybWFsaXplZCB0byB1cHBlcmNhc2UgYW5kIHJlc3VsdHMgaW4gYSA0MDUgZXJyb3IuXG4gICAgLy8gU2VlOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2RcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcblxuICAgIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogZm9ybUVuY1R5cGUgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24udGV4dDtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgJiZcbiAgICAgIHN1Ym1pc3Npb24uZm9ybURhdGFcbiAgICApIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoc3VibWlzc2lvbi5mb3JtRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoZm9ybURhdGE6IEZvcm1EYXRhKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY29udmVydGluZy1hbi1lbnRyeS1saXN0LXRvLWEtbGlzdC1vZi1uYW1lLXZhbHVlLXBhaXJzXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cblxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShcbiAgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNcbik6IEZvcm1EYXRhIHtcbiAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBzZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgcGVuZGluZ0Vycm9yOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQsXG4gIGFjdGl2ZURlZmVycmVkczogTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPlxuKToge1xuICBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIGVycm9yczogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl0gfCBudWxsO1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+O1xufSB7XG4gIC8vIEZpbGwgaW4gbG9hZGVyRGF0YS9lcnJvcnMgZnJvbSBvdXIgbG9hZGVyc1xuICBsZXQgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdID0ge307XG4gIGxldCBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdIHwgbnVsbCA9IG51bGw7XG4gIGxldCBzdGF0dXNDb2RlOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPiA9IHt9O1xuXG4gIC8vIFByb2Nlc3MgbG9hZGVyIHJlc3VsdHMgaW50byBzdGF0ZS5sb2FkZXJEYXRhL3N0YXRlLmVycm9yc1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICBsZXQgaWQgPSBtYXRjaGVzVG9Mb2FkW2luZGV4XS5yb3V0ZS5pZDtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpLFxuICAgICAgXCJDYW5ub3QgaGFuZGxlIHJlZGlyZWN0IHJlc3VsdHMgaW4gcHJvY2Vzc0xvYWRlckRhdGFcIlxuICAgICk7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gTG9vayB1cHdhcmRzIGZyb20gdGhlIG1hdGNoZWQgcm91dGUgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGlkKTtcbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nIGFjdGlvbiBlcnJvciwgd2UgcmVwb3J0IGl0IGF0IHRoZSBoaWdoZXN0LXJvdXRlXG4gICAgICAvLyB0aGF0IHRocm93cyBhIGxvYWRlciBlcnJvciwgYW5kIHRoZW4gY2xlYXIgaXQgb3V0IHRvIGluZGljYXRlIHRoYXRcbiAgICAgIC8vIGl0IHdhcyBjb25zdW1lZFxuICAgICAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgICAgICBlcnJvciA9IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXTtcbiAgICAgICAgcGVuZGluZ0Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBlcnJvcnMgPSBlcnJvcnMgfHwge307XG5cbiAgICAgIC8vIFByZWZlciBoaWdoZXIgZXJyb3IgdmFsdWVzIGlmIGxvd2VyIGVycm9ycyBidWJibGUgdG8gdGhlIHNhbWUgYm91bmRhcnlcbiAgICAgIGlmIChlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPT0gbnVsbCkge1xuICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgb3VyIGFueSBwcmlvciBsb2FkZXJEYXRhIGZvciB0aGUgdGhyb3dpbmcgcm91dGVcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBPbmNlIHdlIGZpbmQgb3VyIGZpcnN0IChoaWdoZXN0KSBlcnJvciwgd2Ugc2V0IHRoZSBzdGF0dXMgY29kZSBhbmRcbiAgICAgIC8vIHByZXZlbnQgZGVlcGVyIHN0YXR1cyBjb2RlcyBmcm9tIG92ZXJyaWRpbmdcbiAgICAgIGlmICghZm91bmRFcnJvcikge1xuICAgICAgICBmb3VuZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgc3RhdHVzQ29kZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICA/IHJlc3VsdC5lcnJvci5zdGF0dXNcbiAgICAgICAgICA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zZXQoaWQsIHJlc3VsdC5kZWZlcnJlZERhdGEpO1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIEVycm9yIHN0YXR1cyBjb2RlcyBhbHdheXMgb3ZlcnJpZGUgc3VjY2VzcyBzdGF0dXMgY29kZXMsIGJ1dCBpZiBhbGxcbiAgICAgIC8vIGxvYWRlcnMgYXJlIHN1Y2Nlc3NmdWwgd2UgdGFrZSB0aGUgZGVlcGVzdCBzdGF0dXMgY29kZS5cbiAgICAgIGlmIChcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCAmJlxuICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmXG4gICAgICAgICFmb3VuZEVycm9yXG4gICAgICApIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IHJlc3VsdC5zdGF0dXNDb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB3ZSBkaWRuJ3QgY29uc3VtZSB0aGUgcGVuZGluZyBhY3Rpb24gZXJyb3IgKGkuZS4sIGFsbCBsb2FkZXJzXG4gIC8vIHJlc29sdmVkKSwgdGhlbiBjb25zdW1lIGl0IGhlcmUuICBBbHNvIGNsZWFyIG91dCBhbnkgbG9hZGVyRGF0YSBmb3IgdGhlXG4gIC8vIHRocm93aW5nIHJvdXRlXG4gIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICBlcnJvcnMgPSBwZW5kaW5nRXJyb3I7XG4gICAgbG9hZGVyRGF0YVtPYmplY3Qua2V5cyhwZW5kaW5nRXJyb3IpWzBdXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnMsXG4gICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSB8fCAyMDAsXG4gICAgbG9hZGVySGVhZGVycyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0xvYWRlckRhdGEoXG4gIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgcGVuZGluZ0Vycm9yOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQsXG4gIHJldmFsaWRhdGluZ0ZldGNoZXJzOiBSZXZhbGlkYXRpbmdGZXRjaGVyW10sXG4gIGZldGNoZXJSZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIGFjdGl2ZURlZmVycmVkczogTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPlxuKToge1xuICBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIGVycm9ycz86IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xufSB7XG4gIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICBtYXRjaGVzLFxuICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgcmVzdWx0cyxcbiAgICBwZW5kaW5nRXJyb3IsXG4gICAgYWN0aXZlRGVmZXJyZWRzXG4gICk7XG5cbiAgLy8gUHJvY2VzcyByZXN1bHRzIGZyb20gb3VyIHJldmFsaWRhdGluZyBmZXRjaGVyc1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHsga2V5LCBtYXRjaCwgY29udHJvbGxlciB9ID0gcmV2YWxpZGF0aW5nRmV0Y2hlcnNbaW5kZXhdO1xuICAgIGludmFyaWFudChcbiAgICAgIGZldGNoZXJSZXN1bHRzICE9PSB1bmRlZmluZWQgJiYgZmV0Y2hlclJlc3VsdHNbaW5kZXhdICE9PSB1bmRlZmluZWQsXG4gICAgICBcIkRpZCBub3QgZmluZCBjb3JyZXNwb25kaW5nIGZldGNoZXIgcmVzdWx0XCJcbiAgICApO1xuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1tpbmRleF07XG5cbiAgICAvLyBQcm9jZXNzIGZldGNoZXIgbm9uLXJlZGlyZWN0IGVycm9yc1xuICAgIGlmIChjb250cm9sbGVyICYmIGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIGFib3J0ZWQgZmV0Y2hlcnNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2g/LnJvdXRlLmlkKTtcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XG4gICAgICAgIGVycm9ycyA9IHtcbiAgICAgICAgICAuLi5lcnJvcnMsXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCByZWRpcmVjdHMgc2hvdWxkIGdldCBwcm9jZXNzZWQgYWJvdmUsIGJ1dCB3ZVxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcbiAgICAgIC8vIGluIHJlc29sdmVEZWZlcnJlZFJlc3VsdHNcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgbG9hZGVyRGF0YSwgZXJyb3JzIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBuZXdMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgZXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBSb3V0ZURhdGEge1xuICBsZXQgbWVyZ2VkTG9hZGVyRGF0YSA9IHsgLi4ubmV3TG9hZGVyRGF0YSB9O1xuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgaWYgKG5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpZiAobmV3TG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IG5ld0xvYWRlckRhdGFbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8tb3AgLSB0aGlzIGlzIHNvIHdlIGlnbm9yZSBleGlzdGluZyBkYXRhIGlmIHdlIGhhdmUgYSBrZXkgaW4gdGhlXG4gICAgICAgIC8vIGluY29taW5nIG9iamVjdCB3aXRoIGFuIHVuZGVmaW5lZCB2YWx1ZSwgd2hpY2ggaXMgaG93IHdlIHVuc2V0IGEgcHJpb3JcbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpZiB3ZSBlbmNvdW50ZXIgYSBsb2FkZXIgZXJyb3JcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQgJiYgbWF0Y2gucm91dGUubG9hZGVyKSB7XG4gICAgICAvLyBQcmVzZXJ2ZSBleGlzdGluZyBrZXlzIG5vdCBpbmNsdWRlZCBpbiBuZXdMb2FkZXJEYXRhIGFuZCB3aGVyZSBhIGxvYWRlclxuICAgICAgLy8gd2Fzbid0IHJlbW92ZWQgYnkgSE1SXG4gICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IGxvYWRlckRhdGFbaWRdO1xuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgLy8gRG9uJ3Qga2VlcCBhbnkgbG9hZGVyIGRhdGEgYmVsb3cgdGhlIGJvdW5kYXJ5XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5cbi8vIEZpbmQgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnksIGxvb2tpbmcgdXB3YXJkcyBmcm9tIHRoZSBsZWFmIHJvdXRlIChvciB0aGVcbi8vIHJvdXRlIHNwZWNpZmllZCBieSByb3V0ZUlkKSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3IgYm91bmRhcnksXG4vLyBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHJvdXRlSWQ/OiBzdHJpbmdcbik6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gge1xuICBsZXQgZWxpZ2libGVNYXRjaGVzID0gcm91dGVJZFxuICAgID8gbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKVxuICAgIDogWy4uLm1hdGNoZXNdO1xuICByZXR1cm4gKFxuICAgIGVsaWdpYmxlTWF0Y2hlcy5yZXZlcnNlKCkuZmluZCgobSkgPT4gbS5yb3V0ZS5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlKSB8fFxuICAgIG1hdGNoZXNbMF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10pOiB7XG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcbiAgcm91dGU6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0O1xufSB7XG4gIC8vIFByZWZlciBhIHJvb3QgbGF5b3V0IHJvdXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBzaGltIGluIGEgcm91dGUgb2JqZWN0XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5maW5kKChyKSA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xuICAgIGlkOiBgX19zaGltLWVycm9yLXJvdXRlX19gLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlczogW1xuICAgICAge1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgICByb3V0ZSxcbiAgICAgIH0sXG4gICAgXSxcbiAgICByb3V0ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihcbiAgc3RhdHVzOiBudW1iZXIsXG4gIHtcbiAgICBwYXRobmFtZSxcbiAgICByb3V0ZUlkLFxuICAgIG1ldGhvZCxcbiAgICB0eXBlLFxuICB9OiB7XG4gICAgcGF0aG5hbWU/OiBzdHJpbmc7XG4gICAgcm91dGVJZD86IHN0cmluZztcbiAgICBtZXRob2Q/OiBzdHJpbmc7XG4gICAgdHlwZT86IFwiZGVmZXItYWN0aW9uXCIgfCBcImludmFsaWQtYm9keVwiO1xuICB9ID0ge31cbikge1xuICBsZXQgc3RhdHVzVGV4dCA9IFwiVW5rbm93biBTZXJ2ZXIgRXJyb3JcIjtcbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiVW5rbm93biBAcmVtaXgtcnVuL3JvdXRlciBlcnJvclwiO1xuXG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBgWW91IG1hZGUgYSAke21ldGhvZH0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGAgK1xuICAgICAgICBgZGlkIG5vdCBwcm92aWRlIGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgYCArXG4gICAgICAgIGBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRlZmVyLWFjdGlvblwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcImRlZmVyKCkgaXMgbm90IHN1cHBvcnRlZCBpbiBhY3Rpb25zXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludmFsaWQtYm9keVwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIlVuYWJsZSB0byBlbmNvZGUgc3VibWlzc2lvbiBib2R5XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiRm9yYmlkZGVuXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IG1hdGNoIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTm90IEZvdW5kXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGBZb3UgbWFkZSBhICR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBgICtcbiAgICAgICAgYGRpZCBub3QgcHJvdmlkZSBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBgICtcbiAgICAgICAgYHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke21ldGhvZC50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgIHN0YXR1cyB8fCA1MDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSxcbiAgICB0cnVlXG4gICk7XG59XG5cbi8vIEZpbmQgYW55IHJldHVybmVkIHJlZGlyZWN0IGVycm9ycywgc3RhcnRpbmcgZnJvbSB0aGUgbG93ZXN0IG1hdGNoXG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QoXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXVxuKTogeyByZXN1bHQ6IFJlZGlyZWN0UmVzdWx0OyBpZHg6IG51bWJlciB9IHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4geyByZXN1bHQsIGlkeDogaSB9O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoOiBUbykge1xuICBsZXQgcGFyc2VkUGF0aCA9IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHBhdGgpIDogcGF0aDtcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoeyAuLi5wYXJzZWRQYXRoLCBoYXNoOiBcIlwiIH0pO1xufVxuXG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGE6IExvY2F0aW9uLCBiOiBMb2NhdGlvbik6IGJvb2xlYW4ge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UgLT4gL3BhZ2UjaGFzaFxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI290aGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiB0aGUgaGFzaCBpcyByZW1vdmVkIHRoZSBicm93c2VyIHdpbGwgcmUtcGVyZm9ybSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlclxuICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQ6IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgRGVmZXJyZWRSZXN1bHQge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIEVycm9yUmVzdWx0IHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdD86IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgUmVkaXJlY3RSZXN1bHQge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmVycmVkRGF0YSh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGVmZXJyZWREYXRhIHtcbiAgbGV0IGRlZmVycmVkOiBEZWZlcnJlZERhdGEgPSB2YWx1ZTtcbiAgcmV0dXJuIChcbiAgICBkZWZlcnJlZCAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZC5kYXRhID09PSBcIm9iamVjdFwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLnJlc29sdmVEYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuaGVhZGVycyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQ6IGFueSk6IHJlc3VsdCBpcyBSZXNwb25zZSB7XG4gIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICByZXR1cm4gc3RhdHVzID49IDMwMCAmJiBzdGF0dXMgPD0gMzk5ICYmIGxvY2F0aW9uICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iajogYW55KTogb2JqIGlzIFF1ZXJ5Um91dGVSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgb2JqICYmXG4gICAgaXNSZXNwb25zZShvYmoucmVzcG9uc2UpICYmXG4gICAgKG9iai50eXBlID09PSBSZXN1bHRUeXBlLmRhdGEgfHwgb2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRNZXRob2QobWV0aG9kOiBzdHJpbmcpOiBtZXRob2QgaXMgRm9ybU1ldGhvZCB8IFY3X0Zvcm1NZXRob2Qge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkgYXMgRm9ybU1ldGhvZCk7XG59XG5cbmZ1bmN0aW9uIGlzTXV0YXRpb25NZXRob2QoXG4gIG1ldGhvZDogc3RyaW5nXG4pOiBtZXRob2QgaXMgTXV0YXRpb25Gb3JtTWV0aG9kIHwgVjdfTXV0YXRpb25Gb3JtTWV0aG9kIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSBhcyBNdXRhdGlvbkZvcm1NZXRob2QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzVG9Mb2FkOiAoQWdub3N0aWNEYXRhUm91dGVNYXRjaCB8IG51bGwpW10sXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgc2lnbmFsczogKEFib3J0U2lnbmFsIHwgbnVsbClbXSxcbiAgaXNGZXRjaGVyOiBib29sZWFuLFxuICBjdXJyZW50TG9hZGVyRGF0YT86IFJvdXRlRGF0YVxuKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbWF0Y2gsIHRoZW4gd2UgY2FuIGhhdmUgYSBkZWZlcnJlZCByZXN1bHQgdG8gZG9cbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcbiAgICAvLyByZW1vdmVkIGR1cmluZyBITVJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudE1hdGNoID0gY3VycmVudE1hdGNoZXMuZmluZChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaCEucm91dGUuaWRcbiAgICApO1xuICAgIGxldCBpc1JldmFsaWRhdGluZ0xvYWRlciA9XG4gICAgICBjdXJyZW50TWF0Y2ggIT0gbnVsbCAmJlxuICAgICAgIWlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSAmJlxuICAgICAgKGN1cnJlbnRMb2FkZXJEYXRhICYmIGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSkgIT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkgJiYgKGlzRmV0Y2hlciB8fCBpc1JldmFsaWRhdGluZ0xvYWRlcikpIHtcbiAgICAgIC8vIE5vdGU6IHdlIGRvIG5vdCBoYXZlIHRvIHRvdWNoIGFjdGl2ZURlZmVycmVkcyBoZXJlIHNpbmNlIHdlIHJhY2UgdGhlbVxuICAgICAgLy8gYWdhaW5zdCB0aGUgc2lnbmFsIGluIHJlc29sdmVEZWZlcnJlZERhdGEgYW5kIHRoZXknbGwgZ2V0IGFib3J0ZWRcbiAgICAgIC8vIHRoZXJlIGlmIG5lZWRlZFxuICAgICAgbGV0IHNpZ25hbCA9IHNpZ25hbHNbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIFwiRXhwZWN0ZWQgYW4gQWJvcnRTaWduYWwgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVyIGRlZmVycmVkIHJlc3VsdFwiXG4gICAgICApO1xuICAgICAgYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgaXNGZXRjaGVyKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gcmVzdWx0IHx8IHJlc3VsdHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkRGF0YShcbiAgcmVzdWx0OiBEZWZlcnJlZFJlc3VsdCxcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgdW53cmFwID0gZmFsc2Vcbik6IFByb21pc2U8U3VjY2Vzc1Jlc3VsdCB8IEVycm9yUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIGxldCBhYm9ydGVkID0gYXdhaXQgcmVzdWx0LmRlZmVycmVkRGF0YS5yZXNvbHZlRGF0YShzaWduYWwpO1xuICBpZiAoYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh1bndyYXApIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLnVud3JhcHBlZERhdGEsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEhhbmRsZSBhbnkgVHJhY2tlZFByb21pc2UuX2Vycm9yIHZhbHVlcyBlbmNvdW50ZXJlZCB3aGlsZSB1bndyYXBwaW5nXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS5kYXRhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0TWF0Y2goXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbG9jYXRpb246IExvY2F0aW9uIHwgc3RyaW5nXG4pIHtcbiAgbGV0IHNlYXJjaCA9XG4gICAgdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChcbiAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiZcbiAgICBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoIHx8IFwiXCIpXG4gICkge1xuICAgIC8vIFJldHVybiB0aGUgbGVhZiBpbmRleCByb3V0ZSB3aGVuIGluZGV4IGlzIHByZXNlbnRcbiAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIE90aGVyd2lzZSBncmFiIHRoZSBkZWVwZXN0IFwicGF0aCBjb250cmlidXRpbmdcIiBtYXRjaCAoaWdub3JpbmcgaW5kZXggYW5kXG4gIC8vIHBhdGhsZXNzIGxheW91dCByb3V0ZXMpXG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXNbcGF0aE1hdGNoZXMubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihcbiAgbmF2aWdhdGlvbjogTmF2aWdhdGlvblxuKTogU3VibWlzc2lvbiB8IHVuZGVmaW5lZCB7XG4gIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCB0ZXh0LCBmb3JtRGF0YSwganNvbiB9ID1cbiAgICBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb24sXG4gICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMb2FkaW5nTmF2aWdhdGlvbihcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuKTogTmF2aWdhdGlvblN0YXRlc1tcIkxvYWRpbmdcIl0ge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uXG4pOiBOYXZpZ2F0aW9uU3RhdGVzW1wiU3VibWl0dGluZ1wiXSB7XG4gIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiU3VibWl0dGluZ1wiXSA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgbG9jYXRpb24sXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICB9O1xuICByZXR1cm4gbmF2aWdhdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uLFxuICBkYXRhPzogRmV0Y2hlcltcImRhdGFcIl1cbik6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgICAgZGF0YSxcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgZGF0YSxcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKFxuICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uLFxuICBleGlzdGluZ0ZldGNoZXI/OiBGZXRjaGVyXG4pOiBGZXRjaGVyU3RhdGVzW1wiU3VibWl0dGluZ1wiXSB7XG4gIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiU3VibWl0dGluZ1wiXSA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkLFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cblxuZnVuY3Rpb24gZ2V0RG9uZUZldGNoZXIoZGF0YTogRmV0Y2hlcltcImRhdGFcIl0pOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSB7XG4gIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICBkYXRhLFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbi8vI2VuZHJlZ2lvblxuIl0sIm5hbWVzIjpbIkFjdGlvbiIsIlBvcFN0YXRlRXZlbnRUeXBlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIm9wdGlvbnMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsInY1Q29tcGF0IiwiZW50cmllcyIsIm1hcCIsImVudHJ5IiwiaW5kZXgiLCJjcmVhdGVNZW1vcnlMb2NhdGlvbiIsInN0YXRlIiwidW5kZWZpbmVkIiwiY2xhbXBJbmRleCIsImxlbmd0aCIsImFjdGlvbiIsIlBvcCIsImxpc3RlbmVyIiwibiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJ0byIsImtleSIsImxvY2F0aW9uIiwiY3JlYXRlTG9jYXRpb24iLCJwYXRobmFtZSIsIndhcm5pbmciLCJjaGFyQXQiLCJKU09OIiwic3RyaW5naWZ5IiwiY3JlYXRlSHJlZiIsImNyZWF0ZVBhdGgiLCJoaXN0b3J5IiwiY3JlYXRlVVJMIiwiVVJMIiwiZW5jb2RlTG9jYXRpb24iLCJwYXRoIiwicGFyc2VQYXRoIiwic2VhcmNoIiwiaGFzaCIsInB1c2giLCJQdXNoIiwibmV4dExvY2F0aW9uIiwic3BsaWNlIiwiZGVsdGEiLCJyZXBsYWNlIiwiUmVwbGFjZSIsImdvIiwibmV4dEluZGV4IiwibGlzdGVuIiwiZm4iLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImNyZWF0ZUJyb3dzZXJMb2NhdGlvbiIsIndpbmRvdyIsImdsb2JhbEhpc3RvcnkiLCJ1c3IiLCJjcmVhdGVCcm93c2VySHJlZiIsImdldFVybEJhc2VkSGlzdG9yeSIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiY3JlYXRlSGFzaExvY2F0aW9uIiwic3Vic3RyIiwic3RhcnRzV2l0aCIsImNyZWF0ZUhhc2hIcmVmIiwiYmFzZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJ1cmwiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJ2YWxpZGF0ZUhhc2hMb2NhdGlvbiIsImludmFyaWFudCIsInZhbHVlIiwibWVzc2FnZSIsIkVycm9yIiwiY29uZCIsImNvbnNvbGUiLCJ3YXJuIiwiZSIsImNyZWF0ZUtleSIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0SGlzdG9yeVN0YXRlIiwiaWR4IiwiY3VycmVudCIsIl9leHRlbmRzIiwiX3JlZiIsInBhcnNlZFBhdGgiLCJzZWFyY2hJbmRleCIsImdldExvY2F0aW9uIiwidmFsaWRhdGVMb2NhdGlvbiIsImRlZmF1bHRWaWV3IiwiZ2V0SW5kZXgiLCJyZXBsYWNlU3RhdGUiLCJoYW5kbGVQb3AiLCJoaXN0b3J5U3RhdGUiLCJwdXNoU3RhdGUiLCJlcnJvciIsIkRPTUV4Y2VwdGlvbiIsIm5hbWUiLCJhc3NpZ24iLCJvcmlnaW4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlc3VsdFR5cGUiLCJpbW11dGFibGVSb3V0ZUtleXMiLCJTZXQiLCJpc0luZGV4Um91dGUiLCJyb3V0ZSIsImNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJyb3V0ZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJwYXJlbnRQYXRoIiwibWFuaWZlc3QiLCJ0cmVlUGF0aCIsImlkIiwiam9pbiIsImNoaWxkcmVuIiwiaW5kZXhSb3V0ZSIsInBhdGhPckxheW91dFJvdXRlIiwibWF0Y2hSb3V0ZXMiLCJsb2NhdGlvbkFyZyIsImJhc2VuYW1lIiwic3RyaXBCYXNlbmFtZSIsImJyYW5jaGVzIiwiZmxhdHRlblJvdXRlcyIsInJhbmtSb3V0ZUJyYW5jaGVzIiwibWF0Y2hlcyIsImkiLCJtYXRjaFJvdXRlQnJhbmNoIiwic2FmZWx5RGVjb2RlVVJJIiwiY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2giLCJtYXRjaCIsImxvYWRlckRhdGEiLCJwYXJhbXMiLCJkYXRhIiwiaGFuZGxlIiwicGFyZW50c01ldGEiLCJmbGF0dGVuUm91dGUiLCJyZWxhdGl2ZVBhdGgiLCJtZXRhIiwiY2FzZVNlbnNpdGl2ZSIsImNoaWxkcmVuSW5kZXgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiX3JvdXRlJHBhdGgiLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2hQYXRoIiwiT2JqZWN0IiwicGF0aG5hbWVCYXNlIiwibm9ybWFsaXplUGF0aG5hbWUiLCJnZW5lcmF0ZVBhdGgiLCJvcmlnaW5hbFBhdGgiLCJwcmVmaXgiLCJwIiwiU3RyaW5nIiwiYXJyYXkiLCJpc0xhc3RTZWdtZW50Iiwic3RhciIsImtleU1hdGNoIiwib3B0aW9uYWwiLCJwYXJhbSIsInBhdHRlcm4iLCJtYXRjaGVyIiwicGFyYW1OYW1lcyIsImNvbXBpbGVQYXRoIiwiY2FwdHVyZUdyb3VwcyIsIm1lbW8iLCJwYXJhbU5hbWUiLCJzcGxhdFZhbHVlIiwic2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50IiwicmVnZXhwU291cmNlIiwiXyIsIlJlZ0V4cCIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsInRvTG93ZXJDYXNlIiwic3RhcnRJbmRleCIsIm5leHRDaGFyIiwicmVzb2x2ZVBhdGgiLCJmcm9tUGF0aG5hbWUiLCJ0b1BhdGhuYW1lIiwicmVzb2x2ZVBhdGhuYW1lIiwibm9ybWFsaXplU2VhcmNoIiwibm9ybWFsaXplSGFzaCIsInJlbGF0aXZlU2VnbWVudHMiLCJwb3AiLCJnZXRJbnZhbGlkUGF0aEVycm9yIiwiY2hhciIsImZpZWxkIiwiZGVzdCIsImdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwicmVzb2x2ZVRvIiwidG9BcmciLCJyb3V0ZVBhdGhuYW1lcyIsImxvY2F0aW9uUGF0aG5hbWUiLCJpc1BhdGhSZWxhdGl2ZSIsImlzRW1wdHlQYXRoIiwiZnJvbSIsInJvdXRlUGF0aG5hbWVJbmRleCIsInRvU2VnbWVudHMiLCJzaGlmdCIsImhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCIsImhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoIiwiZ2V0VG9QYXRobmFtZSIsInBhdGhzIiwianNvbiIsImluaXQiLCJyZXNwb25zZUluaXQiLCJzdGF0dXMiLCJoZWFkZXJzIiwiSGVhZGVycyIsImhhcyIsInNldCIsIlJlc3BvbnNlIiwiQWJvcnRlZERlZmVycmVkRXJyb3IiLCJEZWZlcnJlZERhdGEiLCJjb25zdHJ1Y3RvciIsInBlbmRpbmdLZXlzU2V0Iiwic3Vic2NyaWJlcnMiLCJkZWZlcnJlZEtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJyZWplY3QiLCJhYm9ydFByb21pc2UiLCJQcm9taXNlIiwiciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJvbkFib3J0IiwidW5saXN0ZW5BYm9ydFNpZ25hbCIsInNpZ25hbCIsImFjYyIsInRyYWNrUHJvbWlzZSIsImRvbmUiLCJhZGQiLCJwcm9taXNlIiwicmFjZSIsInRoZW4iLCJvblNldHRsZSIsImNhdGNoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhYm9ydGVkIiwiZGVsZXRlIiwidW5kZWZpbmVkRXJyb3IiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsInYiLCJrIiwicmVzb2x2ZURhdGEiLCJyZXNvbHZlIiwic2l6ZSIsInVud3JhcHBlZERhdGEiLCJfcmVmMiIsInVud3JhcFRyYWNrZWRQcm9taXNlIiwicGVuZGluZ0tleXMiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVzcG9uc2UiLCJFcnJvclJlc3BvbnNlSW1wbCIsInN0YXR1c1RleHQiLCJpbnRlcm5hbCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwidmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIiLCJ2YWxpZE11dGF0aW9uTWV0aG9kcyIsInZhbGlkUmVxdWVzdE1ldGhvZHNBcnIiLCJ2YWxpZFJlcXVlc3RNZXRob2RzIiwicmVkaXJlY3RTdGF0dXNDb2RlcyIsInJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyIsIklETEVfTkFWSUdBVElPTiIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsInRleHQiLCJJRExFX0ZFVENIRVIiLCJJRExFX0JMT0NLRVIiLCJwcm9jZWVkIiwicmVzZXQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzIiwiaGFzRXJyb3JCb3VuZGFyeSIsIkJvb2xlYW4iLCJjcmVhdGVSb3V0ZXIiLCJyb3V0ZXJXaW5kb3ciLCJpc0Jyb3dzZXIiLCJjcmVhdGVFbGVtZW50IiwiaXNTZXJ2ZXIiLCJkZXRlY3RFcnJvckJvdW5kYXJ5IiwiZGF0YVJvdXRlcyIsImluRmxpZ2h0RGF0YVJvdXRlcyIsImZ1dHVyZSIsInY3X25vcm1hbGl6ZUZvcm1NZXRob2QiLCJ2N19wcmVwZW5kQmFzZW5hbWUiLCJ1bmxpc3Rlbkhpc3RvcnkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsImdldFNjcm9sbFJlc3RvcmF0aW9uS2V5IiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJpbml0aWFsU2Nyb2xsUmVzdG9yZWQiLCJoeWRyYXRpb25EYXRhIiwiaW5pdGlhbE1hdGNoZXMiLCJpbml0aWFsRXJyb3JzIiwiZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvciIsImdldFNob3J0Q2lyY3VpdE1hdGNoZXMiLCJpbml0aWFsaXplZCIsIm0iLCJsYXp5IiwibG9hZGVyIiwicm91dGVyIiwiaGlzdG9yeUFjdGlvbiIsIm5hdmlnYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJhY3Rpb25EYXRhIiwiZXJyb3JzIiwiZmV0Y2hlcnMiLCJNYXAiLCJibG9ja2VycyIsInBlbmRpbmdBY3Rpb24iLCJwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0IiwicGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIiwiaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwiaXNSZXZhbGlkYXRpb25SZXF1aXJlZCIsImNhbmNlbGxlZERlZmVycmVkUm91dGVzIiwiY2FuY2VsbGVkRmV0Y2hlckxvYWRzIiwiZmV0Y2hDb250cm9sbGVycyIsImluY3JlbWVudGluZ0xvYWRJZCIsInBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkIiwiZmV0Y2hSZWxvYWRJZHMiLCJmZXRjaFJlZGlyZWN0SWRzIiwiZmV0Y2hMb2FkTWF0Y2hlcyIsImFjdGl2ZURlZmVycmVkcyIsImJsb2NrZXJGdW5jdGlvbnMiLCJpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSIsImluaXRpYWxpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwidXBkYXRlQmxvY2tlciIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwiZGlzcG9zZSIsImNsZWFyIiwiZGVsZXRlRmV0Y2hlciIsImRlbGV0ZUJsb2NrZXIiLCJuZXdTdGF0ZSIsImNvbXBsZXRlTmF2aWdhdGlvbiIsIl9sb2NhdGlvbiRzdGF0ZSIsIl9sb2NhdGlvbiRzdGF0ZTIiLCJpc0FjdGlvblJlbG9hZCIsImlzTXV0YXRpb25NZXRob2QiLCJfaXNSZWRpcmVjdCIsImtleXMiLCJtZXJnZUxvYWRlckRhdGEiLCJnZXRTYXZlZFNjcm9sbFBvc2l0aW9uIiwibmF2aWdhdGUiLCJvcHRzIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVUbyIsImZyb21Sb3V0ZUlkIiwicmVsYXRpdmUiLCJzdWJtaXNzaW9uIiwibm9ybWFsaXplTmF2aWdhdGVPcHRpb25zIiwidXNlclJlcGxhY2UiLCJwZW5kaW5nRXJyb3IiLCJyZXZhbGlkYXRlIiwiaW50ZXJydXB0QWN0aXZlTG9hZHMiLCJzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJvdmVycmlkZU5hdmlnYXRpb24iLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJyb3V0ZXNUb1VzZSIsImxvYWRpbmdOYXZpZ2F0aW9uIiwibm90Rm91bmRNYXRjaGVzIiwiY2FuY2VsQWN0aXZlRGVmZXJyZWRzIiwiaXNIYXNoQ2hhbmdlT25seSIsInJlcXVlc3QiLCJjcmVhdGVDbGllbnRTaWRlUmVxdWVzdCIsInBlbmRpbmdBY3Rpb25EYXRhIiwiZmluZE5lYXJlc3RCb3VuZGFyeSIsImFjdGlvbk91dHB1dCIsImhhbmRsZUFjdGlvbiIsInNob3J0Q2lyY3VpdGVkIiwicGVuZGluZ0FjdGlvbkVycm9yIiwiZ2V0TG9hZGluZ05hdmlnYXRpb24iLCJSZXF1ZXN0IiwiaGFuZGxlTG9hZGVycyIsImZldGNoZXJTdWJtaXNzaW9uIiwiZ2V0U3VibWl0dGluZ05hdmlnYXRpb24iLCJhY3Rpb25NYXRjaCIsImdldFRhcmdldE1hdGNoIiwidHlwZSIsIm1ldGhvZCIsInJvdXRlSWQiLCJjYWxsTG9hZGVyT3JBY3Rpb24iLCJpc1JlZGlyZWN0UmVzdWx0Iiwic3RhcnRSZWRpcmVjdE5hdmlnYXRpb24iLCJpc0Vycm9yUmVzdWx0IiwiYm91bmRhcnlNYXRjaCIsImlzRGVmZXJyZWRSZXN1bHQiLCJhY3RpdmVTdWJtaXNzaW9uIiwiZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uIiwibWF0Y2hlc1RvTG9hZCIsInJldmFsaWRhdGluZ0ZldGNoZXJzIiwiZ2V0TWF0Y2hlc1RvTG9hZCIsInVwZGF0ZWRGZXRjaGVycyIsIm1hcmtGZXRjaFJlZGlyZWN0c0RvbmUiLCJyZiIsImZldGNoZXIiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwiZ2V0TG9hZGluZ0ZldGNoZXIiLCJhYm9ydEZldGNoZXIiLCJhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMiLCJmIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsImZldGNoZXJLZXkiLCJwcm9jZXNzTG9hZGVyRGF0YSIsImRlZmVycmVkRGF0YSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwic2hvdWxkVXBkYXRlRmV0Y2hlcnMiLCJnZXRGZXRjaGVyIiwiZmV0Y2giLCJzZXRGZXRjaGVyRXJyb3IiLCJoYW5kbGVGZXRjaGVyQWN0aW9uIiwiaGFuZGxlRmV0Y2hlckxvYWRlciIsInJlcXVlc3RNYXRjaGVzIiwiZXhpc3RpbmdGZXRjaGVyIiwiZ2V0U3VibWl0dGluZ0ZldGNoZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJmZXRjaFJlcXVlc3QiLCJvcmlnaW5hdGluZ0xvYWRJZCIsImFjdGlvblJlc3VsdCIsImRvbmVGZXRjaGVyIiwiZ2V0RG9uZUZldGNoZXIiLCJsb2FkaW5nRmV0Y2hlciIsInJldmFsaWRhdGlvblJlcXVlc3QiLCJsb2FkSWQiLCJsb2FkRmV0Y2hlciIsInN0YWxlS2V5IiwicmVzb2x2ZURlZmVycmVkRGF0YSIsIl90ZW1wIiwicmVkaXJlY3RMb2NhdGlvbiIsImlzRG9jdW1lbnRSZWxvYWQiLCJyZWxvYWREb2N1bWVudCIsInJlZGlyZWN0SGlzdG9yeUFjdGlvbiIsImN1cnJlbnRNYXRjaGVzIiwiZmV0Y2hlcnNUb0xvYWQiLCJhbGwiLCJyZXNvbHZlRGVmZXJyZWRSZXN1bHRzIiwibWFya0ZldGNoZXJzRG9uZSIsImRvbmVLZXlzIiwibGFuZGVkSWQiLCJ5ZWV0ZWRLZXlzIiwiZ2V0QmxvY2tlciIsImJsb2NrZXIiLCJuZXdCbG9ja2VyIiwiYmxvY2tlckZ1bmN0aW9uIiwicHJlZGljYXRlIiwiY2FuY2VsbGVkUm91dGVJZHMiLCJkZmQiLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uIiwiZ2V0S2V5IiwieSIsImdldFNjcm9sbEtleSIsIl9pbnRlcm5hbFNldFJvdXRlcyIsIm5ld1JvdXRlcyIsIl9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMiLCJfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHMiLCJVTlNBRkVfREVGRVJSRURfU1lNQk9MIiwiU3ltYm9sIiwiY3JlYXRlU3RhdGljSGFuZGxlciIsInF1ZXJ5IiwiX3RlbXAyIiwicmVxdWVzdENvbnRleHQiLCJpc1ZhbGlkTWV0aG9kIiwibWV0aG9kTm90QWxsb3dlZE1hdGNoZXMiLCJzdGF0dXNDb2RlIiwibG9hZGVySGVhZGVycyIsImFjdGlvbkhlYWRlcnMiLCJxdWVyeUltcGwiLCJpc1Jlc3BvbnNlIiwicXVlcnlSb3V0ZSIsIl90ZW1wMyIsImZpbmQiLCJ2YWx1ZXMiLCJfcmVzdWx0JGFjdGl2ZURlZmVycmUiLCJyb3V0ZU1hdGNoIiwic3VibWl0IiwibG9hZFJvdXRlRGF0YSIsImlzUXVlcnlSb3V0ZVJlc3BvbnNlIiwiaXNSZWRpcmVjdFJlc3BvbnNlIiwiaXNSb3V0ZVJlcXVlc3QiLCJpc1N0YXRpY1JlcXVlc3QiLCJMb2NhdGlvbiIsImNvbnRleHQiLCJsb2FkZXJSZXF1ZXN0IiwiZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkiLCJwcm9jZXNzUm91dGVMb2FkZXJEYXRhIiwiZXhlY3V0ZWRMb2FkZXJzIiwiZnJvbUVudHJpZXMiLCJnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yIiwibmV3Q29udGV4dCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaXNTdWJtaXNzaW9uTmF2aWdhdGlvbiIsImJvZHkiLCJwcmVwZW5kQmFzZW5hbWUiLCJjb250ZXh0dWFsTWF0Y2hlcyIsImFjdGl2ZVJvdXRlTWF0Y2giLCJoYXNOYWtlZEluZGV4UXVlcnkiLCJub3JtYWxpemVGb3JtTWV0aG9kIiwiaXNGZXRjaGVyIiwiZ2V0SW52YWxpZEJvZHlFcnJvciIsInJhd0Zvcm1NZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInN0cmlwSGFzaEZyb21QYXRoIiwiRm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJfcmVmMyIsInBhcnNlIiwic2VhcmNoUGFyYW1zIiwiY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMiLCJjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YSIsImFwcGVuZCIsImJvdW5kYXJ5SWQiLCJib3VuZGFyeU1hdGNoZXMiLCJmaW5kSW5kZXgiLCJjdXJyZW50VXJsIiwibmV4dFVybCIsIm5hdmlnYXRpb25NYXRjaGVzIiwiaXNOZXdMb2FkZXIiLCJjdXJyZW50Um91dGVNYXRjaCIsIm5leHRSb3V0ZU1hdGNoIiwic2hvdWxkUmV2YWxpZGF0ZUxvYWRlciIsImN1cnJlbnRQYXJhbXMiLCJuZXh0UGFyYW1zIiwiZGVmYXVsdFNob3VsZFJldmFsaWRhdGUiLCJpc05ld1JvdXRlSW5zdGFuY2UiLCJmZXRjaGVyTWF0Y2hlcyIsImZldGNoZXJNYXRjaCIsInNob3VsZFJldmFsaWRhdGUiLCJjdXJyZW50TG9hZGVyRGF0YSIsImN1cnJlbnRNYXRjaCIsImlzTmV3IiwiaXNNaXNzaW5nRGF0YSIsImN1cnJlbnRQYXRoIiwibG9hZGVyTWF0Y2giLCJhcmciLCJyb3V0ZUNob2ljZSIsImxvYWRMYXp5Um91dGVNb2R1bGUiLCJsYXp5Um91dGUiLCJyb3V0ZVRvVXBkYXRlIiwicm91dGVVcGRhdGVzIiwibGF6eVJvdXRlUHJvcGVydHkiLCJzdGF0aWNSb3V0ZVZhbHVlIiwiaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkIiwicmVzdWx0VHlwZSIsIm9uUmVqZWN0IiwicnVuSGFuZGxlciIsImhhbmRsZXIiLCJoYW5kbGVyRXJyb3IiLCJwcm90b2NvbCIsImlzU2FtZUJhc2VuYW1lIiwicXVlcnlSb3V0ZVJlc3BvbnNlIiwiY29udGVudFR5cGUiLCJpc0RlZmVycmVkRGF0YSIsIl9yZXN1bHQkaW5pdCIsIl9yZXN1bHQkaW5pdDIiLCJkZWZlcnJlZCIsImZvdW5kRXJyb3IiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VkTG9hZGVyRGF0YSIsImhhc093blByb3BlcnR5IiwiZWxpZ2libGVNYXRjaGVzIiwicmV2ZXJzZSIsIl90ZW1wNCIsImVycm9yTWVzc2FnZSIsIm9iaiIsInNpZ25hbHMiLCJpc1JldmFsaWRhdGluZ0xvYWRlciIsInVud3JhcCIsImdldEFsbCIsInBhdGhNYXRjaGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1300\n')},6598:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  P1: () => (/* binding */ createSelector)\n});\n\n// UNUSED EXPORTS: createSelectorCreator, createStructuredSelector, defaultEqualityCheck, defaultMemoize\n\n;// CONCATENATED MODULE: ./node_modules/reselect/es/defaultMemoize.js\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = 'NOT_FOUND';\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    } // No entry found in cache, return sentinel\n\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n    var length = prev.length;\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nfunction defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n    equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n    _providedOptions$maxS = providedOptions.maxSize,\n    maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n    resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n        if (matchingEntry) {\n          value = matchingEntry.value;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n  return memoized;\n}\n;// CONCATENATED MODULE: ./node_modules/reselect/es/index.js\n\n\nfunction getDependencies(funcs) {\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n  if (!dependencies.every(function (dep) {\n    return typeof dep === 'function';\n  })) {\n    var dependencyTypes = dependencies.map(function (dep) {\n      return typeof dep === 'function' ? \"function \" + (dep.name || 'unnamed') + \"()\" : typeof dep;\n    }).join(', ');\n    throw new Error(\"createSelector expects all input-selectors to be functions, but received the following types: [\" + dependencyTypes + \"]\");\n  }\n  return dependencies;\n}\nfunction createSelectorCreator(memoize) {\n  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    memoizeOptionsFromArgs[_key - 1] = arguments[_key];\n  }\n  var createSelector = function createSelector() {\n    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      funcs[_key2] = arguments[_key2];\n    }\n    var _recomputations = 0;\n    var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.\n    // So, start by declaring the default value here.\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n\n    var directlyPassedOptions = {\n      memoizeOptions: undefined\n    }; // Normally, the result func or \"output selector\" is the last arg\n\n    var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object\n\n    if (typeof resultFunc === 'object') {\n      directlyPassedOptions = resultFunc; // and pop the real result func off\n\n      resultFunc = funcs.pop();\n    }\n    if (typeof resultFunc !== 'function') {\n      throw new Error(\"createSelector expects an output function after the inputs, but received: [\" + typeof resultFunc + \"]\");\n    } // Determine which set of options we're using. Prefer options passed directly,\n    // but fall back to options given to createSelectorCreator.\n\n    var _directlyPassedOption = directlyPassedOptions,\n      _directlyPassedOption2 = _directlyPassedOption.memoizeOptions,\n      memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n    // is an array. In most libs I've looked at, it's an equality function or options object.\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n    // we wrap it in an array so we can apply it.\n\n    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];\n    var dependencies = getDependencies(funcs);\n    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {\n      _recomputations++; // apply arguments instead of spreading for performance.\n\n      return resultFunc.apply(null, arguments);\n    }].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n\n    var selector = memoize(function dependenciesChecker() {\n      var params = [];\n      var length = dependencies.length;\n      for (var i = 0; i < length; i++) {\n        // apply arguments instead of spreading and mutate a local list of params for performance.\n        // @ts-ignore\n        params.push(dependencies[i].apply(null, arguments));\n      } // apply arguments instead of spreading for performance.\n\n      _lastResult = memoizedResultFunc.apply(null, params);\n      return _lastResult;\n    });\n    Object.assign(selector, {\n      resultFunc: resultFunc,\n      memoizedResultFunc: memoizedResultFunc,\n      dependencies: dependencies,\n      lastResult: function lastResult() {\n        return _lastResult;\n      },\n      recomputations: function recomputations() {\n        return _recomputations;\n      },\n      resetRecomputations: function resetRecomputations() {\n        return _recomputations = 0;\n      }\n    });\n    return selector;\n  }; // @ts-ignore\n\n  return createSelector;\n}\nvar createSelector = /* #__PURE__ */createSelectorCreator(defaultMemoize);\n// Manual definition of state and output arguments\nvar createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {\n  if (selectorCreator === void 0) {\n    selectorCreator = createSelector;\n  }\n  if (typeof selectors !== 'object') {\n    throw new Error('createStructuredSelector expects first argument to be an object ' + (\"where each property is a selector, instead received a \" + typeof selectors));\n  }\n  var objectKeys = Object.keys(selectors);\n  var resultSelector = selectorCreator(\n  // @ts-ignore\n  objectKeys.map(function (key) {\n    return selectors[key];\n  }), function () {\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n    return values.reduce(function (composition, value, index) {\n      composition[objectKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n  return resultSelector;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEdBQUd6RixLQUFLO01BQ3RDLE9BQU93RixXQUFXO0lBQ3BCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNSLENBQUMsQ0FBQztFQUNGLE9BQU9MLGNBQWM7QUFDdkIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2VzL2RlZmF1bHRNZW1vaXplLmpzPzEyYzgiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvaW5kZXguanM/MWI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWNoZSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBFcmlrIFJhc211c3NlbidzIGBscnUtbWVtb2l6ZWA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXJpa3Jhcy9scnUtbWVtb2l6ZVxudmFyIE5PVF9GT1VORCA9ICdOT1RfRk9VTkQnO1xuXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25DYWNoZShlcXVhbHMpIHtcbiAgdmFyIGVudHJ5O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgZW50cnkgPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRFbnRyaWVzOiBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJ5ID8gW2VudHJ5XSA6IFtdO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpO1xuICAgIH0pOyAvLyBXZSBmb3VuZCBhIGNhY2hlZCBlbnRyeVxuXG4gICAgaWYgKGNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XTsgLy8gQ2FjaGVkIGVudHJ5IG5vdCBhdCB0b3Agb2YgY2FjaGUsIG1vdmUgaXQgdG8gdGhlIHRvcFxuXG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9IC8vIE5vIGVudHJ5IGZvdW5kIGluIGNhY2hlLCByZXR1cm4gc2VudGluZWxcblxuXG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGdldChrZXkpID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIC8vIFRPRE8gSXMgdW5zaGlmdCBzbG93P1xuICAgICAgZW50cmllcy51bnNoaWZ0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW50cmllcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGdldCxcbiAgICBwdXQ6IHB1dCxcbiAgICBnZXRFbnRyaWVzOiBnZXRFbnRyaWVzLFxuICAgIGNsZWFyOiBjbGVhclxuICB9O1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRFcXVhbGl0eUNoZWNrID0gZnVuY3Rpb24gZGVmYXVsdEVxdWFsaXR5Q2hlY2soYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGxlbmd0aCA9IHByZXYubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbi8vIGRlZmF1bHRNZW1vaXplIG5vdyBzdXBwb3J0cyBhIGNvbmZpZ3VyYWJsZSBjYWNoZSBzaXplIHdpdGggTFJVIGJlaGF2aW9yLFxuLy8gYW5kIG9wdGlvbmFsIGNvbXBhcmlzb24gb2YgdGhlIHJlc3VsdCB2YWx1ZSB3aXRoIGV4aXN0aW5nIHZhbHVlc1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZW1vaXplKGZ1bmMsIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMpIHtcbiAgdmFyIHByb3ZpZGVkT3B0aW9ucyA9IHR5cGVvZiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zID09PSAnb2JqZWN0JyA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7XG4gICAgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9uc1xuICB9O1xuICB2YXIgX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID0gcHJvdmlkZWRPcHRpb25zLmVxdWFsaXR5Q2hlY2ssXG4gICAgICBlcXVhbGl0eUNoZWNrID0gX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID09PSB2b2lkIDAgPyBkZWZhdWx0RXF1YWxpdHlDaGVjayA6IF9wcm92aWRlZE9wdGlvbnMkZXF1YSxcbiAgICAgIF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9IHByb3ZpZGVkT3B0aW9ucy5tYXhTaXplLFxuICAgICAgbWF4U2l6ZSA9IF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9PT0gdm9pZCAwID8gMSA6IF9wcm92aWRlZE9wdGlvbnMkbWF4UyxcbiAgICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2sgPSBwcm92aWRlZE9wdGlvbnMucmVzdWx0RXF1YWxpdHlDaGVjaztcbiAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjayk7XG4gIHZhciBjYWNoZSA9IG1heFNpemUgPT09IDEgPyBjcmVhdGVTaW5nbGV0b25DYWNoZShjb21wYXJhdG9yKSA6IGNyZWF0ZUxydUNhY2hlKG1heFNpemUsIGNvbXBhcmF0b3IpOyAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBjYWNoZS5nZXRFbnRyaWVzKCk7XG4gICAgICAgIHZhciBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuXG4gIHJldHVybiBtZW1vaXplZDtcbn0iLCJpbXBvcnQgeyBkZWZhdWx0TWVtb2l6ZSwgZGVmYXVsdEVxdWFsaXR5Q2hlY2sgfSBmcm9tICcuL2RlZmF1bHRNZW1vaXplJztcbmV4cG9ydCB7IGRlZmF1bHRNZW1vaXplLCBkZWZhdWx0RXF1YWxpdHlDaGVjayB9O1xuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoZnVuY3MpIHtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoZnVuY3NbMF0pID8gZnVuY3NbMF0gOiBmdW5jcztcblxuICBpZiAoIWRlcGVuZGVuY2llcy5ldmVyeShmdW5jdGlvbiAoZGVwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkZXAgPT09ICdmdW5jdGlvbic7XG4gIH0pKSB7XG4gICAgdmFyIGRlcGVuZGVuY3lUeXBlcyA9IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkZXAgPT09ICdmdW5jdGlvbicgPyBcImZ1bmN0aW9uIFwiICsgKGRlcC5uYW1lIHx8ICd1bm5hbWVkJykgKyBcIigpXCIgOiB0eXBlb2YgZGVwO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbGwgaW5wdXQtc2VsZWN0b3JzIHRvIGJlIGZ1bmN0aW9ucywgYnV0IHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IFtcIiArIGRlcGVuZGVuY3lUeXBlcyArIFwiXVwiKTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3IobWVtb2l6ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVtb2l6ZU9wdGlvbnNGcm9tQXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWVtb2l6ZU9wdGlvbnNGcm9tQXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY3JlYXRlU2VsZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBmdW5jc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBfcmVjb21wdXRhdGlvbnMgPSAwO1xuXG4gICAgdmFyIF9sYXN0UmVzdWx0OyAvLyBEdWUgdG8gdGhlIGludHJpY2FjaWVzIG9mIHJlc3QgcGFyYW1zLCB3ZSBjYW4ndCBkbyBhbiBvcHRpb25hbCBhcmcgYWZ0ZXIgYC4uLmZ1bmNzYC5cbiAgICAvLyBTbywgc3RhcnQgYnkgZGVjbGFyaW5nIHRoZSBkZWZhdWx0IHZhbHVlIGhlcmUuXG4gICAgLy8gKEFuZCB5ZXMsIHRoZSB3b3JkcyAnbWVtb2l6ZScgYW5kICdvcHRpb25zJyBhcHBlYXIgdG9vIG1hbnkgdGltZXMgaW4gdGhpcyBuZXh0IHNlcXVlbmNlLilcblxuXG4gICAgdmFyIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHtcbiAgICAgIG1lbW9pemVPcHRpb25zOiB1bmRlZmluZWRcbiAgICB9OyAvLyBOb3JtYWxseSwgdGhlIHJlc3VsdCBmdW5jIG9yIFwib3V0cHV0IHNlbGVjdG9yXCIgaXMgdGhlIGxhc3QgYXJnXG5cbiAgICB2YXIgcmVzdWx0RnVuYyA9IGZ1bmNzLnBvcCgpOyAvLyBJZiB0aGUgcmVzdWx0IGZ1bmMgaXMgYWN0dWFsbHkgYW4gX29iamVjdF8sIGFzc3VtZSBpdCdzIG91ciBvcHRpb25zIG9iamVjdFxuXG4gICAgaWYgKHR5cGVvZiByZXN1bHRGdW5jID09PSAnb2JqZWN0Jykge1xuICAgICAgZGlyZWN0bHlQYXNzZWRPcHRpb25zID0gcmVzdWx0RnVuYzsgLy8gYW5kIHBvcCB0aGUgcmVhbCByZXN1bHQgZnVuYyBvZmZcblxuICAgICAgcmVzdWx0RnVuYyA9IGZ1bmNzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbiBvdXRwdXQgZnVuY3Rpb24gYWZ0ZXIgdGhlIGlucHV0cywgYnV0IHJlY2VpdmVkOiBbXCIgKyB0eXBlb2YgcmVzdWx0RnVuYyArIFwiXVwiKTtcbiAgICB9IC8vIERldGVybWluZSB3aGljaCBzZXQgb2Ygb3B0aW9ucyB3ZSdyZSB1c2luZy4gUHJlZmVyIG9wdGlvbnMgcGFzc2VkIGRpcmVjdGx5LFxuICAgIC8vIGJ1dCBmYWxsIGJhY2sgdG8gb3B0aW9ucyBnaXZlbiB0byBjcmVhdGVTZWxlY3RvckNyZWF0b3IuXG5cblxuICAgIHZhciBfZGlyZWN0bHlQYXNzZWRPcHRpb24gPSBkaXJlY3RseVBhc3NlZE9wdGlvbnMsXG4gICAgICAgIF9kaXJlY3RseVBhc3NlZE9wdGlvbjIgPSBfZGlyZWN0bHlQYXNzZWRPcHRpb24ubWVtb2l6ZU9wdGlvbnMsXG4gICAgICAgIG1lbW9pemVPcHRpb25zID0gX2RpcmVjdGx5UGFzc2VkT3B0aW9uMiA9PT0gdm9pZCAwID8gbWVtb2l6ZU9wdGlvbnNGcm9tQXJncyA6IF9kaXJlY3RseVBhc3NlZE9wdGlvbjI7IC8vIFNpbXBsaWZ5aW5nIGFzc3VtcHRpb246IGl0J3MgdW5saWtlbHkgdGhhdCB0aGUgZmlyc3Qgb3B0aW9ucyBhcmcgb2YgdGhlIHByb3ZpZGVkIG1lbW9pemVyXG4gICAgLy8gaXMgYW4gYXJyYXkuIEluIG1vc3QgbGlicyBJJ3ZlIGxvb2tlZCBhdCwgaXQncyBhbiBlcXVhbGl0eSBmdW5jdGlvbiBvciBvcHRpb25zIG9iamVjdC5cbiAgICAvLyBCYXNlZCBvbiB0aGF0LCBpZiBgbWVtb2l6ZU9wdGlvbnNgIF9pc18gYW4gYXJyYXksIHdlIGFzc3VtZSBpdCdzIGEgZnVsbFxuICAgIC8vIHVzZXItcHJvdmlkZWQgYXJyYXkgb2Ygb3B0aW9ucy4gT3RoZXJ3aXNlLCBpdCBtdXN0IGJlIGp1c3QgdGhlIF9maXJzdF8gYXJnLCBhbmQgc29cbiAgICAvLyB3ZSB3cmFwIGl0IGluIGFuIGFycmF5IHNvIHdlIGNhbiBhcHBseSBpdC5cblxuICAgIHZhciBmaW5hbE1lbW9pemVPcHRpb25zID0gQXJyYXkuaXNBcnJheShtZW1vaXplT3B0aW9ucykgPyBtZW1vaXplT3B0aW9ucyA6IFttZW1vaXplT3B0aW9uc107XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhmdW5jcyk7XG4gICAgdmFyIG1lbW9pemVkUmVzdWx0RnVuYyA9IG1lbW9pemUuYXBwbHkodm9pZCAwLCBbZnVuY3Rpb24gcmVjb21wdXRhdGlvbldyYXBwZXIoKSB7XG4gICAgICBfcmVjb21wdXRhdGlvbnMrKzsgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cblxuICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XS5jb25jYXQoZmluYWxNZW1vaXplT3B0aW9ucykpOyAvLyBJZiBhIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBleGFjdCBzYW1lIGFyZ3VtZW50cyB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIG91ciBkZXBlbmRlbmNpZXMgYWdhaW4uXG5cbiAgICB2YXIgc2VsZWN0b3IgPSBtZW1vaXplKGZ1bmN0aW9uIGRlcGVuZGVuY2llc0NoZWNrZXIoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgYW5kIG11dGF0ZSBhIGxvY2FsIGxpc3Qgb2YgcGFyYW1zIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwYXJhbXMucHVzaChkZXBlbmRlbmNpZXNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICB9IC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG5cblxuICAgICAgX2xhc3RSZXN1bHQgPSBtZW1vaXplZFJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgcGFyYW1zKTtcbiAgICAgIHJldHVybiBfbGFzdFJlc3VsdDtcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKHNlbGVjdG9yLCB7XG4gICAgICByZXN1bHRGdW5jOiByZXN1bHRGdW5jLFxuICAgICAgbWVtb2l6ZWRSZXN1bHRGdW5jOiBtZW1vaXplZFJlc3VsdEZ1bmMsXG4gICAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICAgIGxhc3RSZXN1bHQ6IGZ1bmN0aW9uIGxhc3RSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiBfbGFzdFJlc3VsdDtcbiAgICAgIH0sXG4gICAgICByZWNvbXB1dGF0aW9uczogZnVuY3Rpb24gcmVjb21wdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVjb21wdXRhdGlvbnM7XG4gICAgICB9LFxuICAgICAgcmVzZXRSZWNvbXB1dGF0aW9uczogZnVuY3Rpb24gcmVzZXRSZWNvbXB1dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIF9yZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xuICB9OyAvLyBAdHMtaWdub3JlXG5cblxuICByZXR1cm4gY3JlYXRlU2VsZWN0b3I7XG59XG5leHBvcnQgdmFyIGNyZWF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY3JlYXRlU2VsZWN0b3JDcmVhdG9yKGRlZmF1bHRNZW1vaXplKTtcbi8vIE1hbnVhbCBkZWZpbml0aW9uIG9mIHN0YXRlIGFuZCBvdXRwdXQgYXJndW1lbnRzXG5leHBvcnQgdmFyIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcihzZWxlY3RvcnMsIHNlbGVjdG9yQ3JlYXRvcikge1xuICBpZiAoc2VsZWN0b3JDcmVhdG9yID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RvckNyZWF0b3IgPSBjcmVhdGVTZWxlY3RvcjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGV4cGVjdHMgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0ICcgKyAoXCJ3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSBcIiArIHR5cGVvZiBzZWxlY3RvcnMpKTtcbiAgfVxuXG4gIHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMoc2VsZWN0b3JzKTtcbiAgdmFyIHJlc3VsdFNlbGVjdG9yID0gc2VsZWN0b3JDcmVhdG9yKCAvLyBAdHMtaWdub3JlXG4gIG9iamVjdEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc2VsZWN0b3JzW2tleV07XG4gIH0pLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIHZhbHVlc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSB7XG4gICAgICBjb21wb3NpdGlvbltvYmplY3RLZXlzW2luZGV4XV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICB9LCB7fSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0U2VsZWN0b3I7XG59OyJdLCJuYW1lcyI6WyJOT1RfRk9VTkQiLCJjcmVhdGVTaW5nbGV0b25DYWNoZSIsImVxdWFscyIsImVudHJ5IiwiZ2V0Iiwia2V5IiwidmFsdWUiLCJwdXQiLCJnZXRFbnRyaWVzIiwiY2xlYXIiLCJ1bmRlZmluZWQiLCJjcmVhdGVMcnVDYWNoZSIsIm1heFNpemUiLCJlbnRyaWVzIiwiY2FjaGVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInVuc2hpZnQiLCJsZW5ndGgiLCJwb3AiLCJkZWZhdWx0RXF1YWxpdHlDaGVjayIsImEiLCJiIiwiY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yIiwiZXF1YWxpdHlDaGVjayIsImFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsIiwicHJldiIsIm5leHQiLCJpIiwiZGVmYXVsdE1lbW9pemUiLCJmdW5jIiwiZXF1YWxpdHlDaGVja09yT3B0aW9ucyIsInByb3ZpZGVkT3B0aW9ucyIsIl9wcm92aWRlZE9wdGlvbnMkZXF1YSIsIl9wcm92aWRlZE9wdGlvbnMkbWF4UyIsInJlc3VsdEVxdWFsaXR5Q2hlY2siLCJjb21wYXJhdG9yIiwiY2FjaGUiLCJtZW1vaXplZCIsImFyZ3VtZW50cyIsImFwcGx5IiwibWF0Y2hpbmdFbnRyeSIsImZpbmQiLCJjbGVhckNhY2hlIiwiZ2V0RGVwZW5kZW5jaWVzIiwiZnVuY3MiLCJkZXBlbmRlbmNpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsImRlcCIsImRlcGVuZGVuY3lUeXBlcyIsIm1hcCIsIm5hbWUiLCJqb2luIiwiRXJyb3IiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJtZW1vaXplIiwiX2xlbiIsIm1lbW9pemVPcHRpb25zRnJvbUFyZ3MiLCJfa2V5IiwiY3JlYXRlU2VsZWN0b3IiLCJfbGVuMiIsIl9rZXkyIiwiX3JlY29tcHV0YXRpb25zIiwiX2xhc3RSZXN1bHQiLCJkaXJlY3RseVBhc3NlZE9wdGlvbnMiLCJtZW1vaXplT3B0aW9ucyIsInJlc3VsdEZ1bmMiLCJfZGlyZWN0bHlQYXNzZWRPcHRpb24iLCJfZGlyZWN0bHlQYXNzZWRPcHRpb24yIiwiZmluYWxNZW1vaXplT3B0aW9ucyIsIm1lbW9pemVkUmVzdWx0RnVuYyIsInJlY29tcHV0YXRpb25XcmFwcGVyIiwiY29uY2F0Iiwic2VsZWN0b3IiLCJkZXBlbmRlbmNpZXNDaGVja2VyIiwicGFyYW1zIiwicHVzaCIsIk9iamVjdCIsImFzc2lnbiIsImxhc3RSZXN1bHQiLCJyZWNvbXB1dGF0aW9ucyIsInJlc2V0UmVjb21wdXRhdGlvbnMiLCJjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IiLCJzZWxlY3RvcnMiLCJzZWxlY3RvckNyZWF0b3IiLCJvYmplY3RLZXlzIiwia2V5cyIsInJlc3VsdFNlbGVjdG9yIiwiX2xlbjMiLCJ2YWx1ZXMiLCJfa2V5MyIsInJlZHVjZSIsImNvbXBvc2l0aW9uIiwiaW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6598\n")}}]);