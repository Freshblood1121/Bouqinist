"use strict";(self.webpackChunkelder_books_fe=self.webpackChunkelder_books_fe||[]).push([[303],{7971:(module,__unused_webpack_exports,__webpack_require__)=>{eval("\n\nvar forEach = __webpack_require__(4730);\nvar availableTypedArrays = __webpack_require__(9808);\nvar callBind = __webpack_require__(7257);\nvar callBound = __webpack_require__(2648);\nvar gOPD = __webpack_require__(1700);\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(6323)();\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\nvar $slice = callBound('String.prototype.slice');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n  for (var i = 0; i < array.length; i += 1) {\n    if (array[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n};\nvar cache = {\n  __proto__: null\n};\nif (hasToStringTag && gOPD && getPrototypeOf) {\n  forEach(typedArrays, function (typedArray) {\n    var arr = new g[typedArray]();\n    if (Symbol.toStringTag in arr) {\n      var proto = getPrototypeOf(arr);\n      var descriptor = gOPD(proto, Symbol.toStringTag);\n      if (!descriptor) {\n        var superProto = getPrototypeOf(proto);\n        descriptor = gOPD(superProto, Symbol.toStringTag);\n      }\n      cache['$' + typedArray] = callBind(descriptor.get);\n    }\n  });\n} else {\n  forEach(typedArrays, function (typedArray) {\n    var arr = new g[typedArray]();\n    cache['$' + typedArray] = callBind(arr.slice);\n  });\n}\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n  var found = false;\n  forEach(cache, function (getter, typedArray) {\n    if (!found) {\n      try {\n        if ('$' + getter(value) === typedArray) {\n          found = $slice(typedArray, 1);\n        }\n      } catch (e) {/**/}\n    }\n  });\n  return found;\n};\nvar trySlices = function tryAllSlices(value) {\n  var found = false;\n  forEach(cache, function (getter, name) {\n    if (!found) {\n      try {\n        getter(value);\n        found = $slice(name, 1);\n      } catch (e) {/**/}\n    }\n  });\n  return found;\n};\nmodule.exports = function whichTypedArray(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  if (!hasToStringTag) {\n    var tag = $slice($toString(value), 8, -1);\n    if ($indexOf(typedArrays, tag) > -1) {\n      return tag;\n    }\n    if (tag !== 'Object') {\n      return false;\n    }\n    // node < 0.6 hits here on real Typed Arrays\n    return trySlices(value);\n  }\n  if (!gOPD) {\n    return null;\n  } // unknown engine\n  return tryTypedArrays(value);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRztJQUNYO0lBQ0EsSUFBSUEsR0FBRyxLQUFLLFFBQVEsRUFBRTtNQUNyQixPQUFPLEtBQUs7SUFDYjtJQUNBO0lBQ0EsT0FBT04sU0FBUyxDQUFDbkIsS0FBSyxDQUFDO0VBQ3hCO0VBQ0EsSUFBSSxDQUFDYixJQUFJLEVBQUU7SUFBRSxPQUFPLElBQUk7RUFBRSxDQUFDLENBQUM7RUFDNUIsT0FBTzJCLGNBQWMsQ0FBQ2QsS0FBSyxDQUFDO0FBQzdCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcz9lZGM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciBjYWNoZSA9IHsgX19wcm90b19fOiBudWxsIH07XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChkZXNjcmlwdG9yLmdldCk7XG5cdFx0fVxuXHR9KTtcbn0gZWxzZSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChhcnIuc2xpY2UpO1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoJyQnICsgZ2V0dGVyKHZhbHVlKSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kID0gJHNsaWNlKHR5cGVkQXJyYXksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbnZhciB0cnlTbGljZXMgPSBmdW5jdGlvbiB0cnlBbGxTbGljZXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIG5hbWUpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRnZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHRmb3VuZCA9ICRzbGljZShuYW1lLCAxKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0aWYgKCRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTEpIHtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fVxuXHRcdGlmICh0YWcgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIG5vZGUgPCAwLjYgaGl0cyBoZXJlIG9uIHJlYWwgVHlwZWQgQXJyYXlzXG5cdFx0cmV0dXJuIHRyeVNsaWNlcyh2YWx1ZSk7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBudWxsOyB9IC8vIHVua25vd24gZW5naW5lXG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIl0sIm5hbWVzIjpbImZvckVhY2giLCJyZXF1aXJlIiwiYXZhaWxhYmxlVHlwZWRBcnJheXMiLCJjYWxsQmluZCIsImNhbGxCb3VuZCIsImdPUEQiLCIkdG9TdHJpbmciLCJoYXNUb1N0cmluZ1RhZyIsImciLCJnbG9iYWxUaGlzIiwiZ2xvYmFsIiwidHlwZWRBcnJheXMiLCIkc2xpY2UiLCJnZXRQcm90b3R5cGVPZiIsIk9iamVjdCIsIiRpbmRleE9mIiwiaW5kZXhPZiIsImFycmF5IiwidmFsdWUiLCJpIiwibGVuZ3RoIiwiY2FjaGUiLCJfX3Byb3RvX18iLCJ0eXBlZEFycmF5IiwiYXJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJwcm90byIsImRlc2NyaXB0b3IiLCJzdXBlclByb3RvIiwiZ2V0Iiwic2xpY2UiLCJ0cnlUeXBlZEFycmF5cyIsInRyeUFsbFR5cGVkQXJyYXlzIiwiZm91bmQiLCJnZXR0ZXIiLCJlIiwidHJ5U2xpY2VzIiwidHJ5QWxsU2xpY2VzIiwibmFtZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ3aGljaFR5cGVkQXJyYXkiLCJ0YWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7971\n")},8412:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IX: () => (/* binding */ create$2),\n/* harmony export */   O7: () => (/* binding */ create$7),\n/* harmony export */   Rx: () => (/* binding */ create$5),\n/* harmony export */   Ry: () => (/* binding */ create$3),\n/* harmony export */   Z_: () => (/* binding */ create$6),\n/* harmony export */   iH: () => (/* binding */ create$9)\n/* harmony export */ });\n/* unused harmony exports ArraySchema, BooleanSchema, DateSchema, MixedSchema, NumberSchema, ObjectSchema, Schema, StringSchema, TupleSchema, ValidationError, addMethod, bool, date, defaultLocale, getIn, isSchema, lazy, mixed, printValue, reach, setLocale, tuple */\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1231);\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8735);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9064);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst toString = Object.prototype.toString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nfunction printNumber(val) {\n  if (val != +val) return 'NaN';\n  const isNegativeZero = val === 0 && 1 / val < 0;\n  return isNegativeZero ? '-0' : '' + val;\n}\nfunction printSimpleValue(val, quoteStrings = false) {\n  if (val == null || val === true || val === false) return '' + val;\n  const typeOf = typeof val;\n  if (typeOf === 'number') return printNumber(val);\n  if (typeOf === 'string') return quoteStrings ? `\"${val}\"` : val;\n  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';\n  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n  const tag = toString.call(val).slice(8, -1);\n  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);\n  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';\n  if (tag === 'RegExp') return regExpToString.call(val);\n  return null;\n}\nfunction printValue(value, quoteStrings) {\n  let result = printSimpleValue(value, quoteStrings);\n  if (result !== null) return result;\n  return JSON.stringify(value, function (key, value) {\n    let result = printSimpleValue(this[key], quoteStrings);\n    if (result !== null) return result;\n    return value;\n  }, 2);\n}\nfunction toArray(value) {\n  return value == null ? [] : [].concat(value);\n}\nlet strReg = /\\$\\{\\s*(\\w+)\\s*\\}/g;\nclass ValidationError extends Error {\n  static formatError(message, params) {\n    const path = params.label || params.path || 'this';\n    if (path !== params.path) params = Object.assign({}, params, {\n      path\n    });\n    if (typeof message === 'string') return message.replace(strReg, (_, key) => printValue(params[key]));\n    if (typeof message === 'function') return message(params);\n    return message;\n  }\n  static isError(err) {\n    return err && err.name === 'ValidationError';\n  }\n  constructor(errorOrErrors, value, field, type) {\n    super();\n    this.value = void 0;\n    this.path = void 0;\n    this.type = void 0;\n    this.errors = void 0;\n    this.params = void 0;\n    this.inner = void 0;\n    this.name = 'ValidationError';\n    this.value = value;\n    this.path = field;\n    this.type = type;\n    this.errors = [];\n    this.inner = [];\n    toArray(errorOrErrors).forEach(err => {\n      if (ValidationError.isError(err)) {\n        this.errors.push(...err.errors);\n        this.inner = this.inner.concat(err.inner.length ? err.inner : err);\n      } else {\n        this.errors.push(err);\n      }\n    });\n    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];\n    if (Error.captureStackTrace) Error.captureStackTrace(this, ValidationError);\n  }\n}\nlet mixed = {\n  default: '${path} is invalid',\n  required: '${path} is a required field',\n  defined: '${path} must be defined',\n  notNull: '${path} cannot be null',\n  oneOf: '${path} must be one of the following values: ${values}',\n  notOneOf: '${path} must not be one of the following values: ${values}',\n  notType: ({\n    path,\n    type,\n    value,\n    originalValue\n  }) => {\n    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : '.';\n    return type !== 'mixed' ? `${path} must be a \\`${type}\\` type, ` + `but the final value was: \\`${printValue(value, true)}\\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \\`${printValue(value, true)}\\`` + castMsg;\n  }\n};\nlet string = {\n  length: '${path} must be exactly ${length} characters',\n  min: '${path} must be at least ${min} characters',\n  max: '${path} must be at most ${max} characters',\n  matches: '${path} must match the following: \"${regex}\"',\n  email: '${path} must be a valid email',\n  url: '${path} must be a valid URL',\n  uuid: '${path} must be a valid UUID',\n  trim: '${path} must be a trimmed string',\n  lowercase: '${path} must be a lowercase string',\n  uppercase: '${path} must be a upper case string'\n};\nlet number = {\n  min: '${path} must be greater than or equal to ${min}',\n  max: '${path} must be less than or equal to ${max}',\n  lessThan: '${path} must be less than ${less}',\n  moreThan: '${path} must be greater than ${more}',\n  positive: '${path} must be a positive number',\n  negative: '${path} must be a negative number',\n  integer: '${path} must be an integer'\n};\nlet date = {\n  min: '${path} field must be later than ${min}',\n  max: '${path} field must be at earlier than ${max}'\n};\nlet boolean = {\n  isValue: '${path} field must be ${value}'\n};\nlet object = {\n  noUnknown: '${path} field has unspecified keys: ${unknown}'\n};\nlet array = {\n  min: '${path} field must have at least ${min} items',\n  max: '${path} field must have less than or equal to ${max} items',\n  length: '${path} must have ${length} items'\n};\nlet tuple = {\n  notType: params => {\n    const {\n      path,\n      value,\n      spec\n    } = params;\n    const typeLen = spec.types.length;\n    if (Array.isArray(value)) {\n      if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n      if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n    }\n    return ValidationError.formatError(mixed.notType, params);\n  }\n};\nvar locale = Object.assign(Object.create(null), {\n  mixed,\n  string,\n  number,\n  date,\n  object,\n  array,\n  boolean\n});\nconst isSchema = obj => obj && obj.__isYupSchema__;\nclass Condition {\n  static fromOptions(refs, config) {\n    if (!config.then && !config.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    let {\n      is,\n      then,\n      otherwise\n    } = config;\n    let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);\n    return new Condition(refs, (values, schema) => {\n      var _branch;\n      let branch = check(...values) ? then : otherwise;\n      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;\n    });\n  }\n  constructor(refs, builder) {\n    this.fn = void 0;\n    this.refs = refs;\n    this.refs = refs;\n    this.fn = builder;\n  }\n  resolve(base, options) {\n    let values = this.refs.map(ref =>\n    // TODO: ? operator here?\n    ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));\n    let schema = this.fn(values, base, options);\n    if (schema === undefined ||\n    // @ts-ignore this can be base\n    schema === base) {\n      return base;\n    }\n    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');\n    return schema.resolve(options);\n  }\n}\nconst prefixes = {\n  context: '$',\n  value: '.'\n};\nfunction create$9(key, options) {\n  return new Reference(key, options);\n}\nclass Reference {\n  constructor(key, options = {}) {\n    this.key = void 0;\n    this.isContext = void 0;\n    this.isValue = void 0;\n    this.isSibling = void 0;\n    this.path = void 0;\n    this.getter = void 0;\n    this.map = void 0;\n    if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);\n    this.key = key.trim();\n    if (key === '') throw new TypeError('ref must be a non-empty string');\n    this.isContext = this.key[0] === prefixes.context;\n    this.isValue = this.key[0] === prefixes.value;\n    this.isSibling = !this.isContext && !this.isValue;\n    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';\n    this.path = this.key.slice(prefix.length);\n    this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);\n    this.map = options.map;\n  }\n  getValue(value, parent, context) {\n    let result = this.isContext ? context : this.isValue ? value : parent;\n    if (this.getter) result = this.getter(result || {});\n    if (this.map) result = this.map(result);\n    return result;\n  }\n\n  /**\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @param {Object=} options.context\n   * @param {Object=} options.parent\n   */\n  cast(value, options) {\n    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n  }\n  resolve() {\n    return this;\n  }\n  describe() {\n    return {\n      type: 'ref',\n      key: this.key\n    };\n  }\n  toString() {\n    return `Ref(${this.key})`;\n  }\n  static isRef(value) {\n    return value && value.__isYupRef;\n  }\n}\n\n// @ts-ignore\nReference.prototype.__isYupRef = true;\nconst isAbsent = value => value == null;\nfunction createValidation(config) {\n  function validate({\n    value,\n    path = '',\n    options,\n    originalValue,\n    schema\n  }, panic, next) {\n    const {\n      name,\n      test,\n      params,\n      message,\n      skipAbsent\n    } = config;\n    let {\n      parent,\n      context,\n      abortEarly = schema.spec.abortEarly\n    } = options;\n    function resolve(item) {\n      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;\n    }\n    function createError(overrides = {}) {\n      const nextParams = Object.assign({\n        value,\n        originalValue,\n        label: schema.spec.label,\n        path: overrides.path || path,\n        spec: schema.spec\n      }, params, overrides.params);\n      for (const key of Object.keys(nextParams)) nextParams[key] = resolve(nextParams[key]);\n      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);\n      error.params = nextParams;\n      return error;\n    }\n    const invalid = abortEarly ? panic : next;\n    let ctx = {\n      path,\n      parent,\n      type: name,\n      from: options.from,\n      createError,\n      resolve,\n      options,\n      originalValue,\n      schema\n    };\n    const handleResult = validOrError => {\n      if (ValidationError.isError(validOrError)) invalid(validOrError);else if (!validOrError) invalid(createError());else next(null);\n    };\n    const handleError = err => {\n      if (ValidationError.isError(err)) invalid(err);else panic(err);\n    };\n    const shouldSkip = skipAbsent && isAbsent(value);\n    if (!options.sync) {\n      try {\n        Promise.resolve(!shouldSkip ? test.call(ctx, value, ctx) : true).then(handleResult, handleError);\n      } catch (err) {\n        handleError(err);\n      }\n      return;\n    }\n    let result;\n    try {\n      var _result;\n      result = !shouldSkip ? test.call(ctx, value, ctx) : true;\n      if (typeof ((_result = result) == null ? void 0 : _result.then) === 'function') {\n        throw new Error(`Validation test of type: \"${ctx.type}\" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);\n      }\n    } catch (err) {\n      handleError(err);\n      return;\n    }\n    handleResult(result);\n  }\n  validate.OPTIONS = config;\n  return validate;\n}\nfunction getIn(schema, path, value, context = value) {\n  let parent, lastPart, lastPartDebug;\n\n  // root path: ''\n  if (!path) return {\n    parent,\n    parentPath: path,\n    schema\n  };\n  (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, (_part, isBracket, isArray) => {\n    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;\n    schema = schema.resolve({\n      context,\n      parent,\n      value\n    });\n    let isTuple = schema.type === 'tuple';\n    let idx = isArray ? parseInt(part, 10) : 0;\n    if (schema.innerType || isTuple) {\n      if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part \"${lastPartDebug}\" must contain an index to the tuple element, e.g. \"${lastPartDebug}[0]\"`);\n      if (value && idx >= value.length) {\n        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n      }\n      parent = value;\n      value = value && value[idx];\n      schema = isTuple ? schema.spec.types[idx] : schema.innerType;\n    }\n\n    // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema.type}\")`);\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema,\n    parent,\n    parentPath: lastPart\n  };\n}\nfunction reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n}\nclass ReferenceSet extends Set {\n  describe() {\n    const description = [];\n    for (const item of this.values()) {\n      description.push(Reference.isRef(item) ? item.describe() : item);\n    }\n    return description;\n  }\n  resolveAll(resolve) {\n    let result = [];\n    for (const item of this.values()) {\n      result.push(resolve(item));\n    }\n    return result;\n  }\n  clone() {\n    return new ReferenceSet(this.values());\n  }\n  merge(newItems, removeItems) {\n    const next = this.clone();\n    newItems.forEach(value => next.add(value));\n    removeItems.forEach(value => next.delete(value));\n    return next;\n  }\n}\n\n// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js\nfunction clone(src, seen = new Map()) {\n  if (isSchema(src) || !src || typeof src !== 'object') return src;\n  if (seen.has(src)) return seen.get(src);\n  let copy;\n  if (src instanceof Date) {\n    // Date\n    copy = new Date(src.getTime());\n    seen.set(src, copy);\n  } else if (src instanceof RegExp) {\n    // RegExp\n    copy = new RegExp(src);\n    seen.set(src, copy);\n  } else if (Array.isArray(src)) {\n    // Array\n    copy = new Array(src.length);\n    seen.set(src, copy);\n    for (let i = 0; i < src.length; i++) copy[i] = clone(src[i], seen);\n  } else if (src instanceof Map) {\n    // Map\n    copy = new Map();\n    seen.set(src, copy);\n    for (const [k, v] of src.entries()) copy.set(k, clone(v, seen));\n  } else if (src instanceof Set) {\n    // Set\n    copy = new Set();\n    seen.set(src, copy);\n    for (const v of src) copy.add(clone(v, seen));\n  } else if (src instanceof Object) {\n    // Object\n    copy = {};\n    seen.set(src, copy);\n    for (const [k, v] of Object.entries(src)) copy[k] = clone(v, seen);\n  } else {\n    throw Error(`Unable to clone ${src}`);\n  }\n  return copy;\n}\nclass Schema {\n  constructor(options) {\n    this.type = void 0;\n    this.deps = [];\n    this.tests = void 0;\n    this.transforms = void 0;\n    this.conditions = [];\n    this._mutate = void 0;\n    this.internalTests = {};\n    this._whitelist = new ReferenceSet();\n    this._blacklist = new ReferenceSet();\n    this.exclusiveTests = Object.create(null);\n    this._typeCheck = void 0;\n    this.spec = void 0;\n    this.tests = [];\n    this.transforms = [];\n    this.withMutation(() => {\n      this.typeError(mixed.notType);\n    });\n    this.type = options.type;\n    this._typeCheck = options.check;\n    this.spec = Object.assign({\n      strip: false,\n      strict: false,\n      abortEarly: true,\n      recursive: true,\n      nullable: false,\n      optional: true,\n      coerce: true\n    }, options == null ? void 0 : options.spec);\n    this.withMutation(s => {\n      s.nonNullable();\n    });\n  }\n\n  // TODO: remove\n  get _type() {\n    return this.type;\n  }\n  clone(spec) {\n    if (this._mutate) {\n      if (spec) Object.assign(this.spec, spec);\n      return this;\n    }\n\n    // if the nested value is a schema we can skip cloning, since\n    // they are already immutable\n    const next = Object.create(Object.getPrototypeOf(this));\n\n    // @ts-expect-error this is readonly\n    next.type = this.type;\n    next._typeCheck = this._typeCheck;\n    next._whitelist = this._whitelist.clone();\n    next._blacklist = this._blacklist.clone();\n    next.internalTests = Object.assign({}, this.internalTests);\n    next.exclusiveTests = Object.assign({}, this.exclusiveTests);\n\n    // @ts-expect-error this is readonly\n    next.deps = [...this.deps];\n    next.conditions = [...this.conditions];\n    next.tests = [...this.tests];\n    next.transforms = [...this.transforms];\n    next.spec = clone(Object.assign({}, this.spec, spec));\n    return next;\n  }\n  label(label) {\n    let next = this.clone();\n    next.spec.label = label;\n    return next;\n  }\n  meta(...args) {\n    if (args.length === 0) return this.spec.meta;\n    let next = this.clone();\n    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n    return next;\n  }\n  withMutation(fn) {\n    let before = this._mutate;\n    this._mutate = true;\n    let result = fn(this);\n    this._mutate = before;\n    return result;\n  }\n  concat(schema) {\n    if (!schema || schema === this) return this;\n    if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \\`concat()\\` schema's of different types: ${this.type} and ${schema.type}`);\n    let base = this;\n    let combined = schema.clone();\n    const mergedSpec = Object.assign({}, base.spec, combined.spec);\n    combined.spec = mergedSpec;\n    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);\n\n    // manually merge the blacklist/whitelist (the other `schema` takes\n    // precedence in case of conflicts)\n    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);\n\n    // start with the current tests\n    combined.tests = base.tests;\n    combined.exclusiveTests = base.exclusiveTests;\n\n    // manually add the new tests to ensure\n    // the deduping logic is consistent\n    combined.withMutation(next => {\n      schema.tests.forEach(fn => {\n        next.test(fn.OPTIONS);\n      });\n    });\n    combined.transforms = [...base.transforms, ...combined.transforms];\n    return combined;\n  }\n  isType(v) {\n    if (v == null) {\n      if (this.spec.nullable && v === null) return true;\n      if (this.spec.optional && v === undefined) return true;\n      return false;\n    }\n    return this._typeCheck(v);\n  }\n  resolve(options) {\n    let schema = this;\n    if (schema.conditions.length) {\n      let conditions = schema.conditions;\n      schema = schema.clone();\n      schema.conditions = [];\n      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);\n      schema = schema.resolve(options);\n    }\n    return schema;\n  }\n  resolveOptions(options) {\n    var _options$strict, _options$abortEarly, _options$recursive;\n    return Object.assign({}, options, {\n      from: options.from || [],\n      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,\n      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,\n      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive\n    });\n  }\n\n  /**\n   * Run the configured transform pipeline over an input value.\n   */\n\n  cast(value, options = {}) {\n    let resolvedSchema = this.resolve(Object.assign({\n      value\n    }, options));\n    let allowOptionality = options.assert === 'ignore-optionality';\n    let result = resolvedSchema._cast(value, options);\n    if (options.assert !== false && !resolvedSchema.isType(result)) {\n      if (allowOptionality && isAbsent(result)) {\n        return result;\n      }\n      let formattedValue = printValue(value);\n      let formattedResult = printValue(result);\n      throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: \"${resolvedSchema.type}\". \\n\\n` + `attempted value: ${formattedValue} \\n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));\n    }\n    return result;\n  }\n  _cast(rawValue, options) {\n    let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);\n    if (value === undefined) {\n      value = this.getDefault(options);\n    }\n    return value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    let {\n      path,\n      originalValue = _value,\n      strict = this.spec.strict\n    } = options;\n    let value = _value;\n    if (!strict) {\n      value = this._cast(value, Object.assign({\n        assert: false\n      }, options));\n    }\n    let initialTests = [];\n    for (let test of Object.values(this.internalTests)) {\n      if (test) initialTests.push(test);\n    }\n    this.runTests({\n      path,\n      value,\n      originalValue,\n      options,\n      tests: initialTests\n    }, panic, initialErrors => {\n      // even if we aren't ending early we can't proceed further if the types aren't correct\n      if (initialErrors.length) {\n        return next(initialErrors, value);\n      }\n      this.runTests({\n        path,\n        value,\n        originalValue,\n        options,\n        tests: this.tests\n      }, panic, next);\n    });\n  }\n\n  /**\n   * Executes a set of validations, either schema, produced Tests or a nested\n   * schema validate result.\n   */\n  runTests(runOptions, panic, next) {\n    let fired = false;\n    let {\n      tests,\n      value,\n      originalValue,\n      path,\n      options\n    } = runOptions;\n    let panicOnce = arg => {\n      if (fired) return;\n      fired = true;\n      panic(arg, value);\n    };\n    let nextOnce = arg => {\n      if (fired) return;\n      fired = true;\n      next(arg, value);\n    };\n    let count = tests.length;\n    let nestedErrors = [];\n    if (!count) return nextOnce([]);\n    let args = {\n      value,\n      originalValue,\n      path,\n      options,\n      schema: this\n    };\n    for (let i = 0; i < tests.length; i++) {\n      const test = tests[i];\n      test(args, panicOnce, function finishTestRun(err) {\n        if (err) {\n          nestedErrors = nestedErrors.concat(err);\n        }\n        if (--count <= 0) {\n          nextOnce(nestedErrors);\n        }\n      });\n    }\n  }\n  asNestedTest({\n    key,\n    index,\n    parent,\n    parentPath,\n    originalParent,\n    options\n  }) {\n    const k = key != null ? key : index;\n    if (k == null) {\n      throw TypeError('Must include `key` or `index` for nested validations');\n    }\n    const isIndex = typeof k === 'number';\n    let value = parent[k];\n    const testOptions = Object.assign({}, options, {\n      // Nested validations fields are always strict:\n      //    1. parent isn't strict so the casting will also have cast inner values\n      //    2. parent is strict in which case the nested values weren't cast either\n      strict: true,\n      parent,\n      value,\n      originalValue: originalParent[k],\n      // FIXME: tests depend on `index` being passed around deeply,\n      //   we should not let the options.key/index bleed through\n      key: undefined,\n      // index: undefined,\n      [isIndex ? 'index' : 'key']: k,\n      path: isIndex || k.includes('.') ? `${parentPath || ''}[${value ? k : `\"${k}\"`}]` : (parentPath ? `${parentPath}.` : '') + key\n    });\n    return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);\n  }\n  validate(value, options) {\n    let schema = this.resolve(Object.assign({}, options, {\n      value\n    }));\n    return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {\n      if (ValidationError.isError(error)) error.value = parsed;\n      reject(error);\n    }, (errors, validated) => {\n      if (errors.length) reject(new ValidationError(errors, validated));else resolve(validated);\n    }));\n  }\n  validateSync(value, options) {\n    let schema = this.resolve(Object.assign({}, options, {\n      value\n    }));\n    let result;\n    schema._validate(value, Object.assign({}, options, {\n      sync: true\n    }), (error, parsed) => {\n      if (ValidationError.isError(error)) error.value = parsed;\n      throw error;\n    }, (errors, validated) => {\n      if (errors.length) throw new ValidationError(errors, value);\n      result = validated;\n    });\n    return result;\n  }\n  isValid(value, options) {\n    return this.validate(value, options).then(() => true, err => {\n      if (ValidationError.isError(err)) return false;\n      throw err;\n    });\n  }\n  isValidSync(value, options) {\n    try {\n      this.validateSync(value, options);\n      return true;\n    } catch (err) {\n      if (ValidationError.isError(err)) return false;\n      throw err;\n    }\n  }\n  _getDefault(options) {\n    let defaultValue = this.spec.default;\n    if (defaultValue == null) {\n      return defaultValue;\n    }\n    return typeof defaultValue === 'function' ? defaultValue.call(this, options) : clone(defaultValue);\n  }\n  getDefault(options\n  // If schema is defaulted we know it's at least not undefined\n  ) {\n    let schema = this.resolve(options || {});\n    return schema._getDefault(options);\n  }\n  default(def) {\n    if (arguments.length === 0) {\n      return this._getDefault();\n    }\n    let next = this.clone({\n      default: def\n    });\n    return next;\n  }\n  strict(isStrict = true) {\n    return this.clone({\n      strict: isStrict\n    });\n  }\n  nullability(nullable, message) {\n    const next = this.clone({\n      nullable\n    });\n    next.internalTests.nullable = createValidation({\n      message,\n      name: 'nullable',\n      test(value) {\n        return value === null ? this.schema.spec.nullable : true;\n      }\n    });\n    return next;\n  }\n  optionality(optional, message) {\n    const next = this.clone({\n      optional\n    });\n    next.internalTests.optionality = createValidation({\n      message,\n      name: 'optionality',\n      test(value) {\n        return value === undefined ? this.schema.spec.optional : true;\n      }\n    });\n    return next;\n  }\n  optional() {\n    return this.optionality(true);\n  }\n  defined(message = mixed.defined) {\n    return this.optionality(false, message);\n  }\n  nullable() {\n    return this.nullability(true);\n  }\n  nonNullable(message = mixed.notNull) {\n    return this.nullability(false, message);\n  }\n  required(message = mixed.required) {\n    return this.clone().withMutation(next => next.nonNullable(message).defined(message));\n  }\n  notRequired() {\n    return this.clone().withMutation(next => next.nullable().optional());\n  }\n  transform(fn) {\n    let next = this.clone();\n    next.transforms.push(fn);\n    return next;\n  }\n\n  /**\n   * Adds a test function to the schema's queue of tests.\n   * tests can be exclusive or non-exclusive.\n   *\n   * - exclusive tests, will replace any existing tests of the same name.\n   * - non-exclusive: can be stacked\n   *\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\n   * the exclusive test is removed and further tests of the same name will be stacked.\n   *\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\n   * the previous tests are removed and further tests of the same name will replace each other.\n   */\n\n  test(...args) {\n    let opts;\n    if (args.length === 1) {\n      if (typeof args[0] === 'function') {\n        opts = {\n          test: args[0]\n        };\n      } else {\n        opts = args[0];\n      }\n    } else if (args.length === 2) {\n      opts = {\n        name: args[0],\n        test: args[1]\n      };\n    } else {\n      opts = {\n        name: args[0],\n        message: args[1],\n        test: args[2]\n      };\n    }\n    if (opts.message === undefined) opts.message = mixed.default;\n    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');\n    let next = this.clone();\n    let validate = createValidation(opts);\n    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n    if (opts.exclusive) {\n      if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');\n    }\n    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n    next.tests = next.tests.filter(fn => {\n      if (fn.OPTIONS.name === opts.name) {\n        if (isExclusive) return false;\n        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n      }\n      return true;\n    });\n    next.tests.push(validate);\n    return next;\n  }\n  when(keys, options) {\n    if (!Array.isArray(keys) && typeof keys !== 'string') {\n      options = keys;\n      keys = '.';\n    }\n    let next = this.clone();\n    let deps = toArray(keys).map(key => new Reference(key));\n    deps.forEach(dep => {\n      // @ts-ignore readonly array\n      if (dep.isSibling) next.deps.push(dep.key);\n    });\n    next.conditions.push(typeof options === 'function' ? new Condition(deps, options) : Condition.fromOptions(deps, options));\n    return next;\n  }\n  typeError(message) {\n    let next = this.clone();\n    next.internalTests.typeError = createValidation({\n      message,\n      name: 'typeError',\n      skipAbsent: true,\n      test(value) {\n        if (!this.schema._typeCheck(value)) return this.createError({\n          params: {\n            type: this.schema.type\n          }\n        });\n        return true;\n      }\n    });\n    return next;\n  }\n  oneOf(enums, message = mixed.oneOf) {\n    let next = this.clone();\n    enums.forEach(val => {\n      next._whitelist.add(val);\n      next._blacklist.delete(val);\n    });\n    next.internalTests.whiteList = createValidation({\n      message,\n      name: 'oneOf',\n      skipAbsent: true,\n      test(value) {\n        let valids = this.schema._whitelist;\n        let resolved = valids.resolveAll(this.resolve);\n        return resolved.includes(value) ? true : this.createError({\n          params: {\n            values: Array.from(valids).join(', '),\n            resolved\n          }\n        });\n      }\n    });\n    return next;\n  }\n  notOneOf(enums, message = mixed.notOneOf) {\n    let next = this.clone();\n    enums.forEach(val => {\n      next._blacklist.add(val);\n      next._whitelist.delete(val);\n    });\n    next.internalTests.blacklist = createValidation({\n      message,\n      name: 'notOneOf',\n      test(value) {\n        let invalids = this.schema._blacklist;\n        let resolved = invalids.resolveAll(this.resolve);\n        if (resolved.includes(value)) return this.createError({\n          params: {\n            values: Array.from(invalids).join(', '),\n            resolved\n          }\n        });\n        return true;\n      }\n    });\n    return next;\n  }\n  strip(strip = true) {\n    let next = this.clone();\n    next.spec.strip = strip;\n    return next;\n  }\n\n  /**\n   * Return a serialized description of the schema including validations, flags, types etc.\n   *\n   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).\n   */\n  describe(options) {\n    const next = (options ? this.resolve(options) : this).clone();\n    const {\n      label,\n      meta,\n      optional,\n      nullable\n    } = next.spec;\n    const description = {\n      meta,\n      label,\n      optional,\n      nullable,\n      default: next.getDefault(options),\n      type: next.type,\n      oneOf: next._whitelist.describe(),\n      notOneOf: next._blacklist.describe(),\n      tests: next.tests.map(fn => ({\n        name: fn.OPTIONS.name,\n        params: fn.OPTIONS.params\n      })).filter((n, idx, list) => list.findIndex(c => c.name === n.name) === idx)\n    };\n    return description;\n  }\n}\n// @ts-expect-error\nSchema.prototype.__isYupSchema__ = true;\nfor (const method of ['validate', 'validateSync']) Schema.prototype[`${method}At`] = function (path, value, options = {}) {\n  const {\n    parent,\n    parentPath,\n    schema\n  } = getIn(this, path, value, options.context);\n  return schema[method](parent && parent[parentPath], Object.assign({}, options, {\n    parent,\n    path\n  }));\n};\nfor (const alias of ['equals', 'is']) Schema.prototype[alias] = Schema.prototype.oneOf;\nfor (const alias of ['not', 'nope']) Schema.prototype[alias] = Schema.prototype.notOneOf;\nconst returnsTrue = () => true;\nfunction create$8(spec) {\n  return new MixedSchema(spec);\n}\nclass MixedSchema extends Schema {\n  constructor(spec) {\n    super(typeof spec === 'function' ? {\n      type: 'mixed',\n      check: spec\n    } : Object.assign({\n      type: 'mixed',\n      check: returnsTrue\n    }, spec));\n  }\n}\ncreate$8.prototype = MixedSchema.prototype;\nfunction create$7() {\n  return new BooleanSchema();\n}\nclass BooleanSchema extends Schema {\n  constructor() {\n    super({\n      type: 'boolean',\n      check(v) {\n        if (v instanceof Boolean) v = v.valueOf();\n        return typeof v === 'boolean';\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        if (ctx.spec.coerce && !ctx.isType(value)) {\n          if (/^(true|1)$/i.test(String(value))) return true;\n          if (/^(false|0)$/i.test(String(value))) return false;\n        }\n        return value;\n      });\n    });\n  }\n  isTrue(message = boolean.isValue) {\n    return this.test({\n      message,\n      name: 'is-value',\n      exclusive: true,\n      params: {\n        value: 'true'\n      },\n      test(value) {\n        return isAbsent(value) || value === true;\n      }\n    });\n  }\n  isFalse(message = boolean.isValue) {\n    return this.test({\n      message,\n      name: 'is-value',\n      exclusive: true,\n      params: {\n        value: 'false'\n      },\n      test(value) {\n        return isAbsent(value) || value === false;\n      }\n    });\n  }\n  default(def) {\n    return super.default(def);\n  }\n  defined(msg) {\n    return super.defined(msg);\n  }\n  optional() {\n    return super.optional();\n  }\n  required(msg) {\n    return super.required(msg);\n  }\n  notRequired() {\n    return super.notRequired();\n  }\n  nullable() {\n    return super.nullable();\n  }\n  nonNullable(msg) {\n    return super.nonNullable(msg);\n  }\n  strip(v) {\n    return super.strip(v);\n  }\n}\ncreate$7.prototype = BooleanSchema.prototype;\n\n// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address\nlet rEmail =\n// eslint-disable-next-line\n/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nlet rUrl =\n// eslint-disable-next-line\n/^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n\n// eslint-disable-next-line\nlet rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nlet isTrimmed = value => isAbsent(value) || value === value.trim();\nlet objStringTag = {}.toString();\nfunction create$6() {\n  return new StringSchema();\n}\nclass StringSchema extends Schema {\n  constructor() {\n    super({\n      type: 'string',\n      check(value) {\n        if (value instanceof String) value = value.valueOf();\n        return typeof value === 'string';\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        if (!ctx.spec.coerce || ctx.isType(value)) return value;\n\n        // don't ever convert arrays\n        if (Array.isArray(value)) return value;\n        const strValue = value != null && value.toString ? value.toString() : value;\n\n        // no one wants plain objects converted to [Object object]\n        if (strValue === objStringTag) return value;\n        return strValue;\n      });\n    });\n  }\n  required(message) {\n    return super.required(message).withMutation(schema => schema.test({\n      message: message || mixed.required,\n      name: 'required',\n      skipAbsent: true,\n      test: value => !!value.length\n    }));\n  }\n  notRequired() {\n    return super.notRequired().withMutation(schema => {\n      schema.tests = schema.tests.filter(t => t.OPTIONS.name !== 'required');\n      return schema;\n    });\n  }\n  length(length, message = string.length) {\n    return this.test({\n      message,\n      name: 'length',\n      exclusive: true,\n      params: {\n        length\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length === this.resolve(length);\n      }\n    });\n  }\n  min(min, message = string.min) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length >= this.resolve(min);\n      }\n    });\n  }\n  max(max, message = string.max) {\n    return this.test({\n      name: 'max',\n      exclusive: true,\n      message,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length <= this.resolve(max);\n      }\n    });\n  }\n  matches(regex, options) {\n    let excludeEmptyString = false;\n    let message;\n    let name;\n    if (options) {\n      if (typeof options === 'object') {\n        ({\n          excludeEmptyString = false,\n          message,\n          name\n        } = options);\n      } else {\n        message = options;\n      }\n    }\n    return this.test({\n      name: name || 'matches',\n      message: message || string.matches,\n      params: {\n        regex\n      },\n      skipAbsent: true,\n      test: value => value === '' && excludeEmptyString || value.search(regex) !== -1\n    });\n  }\n  email(message = string.email) {\n    return this.matches(rEmail, {\n      name: 'email',\n      message,\n      excludeEmptyString: true\n    });\n  }\n  url(message = string.url) {\n    return this.matches(rUrl, {\n      name: 'url',\n      message,\n      excludeEmptyString: true\n    });\n  }\n  uuid(message = string.uuid) {\n    return this.matches(rUUID, {\n      name: 'uuid',\n      message,\n      excludeEmptyString: false\n    });\n  }\n\n  //-- transforms --\n  ensure() {\n    return this.default('').transform(val => val === null ? '' : val);\n  }\n  trim(message = string.trim) {\n    return this.transform(val => val != null ? val.trim() : val).test({\n      message,\n      name: 'trim',\n      test: isTrimmed\n    });\n  }\n  lowercase(message = string.lowercase) {\n    return this.transform(value => !isAbsent(value) ? value.toLowerCase() : value).test({\n      message,\n      name: 'string_case',\n      exclusive: true,\n      skipAbsent: true,\n      test: value => isAbsent(value) || value === value.toLowerCase()\n    });\n  }\n  uppercase(message = string.uppercase) {\n    return this.transform(value => !isAbsent(value) ? value.toUpperCase() : value).test({\n      message,\n      name: 'string_case',\n      exclusive: true,\n      skipAbsent: true,\n      test: value => isAbsent(value) || value === value.toUpperCase()\n    });\n  }\n}\ncreate$6.prototype = StringSchema.prototype;\n\n//\n// String Interfaces\n//\n\nlet isNaN$1 = value => value != +value;\nfunction create$5() {\n  return new NumberSchema();\n}\nclass NumberSchema extends Schema {\n  constructor() {\n    super({\n      type: 'number',\n      check(value) {\n        if (value instanceof Number) value = value.valueOf();\n        return typeof value === 'number' && !isNaN$1(value);\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        if (!ctx.spec.coerce) return value;\n        let parsed = value;\n        if (typeof parsed === 'string') {\n          parsed = parsed.replace(/\\s/g, '');\n          if (parsed === '') return NaN;\n          // don't use parseFloat to avoid positives on alpha-numeric strings\n          parsed = +parsed;\n        }\n\n        // null -> NaN isn't useful; treat all nulls as null and let it fail on\n        // nullability check vs TypeErrors\n        if (ctx.isType(parsed) || parsed === null) return parsed;\n        return parseFloat(parsed);\n      });\n    });\n  }\n  min(min, message = number.min) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      test(value) {\n        return value >= this.resolve(min);\n      }\n    });\n  }\n  max(max, message = number.max) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value <= this.resolve(max);\n      }\n    });\n  }\n  lessThan(less, message = number.lessThan) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        less\n      },\n      skipAbsent: true,\n      test(value) {\n        return value < this.resolve(less);\n      }\n    });\n  }\n  moreThan(more, message = number.moreThan) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        more\n      },\n      skipAbsent: true,\n      test(value) {\n        return value > this.resolve(more);\n      }\n    });\n  }\n  positive(msg = number.positive) {\n    return this.moreThan(0, msg);\n  }\n  negative(msg = number.negative) {\n    return this.lessThan(0, msg);\n  }\n  integer(message = number.integer) {\n    return this.test({\n      name: 'integer',\n      message,\n      skipAbsent: true,\n      test: val => Number.isInteger(val)\n    });\n  }\n  truncate() {\n    return this.transform(value => !isAbsent(value) ? value | 0 : value);\n  }\n  round(method) {\n    var _method;\n    let avail = ['ceil', 'floor', 'round', 'trunc'];\n    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round';\n\n    // this exists for symemtry with the new Math.trunc\n    if (method === 'trunc') return this.truncate();\n    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));\n    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);\n  }\n}\ncreate$5.prototype = NumberSchema.prototype;\n\n//\n// Number Interfaces\n//\n\n/* eslint-disable */\n/**\n *\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n * NON-CONFORMANT EDITION.\n * © 2011 Colin Snover <http://zetafleet.com>\n * Released under MIT license.\n */\n\n//              1 YYYY                 2 MM        3 DD              4 HH     5 mm        6 ss            7 msec         8 Z 9 ±    10 tzHH    11 tzmm\nvar isoReg = /^(\\d{4}|[+\\-]\\d{6})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:[ T]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,\\.](\\d{1,}))?)?(?:(Z)|([+\\-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\nfunction parseIsoDate(date) {\n  var numericKeys = [1, 4, 5, 6, 7, 10, 11],\n    minutesOffset = 0,\n    timestamp,\n    struct;\n  if (struct = isoReg.exec(date)) {\n    // avoid NaN timestamps caused by “undefined” values being passed to Date.UTC\n    for (var i = 0, k; k = numericKeys[i]; ++i) struct[k] = +struct[k] || 0;\n\n    // allow undefined days and months\n    struct[2] = (+struct[2] || 1) - 1;\n    struct[3] = +struct[3] || 1;\n\n    // allow arbitrary sub-second precision beyond milliseconds\n    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;\n\n    // timestamps without timezone identifiers should be considered local time\n    if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === '')) timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);else {\n      if (struct[8] !== 'Z' && struct[9] !== undefined) {\n        minutesOffset = struct[10] * 60 + struct[11];\n        if (struct[9] === '+') minutesOffset = 0 - minutesOffset;\n      }\n      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);\n    }\n  } else timestamp = Date.parse ? Date.parse(date) : NaN;\n  return timestamp;\n}\n\n// @ts-ignore\nlet invalidDate = new Date('');\nlet isDate = obj => Object.prototype.toString.call(obj) === '[object Date]';\nfunction create$4() {\n  return new DateSchema();\n}\nclass DateSchema extends Schema {\n  constructor() {\n    super({\n      type: 'date',\n      check(v) {\n        return isDate(v) && !isNaN(v.getTime());\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on\n        // nullability check vs TypeErrors\n        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;\n        value = parseIsoDate(value);\n\n        // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.\n        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;\n      });\n    });\n  }\n  prepareParam(ref, name) {\n    let param;\n    if (!Reference.isRef(ref)) {\n      let cast = this.cast(ref);\n      if (!this._typeCheck(cast)) throw new TypeError(`\\`${name}\\` must be a Date or a value that can be \\`cast()\\` to a Date`);\n      param = cast;\n    } else {\n      param = ref;\n    }\n    return param;\n  }\n  min(min, message = date.min) {\n    let limit = this.prepareParam(min, 'min');\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      test(value) {\n        return value >= this.resolve(limit);\n      }\n    });\n  }\n  max(max, message = date.max) {\n    let limit = this.prepareParam(max, 'max');\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value <= this.resolve(limit);\n      }\n    });\n  }\n}\nDateSchema.INVALID_DATE = invalidDate;\ncreate$4.prototype = DateSchema.prototype;\ncreate$4.INVALID_DATE = invalidDate;\n\n// @ts-expect-error\nfunction sortFields(fields, excludedEdges = []) {\n  let edges = [];\n  let nodes = new Set();\n  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));\n  function addNode(depPath, key) {\n    let node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];\n    nodes.add(node);\n    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);\n  }\n  for (const key of Object.keys(fields)) {\n    let value = fields[key];\n    nodes.add(key);\n    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));\n  }\n  return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();\n}\nfunction findIndex(arr, err) {\n  let idx = Infinity;\n  arr.some((key, ii) => {\n    var _err$path;\n    if ((_err$path = err.path) != null && _err$path.includes(key)) {\n      idx = ii;\n      return true;\n    }\n  });\n  return idx;\n}\nfunction sortByKeyOrder(keys) {\n  return (a, b) => {\n    return findIndex(keys, a) - findIndex(keys, b);\n  };\n}\nconst parseJson = (value, _, ctx) => {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  let parsed = value;\n  try {\n    parsed = JSON.parse(value);\n  } catch (err) {\n    /* */\n  }\n  return ctx.isType(parsed) ? parsed : value;\n};\n\n// @ts-ignore\nfunction deepPartial(schema) {\n  if ('fields' in schema) {\n    const partial = {};\n    for (const [key, fieldSchema] of Object.entries(schema.fields)) {\n      partial[key] = deepPartial(fieldSchema);\n    }\n    return schema.setFields(partial);\n  }\n  if (schema.type === 'array') {\n    const nextArray = schema.optional();\n    if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);\n    return nextArray;\n  }\n  if (schema.type === 'tuple') {\n    return schema.optional().clone({\n      types: schema.spec.types.map(deepPartial)\n    });\n  }\n  if ('optional' in schema) {\n    return schema.optional();\n  }\n  return schema;\n}\nconst deepHas = (obj, p) => {\n  const path = [...(0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p)];\n  if (path.length === 1) return path[0] in obj;\n  let last = path.pop();\n  let parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);\n  return !!(parent && last in parent);\n};\nlet isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\nfunction unknown(ctx, value) {\n  let known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(key => known.indexOf(key) === -1);\n}\nconst defaultSort = sortByKeyOrder([]);\nfunction create$3(spec) {\n  return new ObjectSchema(spec);\n}\nclass ObjectSchema extends Schema {\n  constructor(spec) {\n    super({\n      type: 'object',\n      check(value) {\n        return isObject(value) || typeof value === 'function';\n      }\n    });\n    this.fields = Object.create(null);\n    this._sortErrors = defaultSort;\n    this._nodes = [];\n    this._excludedEdges = [];\n    this.withMutation(() => {\n      if (spec) {\n        this.shape(spec);\n      }\n    });\n  }\n  _cast(_value, options = {}) {\n    var _options$stripUnknown;\n    let value = super._cast(_value, options);\n\n    //should ignore nulls here\n    if (value === undefined) return this.getDefault(options);\n    if (!this._typeCheck(value)) return value;\n    let fields = this.fields;\n    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n    let props = [].concat(this._nodes, Object.keys(value).filter(v => !this._nodes.includes(v)));\n    let intermediateValue = {}; // is filled during the transform below\n    let innerOptions = Object.assign({}, options, {\n      parent: intermediateValue,\n      __validating: options.__validating || false\n    });\n    let isChanged = false;\n    for (const prop of props) {\n      let field = fields[prop];\n      let exists = (prop in value);\n      if (field) {\n        let fieldValue;\n        let inputValue = value[prop];\n\n        // safe to mutate since this is fired in sequence\n        innerOptions.path = (options.path ? `${options.path}.` : '') + prop;\n        field = field.resolve({\n          value: inputValue,\n          context: options.context,\n          parent: intermediateValue\n        });\n        let fieldSpec = field instanceof Schema ? field.spec : undefined;\n        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n        if (fieldSpec != null && fieldSpec.strip) {\n          isChanged = isChanged || prop in value;\n          continue;\n        }\n        fieldValue = !options.__validating || !strict ?\n        // TODO: use _cast, this is double resolving\n        field.cast(value[prop], innerOptions) : value[prop];\n        if (fieldValue !== undefined) {\n          intermediateValue[prop] = fieldValue;\n        }\n      } else if (exists && !strip) {\n        intermediateValue[prop] = value[prop];\n      }\n      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {\n        isChanged = true;\n      }\n    }\n    return isChanged ? intermediateValue : value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    let {\n      from = [],\n      originalValue = _value,\n      recursive = this.spec.recursive\n    } = options;\n    options.from = [{\n      schema: this,\n      value: originalValue\n    }, ...from];\n    // this flag is needed for handling `strict` correctly in the context of\n    // validation vs just casting. e.g strict() on a field is only used when validating\n    options.__validating = true;\n    options.originalValue = originalValue;\n    super._validate(_value, options, panic, (objectErrors, value) => {\n      if (!recursive || !isObject(value)) {\n        next(objectErrors, value);\n        return;\n      }\n      originalValue = originalValue || value;\n      let tests = [];\n      for (let key of this._nodes) {\n        let field = this.fields[key];\n        if (!field || Reference.isRef(field)) {\n          continue;\n        }\n        tests.push(field.asNestedTest({\n          options,\n          key,\n          parent: value,\n          parentPath: options.path,\n          originalParent: originalValue\n        }));\n      }\n      this.runTests({\n        tests,\n        value,\n        originalValue,\n        options\n      }, panic, fieldErrors => {\n        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);\n      });\n    });\n  }\n  clone(spec) {\n    const next = super.clone(spec);\n    next.fields = Object.assign({}, this.fields);\n    next._nodes = this._nodes;\n    next._excludedEdges = this._excludedEdges;\n    next._sortErrors = this._sortErrors;\n    return next;\n  }\n  concat(schema) {\n    let next = super.concat(schema);\n    let nextFields = next.fields;\n    for (let [field, schemaOrRef] of Object.entries(this.fields)) {\n      const target = nextFields[field];\n      nextFields[field] = target === undefined ? schemaOrRef : target;\n    }\n    return next.withMutation(s =>\n    // XXX: excludes here is wrong\n    s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges]));\n  }\n  _getDefault(options) {\n    if ('default' in this.spec) {\n      return super._getDefault(options);\n    }\n\n    // if there is no default set invent one\n    if (!this._nodes.length) {\n      return undefined;\n    }\n    let dft = {};\n    this._nodes.forEach(key => {\n      var _innerOptions;\n      const field = this.fields[key];\n      let innerOptions = options;\n      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[key]\n        });\n      }\n      dft[key] = field && 'getDefault' in field ? field.getDefault(innerOptions) : undefined;\n    });\n    return dft;\n  }\n  setFields(shape, excludedEdges) {\n    let next = this.clone();\n    next.fields = shape;\n    next._nodes = sortFields(shape, excludedEdges);\n    next._sortErrors = sortByKeyOrder(Object.keys(shape));\n    // XXX: this carries over edges which may not be what you want\n    if (excludedEdges) next._excludedEdges = excludedEdges;\n    return next;\n  }\n  shape(additions, excludes = []) {\n    return this.clone().withMutation(next => {\n      let edges = next._excludedEdges;\n      if (excludes.length) {\n        if (!Array.isArray(excludes[0])) excludes = [excludes];\n        edges = [...next._excludedEdges, ...excludes];\n      }\n\n      // XXX: excludes here is wrong\n      return next.setFields(Object.assign(next.fields, additions), edges);\n    });\n  }\n  partial() {\n    const partial = {};\n    for (const [key, schema] of Object.entries(this.fields)) {\n      partial[key] = 'optional' in schema && schema.optional instanceof Function ? schema.optional() : schema;\n    }\n    return this.setFields(partial);\n  }\n  deepPartial() {\n    const next = deepPartial(this);\n    return next;\n  }\n  pick(keys) {\n    const picked = {};\n    for (const key of keys) {\n      if (this.fields[key]) picked[key] = this.fields[key];\n    }\n    return this.setFields(picked);\n  }\n  omit(keys) {\n    const fields = Object.assign({}, this.fields);\n    for (const key of keys) {\n      delete fields[key];\n    }\n    return this.setFields(fields);\n  }\n  from(from, to, alias) {\n    let fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(from, true);\n    return this.transform(obj => {\n      if (!obj) return obj;\n      let newObj = obj;\n      if (deepHas(obj, from)) {\n        newObj = Object.assign({}, obj);\n        if (!alias) delete newObj[from];\n        newObj[to] = fromGetter(obj);\n      }\n      return newObj;\n    });\n  }\n\n  /** Parse an input JSON string to an object */\n  json() {\n    return this.transform(parseJson);\n  }\n  noUnknown(noAllow = true, message = object.noUnknown) {\n    if (typeof noAllow !== 'boolean') {\n      message = noAllow;\n      noAllow = true;\n    }\n    let next = this.test({\n      name: 'noUnknown',\n      exclusive: true,\n      message: message,\n      test(value) {\n        if (value == null) return true;\n        const unknownKeys = unknown(this.schema, value);\n        return !noAllow || unknownKeys.length === 0 || this.createError({\n          params: {\n            unknown: unknownKeys.join(', ')\n          }\n        });\n      }\n    });\n    next.spec.noUnknown = noAllow;\n    return next;\n  }\n  unknown(allow = true, message = object.noUnknown) {\n    return this.noUnknown(!allow, message);\n  }\n  transformKeys(fn) {\n    return this.transform(obj => {\n      if (!obj) return obj;\n      const result = {};\n      for (const key of Object.keys(obj)) result[fn(key)] = obj[key];\n      return result;\n    });\n  }\n  camelCase() {\n    return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);\n  }\n  snakeCase() {\n    return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);\n  }\n  constantCase() {\n    return this.transformKeys(key => (0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase());\n  }\n  describe(options) {\n    let base = super.describe(options);\n    base.fields = {};\n    for (const [key, value] of Object.entries(this.fields)) {\n      var _innerOptions2;\n      let innerOptions = options;\n      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[key]\n        });\n      }\n      base.fields[key] = value.describe(innerOptions);\n    }\n    return base;\n  }\n}\ncreate$3.prototype = ObjectSchema.prototype;\nfunction create$2(type) {\n  return new ArraySchema(type);\n}\nclass ArraySchema extends Schema {\n  constructor(type) {\n    super({\n      type: 'array',\n      spec: {\n        types: type\n      },\n      check(v) {\n        return Array.isArray(v);\n      }\n    });\n\n    // `undefined` specifically means uninitialized, as opposed to \"no subtype\"\n    this.innerType = void 0;\n    this.innerType = type;\n  }\n  _cast(_value, _opts) {\n    const value = super._cast(_value, _opts);\n\n    // should ignore nulls here\n    if (!this._typeCheck(value) || !this.innerType) {\n      return value;\n    }\n    let isChanged = false;\n    const castArray = value.map((v, idx) => {\n      const castElement = this.innerType.cast(v, Object.assign({}, _opts, {\n        path: `${_opts.path || ''}[${idx}]`\n      }));\n      if (castElement !== v) {\n        isChanged = true;\n      }\n      return castElement;\n    });\n    return isChanged ? castArray : value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    var _options$recursive;\n    // let sync = options.sync;\n    // let path = options.path;\n    let innerType = this.innerType;\n    // let endEarly = options.abortEarly ?? this.spec.abortEarly;\n    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n    options.originalValue != null ? options.originalValue : _value;\n    super._validate(_value, options, panic, (arrayErrors, value) => {\n      var _options$originalValu2;\n      if (!recursive || !innerType || !this._typeCheck(value)) {\n        next(arrayErrors, value);\n        return;\n      }\n\n      // #950 Ensure that sparse array empty slots are validated\n      let tests = new Array(value.length);\n      for (let index = 0; index < value.length; index++) {\n        var _options$originalValu;\n        tests[index] = innerType.asNestedTest({\n          options,\n          index,\n          parent: value,\n          parentPath: options.path,\n          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n        });\n      }\n      this.runTests({\n        value,\n        tests,\n        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n        options\n      }, panic, innerTypeErrors => next(innerTypeErrors.concat(arrayErrors), value));\n    });\n  }\n  clone(spec) {\n    const next = super.clone(spec);\n    // @ts-expect-error readonly\n    next.innerType = this.innerType;\n    return next;\n  }\n\n  /** Parse an input JSON string to an object */\n  json() {\n    return this.transform(parseJson);\n  }\n  concat(schema) {\n    let next = super.concat(schema);\n\n    // @ts-expect-error readonly\n    next.innerType = this.innerType;\n    if (schema.innerType)\n      // @ts-expect-error readonly\n      next.innerType = next.innerType ?\n      // @ts-expect-error Lazy doesn't have concat and will break\n      next.innerType.concat(schema.innerType) : schema.innerType;\n    return next;\n  }\n  of(schema) {\n    // FIXME: this should return a new instance of array without the default to be\n    let next = this.clone();\n    if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema));\n\n    // @ts-expect-error readonly\n    next.innerType = schema;\n    next.spec = Object.assign({}, next.spec, {\n      types: schema\n    });\n    return next;\n  }\n  length(length, message = array.length) {\n    return this.test({\n      message,\n      name: 'length',\n      exclusive: true,\n      params: {\n        length\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length === this.resolve(length);\n      }\n    });\n  }\n  min(min, message) {\n    message = message || array.min;\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      // FIXME(ts): Array<typeof T>\n      test(value) {\n        return value.length >= this.resolve(min);\n      }\n    });\n  }\n  max(max, message) {\n    message = message || array.max;\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length <= this.resolve(max);\n      }\n    });\n  }\n  ensure() {\n    return this.default(() => []).transform((val, original) => {\n      // We don't want to return `null` for nullable schema\n      if (this._typeCheck(val)) return val;\n      return original == null ? [] : [].concat(original);\n    });\n  }\n  compact(rejector) {\n    let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);\n    return this.transform(values => values != null ? values.filter(reject) : values);\n  }\n  describe(options) {\n    let base = super.describe(options);\n    if (this.innerType) {\n      var _innerOptions;\n      let innerOptions = options;\n      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[0]\n        });\n      }\n      base.innerType = this.innerType.describe(innerOptions);\n    }\n    return base;\n  }\n}\ncreate$2.prototype = ArraySchema.prototype;\n\n// @ts-ignore\nfunction create$1(schemas) {\n  return new TupleSchema(schemas);\n}\nclass TupleSchema extends Schema {\n  constructor(schemas) {\n    super({\n      type: 'tuple',\n      spec: {\n        types: schemas\n      },\n      check(v) {\n        const types = this.spec.types;\n        return Array.isArray(v) && v.length === types.length;\n      }\n    });\n    this.withMutation(() => {\n      this.typeError(tuple.notType);\n    });\n  }\n  _cast(inputValue, options) {\n    const {\n      types\n    } = this.spec;\n    const value = super._cast(inputValue, options);\n    if (!this._typeCheck(value)) {\n      return value;\n    }\n    let isChanged = false;\n    const castArray = types.map((type, idx) => {\n      const castElement = type.cast(value[idx], Object.assign({}, options, {\n        path: `${options.path || ''}[${idx}]`\n      }));\n      if (castElement !== value[idx]) isChanged = true;\n      return castElement;\n    });\n    return isChanged ? castArray : value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    let itemTypes = this.spec.types;\n    super._validate(_value, options, panic, (tupleErrors, value) => {\n      var _options$originalValu2;\n      // intentionally not respecting recursive\n      if (!this._typeCheck(value)) {\n        next(tupleErrors, value);\n        return;\n      }\n      let tests = [];\n      for (let [index, itemSchema] of itemTypes.entries()) {\n        var _options$originalValu;\n        tests[index] = itemSchema.asNestedTest({\n          options,\n          index,\n          parent: value,\n          parentPath: options.path,\n          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n        });\n      }\n      this.runTests({\n        value,\n        tests,\n        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n        options\n      }, panic, innerTypeErrors => next(innerTypeErrors.concat(tupleErrors), value));\n    });\n  }\n  describe(options) {\n    let base = super.describe(options);\n    base.innerType = this.spec.types.map((schema, index) => {\n      var _innerOptions;\n      let innerOptions = options;\n      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[index]\n        });\n      }\n      return schema.describe(innerOptions);\n    });\n    return base;\n  }\n}\ncreate$1.prototype = TupleSchema.prototype;\nfunction create(builder) {\n  return new Lazy(builder);\n}\nclass Lazy {\n  constructor(builder) {\n    this.type = 'lazy';\n    this.__isYupSchema__ = true;\n    this.spec = void 0;\n    this._resolve = (value, options = {}) => {\n      let schema = this.builder(value, options);\n      if (!isSchema(schema)) throw new TypeError('lazy() functions must return a valid schema');\n      if (this.spec.optional) schema = schema.optional();\n      return schema.resolve(options);\n    };\n    this.builder = builder;\n    this.spec = {\n      meta: undefined,\n      optional: false\n    };\n  }\n  clone(spec) {\n    const next = new Lazy(this.builder);\n    next.spec = Object.assign({}, this.spec, spec);\n    return next;\n  }\n  optionality(optional) {\n    const next = this.clone({\n      optional\n    });\n    return next;\n  }\n  optional() {\n    return this.optionality(true);\n  }\n  resolve(options) {\n    return this._resolve(options.value, options);\n  }\n  cast(value, options) {\n    return this._resolve(value, options).cast(value, options);\n  }\n  asNestedTest(config) {\n    let {\n      key,\n      index,\n      parent,\n      options\n    } = config;\n    let value = parent[index != null ? index : key];\n    return this._resolve(value, Object.assign({}, options, {\n      value,\n      parent\n    })).asNestedTest(config);\n  }\n  validate(value, options) {\n    return this._resolve(value, options).validate(value, options);\n  }\n  validateSync(value, options) {\n    return this._resolve(value, options).validateSync(value, options);\n  }\n  validateAt(path, value, options) {\n    return this._resolve(value, options).validateAt(path, value, options);\n  }\n  validateSyncAt(path, value, options) {\n    return this._resolve(value, options).validateSyncAt(path, value, options);\n  }\n  isValid(value, options) {\n    return this._resolve(value, options).isValid(value, options);\n  }\n  isValidSync(value, options) {\n    return this._resolve(value, options).isValidSync(value, options);\n  }\n  describe(options) {\n    return options ? this.resolve(options).describe(options) : {\n      type: 'lazy',\n      meta: this.spec.meta,\n      label: undefined\n    };\n  }\n  meta(...args) {\n    if (args.length === 0) return this.spec.meta;\n    let next = this.clone();\n    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n    return next;\n  }\n}\nfunction setLocale(custom) {\n  Object.keys(custom).forEach(type => {\n    // @ts-ignore\n    Object.keys(custom[type]).forEach(method => {\n      // @ts-ignore\n      locale[type][method] = custom[type][method];\n    });\n  });\n}\nfunction addMethod(schemaType, name, fn) {\n  if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError('You must provide a yup schema constructor function');\n  if (typeof name !== 'string') throw new TypeError('A Method name must be provided');\n  if (typeof fn !== 'function') throw new TypeError('Method function must be provided');\n  schemaType.prototype[name] = fn;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTb1QsU0FBU0EsQ0FBQ0MsTUFBTSxFQUFFO0VBQ3pCMWIsTUFBTSxDQUFDNkksSUFBSSxDQUFDNlMsTUFBTSxDQUFDLENBQUNsYyxPQUFPLENBQUNxRCxJQUFJLElBQUk7SUFDbEM7SUFDQTdDLE1BQU0sQ0FBQzZJLElBQUksQ0FBQzZTLE1BQU0sQ0FBQzdZLElBQUksQ0FBQyxDQUFDLENBQUNyRCxPQUFPLENBQUNvUyxNQUFNLElBQUk7TUFDMUM7TUFDQW5NLE1BQU0sQ0FBQzVDLElBQUksQ0FBQyxDQUFDK08sTUFBTSxDQUFDLEdBQUc4SixNQUFNLENBQUM3WSxJQUFJLENBQUMsQ0FBQytPLE1BQU0sQ0FBQztJQUM3QyxDQUFDLENBQUM7RUFDSixDQUFDLENBQUM7QUFDSjtBQUVBLFNBQVMrSixTQUFTQSxDQUFDQyxVQUFVLEVBQUU3YSxJQUFJLEVBQUU4RixFQUFFLEVBQUU7RUFDdkMsSUFBSSxDQUFDK1UsVUFBVSxJQUFJLENBQUNqVyxRQUFRLENBQUNpVyxVQUFVLENBQUMzYixTQUFTLENBQUMsRUFBRSxNQUFNLElBQUltRyxTQUFTLENBQUMsb0RBQW9ELENBQUM7RUFDN0gsSUFBSSxPQUFPckYsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLElBQUlxRixTQUFTLENBQUMsZ0NBQWdDLENBQUM7RUFDbkYsSUFBSSxPQUFPUyxFQUFFLEtBQUssVUFBVSxFQUFFLE1BQU0sSUFBSVQsU0FBUyxDQUFDLGtDQUFrQyxDQUFDO0VBQ3JGd1YsVUFBVSxDQUFDM2IsU0FBUyxDQUFDYyxJQUFJLENBQUMsR0FBRzhGLEVBQUU7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy95dXAvaW5kZXguZXNtLmpzPzQyZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0dGVyLCBmb3JFYWNoLCBzcGxpdCwgbm9ybWFsaXplUGF0aCwgam9pbiB9IGZyb20gJ3Byb3BlcnR5LWV4cHInO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBzbmFrZUNhc2UgfSBmcm9tICd0aW55LWNhc2UnO1xuaW1wb3J0IHRvcG9zb3J0IGZyb20gJ3RvcG9zb3J0JztcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgZXJyb3JUb1N0cmluZyA9IEVycm9yLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHJlZ0V4cFRvU3RyaW5nID0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHN5bWJvbFRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogKCkgPT4gJyc7XG5jb25zdCBTWU1CT0xfUkVHRVhQID0gL15TeW1ib2xcXCgoLiopXFwpKC4qKSQvO1xuZnVuY3Rpb24gcHJpbnROdW1iZXIodmFsKSB7XG4gIGlmICh2YWwgIT0gK3ZhbCkgcmV0dXJuICdOYU4nO1xuICBjb25zdCBpc05lZ2F0aXZlWmVybyA9IHZhbCA9PT0gMCAmJiAxIC8gdmFsIDwgMDtcbiAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvID8gJy0wJyA6ICcnICsgdmFsO1xufVxuZnVuY3Rpb24gcHJpbnRTaW1wbGVWYWx1ZSh2YWwsIHF1b3RlU3RyaW5ncyA9IGZhbHNlKSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSkgcmV0dXJuICcnICsgdmFsO1xuICBjb25zdCB0eXBlT2YgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZU9mID09PSAnbnVtYmVyJykgcmV0dXJuIHByaW50TnVtYmVyKHZhbCk7XG4gIGlmICh0eXBlT2YgPT09ICdzdHJpbmcnKSByZXR1cm4gcXVvdGVTdHJpbmdzID8gYFwiJHt2YWx9XCJgIDogdmFsO1xuICBpZiAodHlwZU9mID09PSAnZnVuY3Rpb24nKSByZXR1cm4gJ1tGdW5jdGlvbiAnICsgKHZhbC5uYW1lIHx8ICdhbm9ueW1vdXMnKSArICddJztcbiAgaWYgKHR5cGVPZiA9PT0gJ3N5bWJvbCcpIHJldHVybiBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbCkucmVwbGFjZShTWU1CT0xfUkVHRVhQLCAnU3ltYm9sKCQxKScpO1xuICBjb25zdCB0YWcgPSB0b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xuICBpZiAodGFnID09PSAnRGF0ZScpIHJldHVybiBpc05hTih2YWwuZ2V0VGltZSgpKSA/ICcnICsgdmFsIDogdmFsLnRvSVNPU3RyaW5nKHZhbCk7XG4gIGlmICh0YWcgPT09ICdFcnJvcicgfHwgdmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiAnWycgKyBlcnJvclRvU3RyaW5nLmNhbGwodmFsKSArICddJztcbiAgaWYgKHRhZyA9PT0gJ1JlZ0V4cCcpIHJldHVybiByZWdFeHBUb1N0cmluZy5jYWxsKHZhbCk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcHJpbnRWYWx1ZSh2YWx1ZSwgcXVvdGVTdHJpbmdzKSB7XG4gIGxldCByZXN1bHQgPSBwcmludFNpbXBsZVZhbHVlKHZhbHVlLCBxdW90ZVN0cmluZ3MpO1xuICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHByaW50U2ltcGxlVmFsdWUodGhpc1trZXldLCBxdW90ZVN0cmluZ3MpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LCAyKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KHZhbHVlKTtcbn1cblxubGV0IHN0clJlZyA9IC9cXCRcXHtcXHMqKFxcdyspXFxzKlxcfS9nO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzdGF0aWMgZm9ybWF0RXJyb3IobWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhcmFtcy5sYWJlbCB8fCBwYXJhbXMucGF0aCB8fCAndGhpcyc7XG4gICAgaWYgKHBhdGggIT09IHBhcmFtcy5wYXRoKSBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHtcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSByZXR1cm4gbWVzc2FnZS5yZXBsYWNlKHN0clJlZywgKF8sIGtleSkgPT4gcHJpbnRWYWx1ZShwYXJhbXNba2V5XSkpO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG1lc3NhZ2UocGFyYW1zKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyICYmIGVyci5uYW1lID09PSAnVmFsaWRhdGlvbkVycm9yJztcbiAgfVxuICBjb25zdHJ1Y3RvcihlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmlubmVyID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBmaWVsZDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5pbm5lciA9IFtdO1xuICAgIHRvQXJyYXkoZXJyb3JPckVycm9ycykuZm9yRWFjaChlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCguLi5lcnIuZXJyb3JzKTtcbiAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuY29uY2F0KGVyci5pbm5lci5sZW5ndGggPyBlcnIuaW5uZXIgOiBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuZXJyb3JzLmxlbmd0aCA+IDEgPyBgJHt0aGlzLmVycm9ycy5sZW5ndGh9IGVycm9ycyBvY2N1cnJlZGAgOiB0aGlzLmVycm9yc1swXTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRpb25FcnJvcik7XG4gIH1cbn1cblxubGV0IG1peGVkID0ge1xuICBkZWZhdWx0OiAnJHtwYXRofSBpcyBpbnZhbGlkJyxcbiAgcmVxdWlyZWQ6ICcke3BhdGh9IGlzIGEgcmVxdWlyZWQgZmllbGQnLFxuICBkZWZpbmVkOiAnJHtwYXRofSBtdXN0IGJlIGRlZmluZWQnLFxuICBub3ROdWxsOiAnJHtwYXRofSBjYW5ub3QgYmUgbnVsbCcsXG4gIG9uZU9mOiAnJHtwYXRofSBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczogJHt2YWx1ZXN9JyxcbiAgbm90T25lT2Y6ICcke3BhdGh9IG11c3Qgbm90IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczogJHt2YWx1ZXN9JyxcbiAgbm90VHlwZTogKHtcbiAgICBwYXRoLFxuICAgIHR5cGUsXG4gICAgdmFsdWUsXG4gICAgb3JpZ2luYWxWYWx1ZVxuICB9KSA9PiB7XG4gICAgY29uc3QgY2FzdE1zZyA9IG9yaWdpbmFsVmFsdWUgIT0gbnVsbCAmJiBvcmlnaW5hbFZhbHVlICE9PSB2YWx1ZSA/IGAgKGNhc3QgZnJvbSB0aGUgdmFsdWUgXFxgJHtwcmludFZhbHVlKG9yaWdpbmFsVmFsdWUsIHRydWUpfVxcYCkuYCA6ICcuJztcbiAgICByZXR1cm4gdHlwZSAhPT0gJ21peGVkJyA/IGAke3BhdGh9IG11c3QgYmUgYSBcXGAke3R5cGV9XFxgIHR5cGUsIGAgKyBgYnV0IHRoZSBmaW5hbCB2YWx1ZSB3YXM6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYCArIGNhc3RNc2cgOiBgJHtwYXRofSBtdXN0IG1hdGNoIHRoZSBjb25maWd1cmVkIHR5cGUuIGAgKyBgVGhlIHZhbGlkYXRlZCB2YWx1ZSB3YXM6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYCArIGNhc3RNc2c7XG4gIH1cbn07XG5sZXQgc3RyaW5nID0ge1xuICBsZW5ndGg6ICcke3BhdGh9IG11c3QgYmUgZXhhY3RseSAke2xlbmd0aH0gY2hhcmFjdGVycycsXG4gIG1pbjogJyR7cGF0aH0gbXVzdCBiZSBhdCBsZWFzdCAke21pbn0gY2hhcmFjdGVycycsXG4gIG1heDogJyR7cGF0aH0gbXVzdCBiZSBhdCBtb3N0ICR7bWF4fSBjaGFyYWN0ZXJzJyxcbiAgbWF0Y2hlczogJyR7cGF0aH0gbXVzdCBtYXRjaCB0aGUgZm9sbG93aW5nOiBcIiR7cmVnZXh9XCInLFxuICBlbWFpbDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIGVtYWlsJyxcbiAgdXJsOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgVVJMJyxcbiAgdXVpZDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIFVVSUQnLFxuICB0cmltOiAnJHtwYXRofSBtdXN0IGJlIGEgdHJpbW1lZCBzdHJpbmcnLFxuICBsb3dlcmNhc2U6ICcke3BhdGh9IG11c3QgYmUgYSBsb3dlcmNhc2Ugc3RyaW5nJyxcbiAgdXBwZXJjYXNlOiAnJHtwYXRofSBtdXN0IGJlIGEgdXBwZXIgY2FzZSBzdHJpbmcnXG59O1xubGV0IG51bWJlciA9IHtcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fScsXG4gIGxlc3NUaGFuOiAnJHtwYXRofSBtdXN0IGJlIGxlc3MgdGhhbiAke2xlc3N9JyxcbiAgbW9yZVRoYW46ICcke3BhdGh9IG11c3QgYmUgZ3JlYXRlciB0aGFuICR7bW9yZX0nLFxuICBwb3NpdGl2ZTogJyR7cGF0aH0gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gIG5lZ2F0aXZlOiAnJHtwYXRofSBtdXN0IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyxcbiAgaW50ZWdlcjogJyR7cGF0aH0gbXVzdCBiZSBhbiBpbnRlZ2VyJ1xufTtcbmxldCBkYXRlID0ge1xuICBtaW46ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgbGF0ZXIgdGhhbiAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgYXQgZWFybGllciB0aGFuICR7bWF4fSdcbn07XG5sZXQgYm9vbGVhbiA9IHtcbiAgaXNWYWx1ZTogJyR7cGF0aH0gZmllbGQgbXVzdCBiZSAke3ZhbHVlfSdcbn07XG5sZXQgb2JqZWN0ID0ge1xuICBub1Vua25vd246ICcke3BhdGh9IGZpZWxkIGhhcyB1bnNwZWNpZmllZCBrZXlzOiAke3Vua25vd259J1xufTtcbmxldCBhcnJheSA9IHtcbiAgbWluOiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgYXQgbGVhc3QgJHttaW59IGl0ZW1zJyxcbiAgbWF4OiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fSBpdGVtcycsXG4gIGxlbmd0aDogJyR7cGF0aH0gbXVzdCBoYXZlICR7bGVuZ3RofSBpdGVtcydcbn07XG5sZXQgdHVwbGUgPSB7XG4gIG5vdFR5cGU6IHBhcmFtcyA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlLFxuICAgICAgc3BlY1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZUxlbiA9IHNwZWMudHlwZXMubGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHR5cGVMZW4pIHJldHVybiBgJHtwYXRofSB0dXBsZSB2YWx1ZSBoYXMgdG9vIGZldyBpdGVtcywgZXhwZWN0ZWQgYSBsZW5ndGggb2YgJHt0eXBlTGVufSBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBmb3IgdmFsdWU6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYDtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiB0eXBlTGVuKSByZXR1cm4gYCR7cGF0aH0gdHVwbGUgdmFsdWUgaGFzIHRvbyBtYW55IGl0ZW1zLCBleHBlY3RlZCBhIGxlbmd0aCBvZiAke3R5cGVMZW59IGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGZvciB2YWx1ZTogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG1peGVkLm5vdFR5cGUsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgbG9jYWxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIG1peGVkLFxuICBzdHJpbmcsXG4gIG51bWJlcixcbiAgZGF0ZSxcbiAgb2JqZWN0LFxuICBhcnJheSxcbiAgYm9vbGVhblxufSk7XG5cbmNvbnN0IGlzU2NoZW1hID0gb2JqID0+IG9iaiAmJiBvYmouX19pc1l1cFNjaGVtYV9fO1xuXG5jbGFzcyBDb25kaXRpb24ge1xuICBzdGF0aWMgZnJvbU9wdGlvbnMocmVmcywgY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcudGhlbiAmJiAhY29uZmlnLm90aGVyd2lzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignZWl0aGVyIGB0aGVuOmAgb3IgYG90aGVyd2lzZTpgIGlzIHJlcXVpcmVkIGZvciBgd2hlbigpYCBjb25kaXRpb25zJyk7XG4gICAgbGV0IHtcbiAgICAgIGlzLFxuICAgICAgdGhlbixcbiAgICAgIG90aGVyd2lzZVxuICAgIH0gPSBjb25maWc7XG4gICAgbGV0IGNoZWNrID0gdHlwZW9mIGlzID09PSAnZnVuY3Rpb24nID8gaXMgOiAoLi4udmFsdWVzKSA9PiB2YWx1ZXMuZXZlcnkodmFsdWUgPT4gdmFsdWUgPT09IGlzKTtcbiAgICByZXR1cm4gbmV3IENvbmRpdGlvbihyZWZzLCAodmFsdWVzLCBzY2hlbWEpID0+IHtcbiAgICAgIHZhciBfYnJhbmNoO1xuICAgICAgbGV0IGJyYW5jaCA9IGNoZWNrKC4uLnZhbHVlcykgPyB0aGVuIDogb3RoZXJ3aXNlO1xuICAgICAgcmV0dXJuIChfYnJhbmNoID0gYnJhbmNoID09IG51bGwgPyB2b2lkIDAgOiBicmFuY2goc2NoZW1hKSkgIT0gbnVsbCA/IF9icmFuY2ggOiBzY2hlbWE7XG4gICAgfSk7XG4gIH1cbiAgY29uc3RydWN0b3IocmVmcywgYnVpbGRlcikge1xuICAgIHRoaXMuZm4gPSB2b2lkIDA7XG4gICAgdGhpcy5yZWZzID0gcmVmcztcbiAgICB0aGlzLnJlZnMgPSByZWZzO1xuICAgIHRoaXMuZm4gPSBidWlsZGVyO1xuICB9XG4gIHJlc29sdmUoYmFzZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZXMgPSB0aGlzLnJlZnMubWFwKHJlZiA9PlxuICAgIC8vIFRPRE86ID8gb3BlcmF0b3IgaGVyZT9cbiAgICByZWYuZ2V0VmFsdWUob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy52YWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCkpO1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLmZuKHZhbHVlcywgYmFzZSwgb3B0aW9ucyk7XG4gICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgLy8gQHRzLWlnbm9yZSB0aGlzIGNhbiBiZSBiYXNlXG4gICAgc2NoZW1hID09PSBiYXNlKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgaWYgKCFpc1NjaGVtYShzY2hlbWEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb25kaXRpb25zIG11c3QgcmV0dXJuIGEgc2NoZW1hIG9iamVjdCcpO1xuICAgIHJldHVybiBzY2hlbWEucmVzb2x2ZShvcHRpb25zKTtcbiAgfVxufVxuXG5jb25zdCBwcmVmaXhlcyA9IHtcbiAgY29udGV4dDogJyQnLFxuICB2YWx1ZTogJy4nXG59O1xuZnVuY3Rpb24gY3JlYXRlJDkoa2V5LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVmZXJlbmNlKGtleSwgb3B0aW9ucyk7XG59XG5jbGFzcyBSZWZlcmVuY2Uge1xuICBjb25zdHJ1Y3RvcihrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNDb250ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNWYWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzU2libGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy5nZXR0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWYgbXVzdCBiZSBhIHN0cmluZywgZ290OiAnICsga2V5KTtcbiAgICB0aGlzLmtleSA9IGtleS50cmltKCk7XG4gICAgaWYgKGtleSA9PT0gJycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIHRoaXMuaXNDb250ZXh0ID0gdGhpcy5rZXlbMF0gPT09IHByZWZpeGVzLmNvbnRleHQ7XG4gICAgdGhpcy5pc1ZhbHVlID0gdGhpcy5rZXlbMF0gPT09IHByZWZpeGVzLnZhbHVlO1xuICAgIHRoaXMuaXNTaWJsaW5nID0gIXRoaXMuaXNDb250ZXh0ICYmICF0aGlzLmlzVmFsdWU7XG4gICAgbGV0IHByZWZpeCA9IHRoaXMuaXNDb250ZXh0ID8gcHJlZml4ZXMuY29udGV4dCA6IHRoaXMuaXNWYWx1ZSA/IHByZWZpeGVzLnZhbHVlIDogJyc7XG4gICAgdGhpcy5wYXRoID0gdGhpcy5rZXkuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgdGhpcy5nZXR0ZXIgPSB0aGlzLnBhdGggJiYgZ2V0dGVyKHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgdGhpcy5tYXAgPSBvcHRpb25zLm1hcDtcbiAgfVxuICBnZXRWYWx1ZSh2YWx1ZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaXNDb250ZXh0ID8gY29udGV4dCA6IHRoaXMuaXNWYWx1ZSA/IHZhbHVlIDogcGFyZW50O1xuICAgIGlmICh0aGlzLmdldHRlcikgcmVzdWx0ID0gdGhpcy5nZXR0ZXIocmVzdWx0IHx8IHt9KTtcbiAgICBpZiAodGhpcy5tYXApIHJlc3VsdCA9IHRoaXMubWFwKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5jb250ZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5wYXJlbnRcbiAgICovXG4gIGNhc3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCk7XG4gIH1cbiAgcmVzb2x2ZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXNjcmliZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3JlZicsXG4gICAgICBrZXk6IHRoaXMua2V5XG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFJlZigke3RoaXMua2V5fSlgO1xuICB9XG4gIHN0YXRpYyBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5fX2lzWXVwUmVmO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcblJlZmVyZW5jZS5wcm90b3R5cGUuX19pc1l1cFJlZiA9IHRydWU7XG5cbmNvbnN0IGlzQWJzZW50ID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbDtcblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdGlvbihjb25maWcpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUoe1xuICAgIHZhbHVlLFxuICAgIHBhdGggPSAnJyxcbiAgICBvcHRpb25zLFxuICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgc2NoZW1hXG4gIH0sIHBhbmljLCBuZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHRlc3QsXG4gICAgICBwYXJhbXMsXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2tpcEFic2VudFxuICAgIH0gPSBjb25maWc7XG4gICAgbGV0IHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBhYm9ydEVhcmx5ID0gc2NoZW1hLnNwZWMuYWJvcnRFYXJseVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIHJlc29sdmUoaXRlbSkge1xuICAgICAgcmV0dXJuIFJlZmVyZW5jZS5pc1JlZihpdGVtKSA/IGl0ZW0uZ2V0VmFsdWUodmFsdWUsIHBhcmVudCwgY29udGV4dCkgOiBpdGVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFcnJvcihvdmVycmlkZXMgPSB7fSkge1xuICAgICAgY29uc3QgbmV4dFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgbGFiZWw6IHNjaGVtYS5zcGVjLmxhYmVsLFxuICAgICAgICBwYXRoOiBvdmVycmlkZXMucGF0aCB8fCBwYXRoLFxuICAgICAgICBzcGVjOiBzY2hlbWEuc3BlY1xuICAgICAgfSwgcGFyYW1zLCBvdmVycmlkZXMucGFyYW1zKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5leHRQYXJhbXMpKSBuZXh0UGFyYW1zW2tleV0gPSByZXNvbHZlKG5leHRQYXJhbXNba2V5XSk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG92ZXJyaWRlcy5tZXNzYWdlIHx8IG1lc3NhZ2UsIG5leHRQYXJhbXMpLCB2YWx1ZSwgbmV4dFBhcmFtcy5wYXRoLCBvdmVycmlkZXMudHlwZSB8fCBuYW1lKTtcbiAgICAgIGVycm9yLnBhcmFtcyA9IG5leHRQYXJhbXM7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGludmFsaWQgPSBhYm9ydEVhcmx5ID8gcGFuaWMgOiBuZXh0O1xuICAgIGxldCBjdHggPSB7XG4gICAgICBwYXRoLFxuICAgICAgcGFyZW50LFxuICAgICAgdHlwZTogbmFtZSxcbiAgICAgIGZyb206IG9wdGlvbnMuZnJvbSxcbiAgICAgIGNyZWF0ZUVycm9yLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgc2NoZW1hXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVSZXN1bHQgPSB2YWxpZE9yRXJyb3IgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKHZhbGlkT3JFcnJvcikpIGludmFsaWQodmFsaWRPckVycm9yKTtlbHNlIGlmICghdmFsaWRPckVycm9yKSBpbnZhbGlkKGNyZWF0ZUVycm9yKCkpO2Vsc2UgbmV4dChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gZXJyID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSBpbnZhbGlkKGVycik7ZWxzZSBwYW5pYyhlcnIpO1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkU2tpcCA9IHNraXBBYnNlbnQgJiYgaXNBYnNlbnQodmFsdWUpO1xuICAgIGlmICghb3B0aW9ucy5zeW5jKSB7XG4gICAgICB0cnkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoIXNob3VsZFNraXAgPyB0ZXN0LmNhbGwoY3R4LCB2YWx1ZSwgY3R4KSA6IHRydWUpLnRoZW4oaGFuZGxlUmVzdWx0LCBoYW5kbGVFcnJvcik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICByZXN1bHQgPSAhc2hvdWxkU2tpcCA/IHRlc3QuY2FsbChjdHgsIHZhbHVlLCBjdHgpIDogdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgKChfcmVzdWx0ID0gcmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdC50aGVuKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRpb24gdGVzdCBvZiB0eXBlOiBcIiR7Y3R4LnR5cGV9XCIgcmV0dXJuZWQgYSBQcm9taXNlIGR1cmluZyBhIHN5bmNocm9ub3VzIHZhbGlkYXRlLiBgICsgYFRoaXMgdGVzdCB3aWxsIGZpbmlzaCBhZnRlciB0aGUgdmFsaWRhdGUgY2FsbCBoYXMgcmV0dXJuZWRgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xuICB9XG4gIHZhbGlkYXRlLk9QVElPTlMgPSBjb25maWc7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW4oc2NoZW1hLCBwYXRoLCB2YWx1ZSwgY29udGV4dCA9IHZhbHVlKSB7XG4gIGxldCBwYXJlbnQsIGxhc3RQYXJ0LCBsYXN0UGFydERlYnVnO1xuXG4gIC8vIHJvb3QgcGF0aDogJydcbiAgaWYgKCFwYXRoKSByZXR1cm4ge1xuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoOiBwYXRoLFxuICAgIHNjaGVtYVxuICB9O1xuICBmb3JFYWNoKHBhdGgsIChfcGFydCwgaXNCcmFja2V0LCBpc0FycmF5KSA9PiB7XG4gICAgbGV0IHBhcnQgPSBpc0JyYWNrZXQgPyBfcGFydC5zbGljZSgxLCBfcGFydC5sZW5ndGggLSAxKSA6IF9wYXJ0O1xuICAgIHNjaGVtYSA9IHNjaGVtYS5yZXNvbHZlKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBwYXJlbnQsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIGxldCBpc1R1cGxlID0gc2NoZW1hLnR5cGUgPT09ICd0dXBsZSc7XG4gICAgbGV0IGlkeCA9IGlzQXJyYXkgPyBwYXJzZUludChwYXJ0LCAxMCkgOiAwO1xuICAgIGlmIChzY2hlbWEuaW5uZXJUeXBlIHx8IGlzVHVwbGUpIHtcbiAgICAgIGlmIChpc1R1cGxlICYmICFpc0FycmF5KSB0aHJvdyBuZXcgRXJyb3IoYFl1cC5yZWFjaCBjYW5ub3QgaW1wbGljaXRseSBpbmRleCBpbnRvIGEgdHVwbGUgdHlwZS4gdGhlIHBhdGggcGFydCBcIiR7bGFzdFBhcnREZWJ1Z31cIiBtdXN0IGNvbnRhaW4gYW4gaW5kZXggdG8gdGhlIHR1cGxlIGVsZW1lbnQsIGUuZy4gXCIke2xhc3RQYXJ0RGVidWd9WzBdXCJgKTtcbiAgICAgIGlmICh2YWx1ZSAmJiBpZHggPj0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWXVwLnJlYWNoIGNhbm5vdCByZXNvbHZlIGFuIGFycmF5IGl0ZW0gYXQgaW5kZXg6ICR7X3BhcnR9LCBpbiB0aGUgcGF0aDogJHtwYXRofS4gYCArIGBiZWNhdXNlIHRoZXJlIGlzIG5vIHZhbHVlIGF0IHRoYXQgaW5kZXguIGApO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlW2lkeF07XG4gICAgICBzY2hlbWEgPSBpc1R1cGxlID8gc2NoZW1hLnNwZWMudHlwZXNbaWR4XSA6IHNjaGVtYS5pbm5lclR5cGU7XG4gICAgfVxuXG4gICAgLy8gc29tZXRpbWVzIHRoZSBhcnJheSBpbmRleCBwYXJ0IG9mIGEgcGF0aCBkb2Vzbid0IGV4aXN0OiBcIm5lc3RlZC5hcnIuY2hpbGRcIlxuICAgIC8vIGluIHRoZXNlIGNhc2VzIHRoZSBjdXJyZW50IHBhcnQgaXMgdGhlIG5leHQgc2NoZW1hIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkXG4gICAgLy8gaW4gdGhpcyBpdGVyYXRpb24uIEZvciBjYXNlcyB3aGVyZSB0aGUgaW5kZXggc2lnbmF0dXJlIGlzIGluY2x1ZGVkIHRoaXNcbiAgICAvLyBjaGVjayB3aWxsIGZhaWwgYW5kIHdlJ2xsIGhhbmRsZSB0aGUgYGNoaWxkYCBwYXJ0IG9uIHRoZSBuZXh0IGl0ZXJhdGlvbiBsaWtlIG5vcm1hbFxuICAgIGlmICghaXNBcnJheSkge1xuICAgICAgaWYgKCFzY2hlbWEuZmllbGRzIHx8ICFzY2hlbWEuZmllbGRzW3BhcnRdKSB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzY2hlbWEgZG9lcyBub3QgY29udGFpbiB0aGUgcGF0aDogJHtwYXRofS4gYCArIGAoZmFpbGVkIGF0OiAke2xhc3RQYXJ0RGVidWd9IHdoaWNoIGlzIGEgdHlwZTogXCIke3NjaGVtYS50eXBlfVwiKWApO1xuICAgICAgcGFyZW50ID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlW3BhcnRdO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmZpZWxkc1twYXJ0XTtcbiAgICB9XG4gICAgbGFzdFBhcnQgPSBwYXJ0O1xuICAgIGxhc3RQYXJ0RGVidWcgPSBpc0JyYWNrZXQgPyAnWycgKyBfcGFydCArICddJyA6ICcuJyArIF9wYXJ0O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWEsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGg6IGxhc3RQYXJ0XG4gIH07XG59XG5mdW5jdGlvbiByZWFjaChvYmosIHBhdGgsIHZhbHVlLCBjb250ZXh0KSB7XG4gIHJldHVybiBnZXRJbihvYmosIHBhdGgsIHZhbHVlLCBjb250ZXh0KS5zY2hlbWE7XG59XG5cbmNsYXNzIFJlZmVyZW5jZVNldCBleHRlbmRzIFNldCB7XG4gIGRlc2NyaWJlKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goUmVmZXJlbmNlLmlzUmVmKGl0ZW0pID8gaXRlbS5kZXNjcmliZSgpIDogaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgfVxuICByZXNvbHZlQWxsKHJlc29sdmUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHJlc29sdmUoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlU2V0KHRoaXMudmFsdWVzKCkpO1xuICB9XG4gIG1lcmdlKG5ld0l0ZW1zLCByZW1vdmVJdGVtcykge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV3SXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiBuZXh0LmFkZCh2YWx1ZSkpO1xuICAgIHJlbW92ZUl0ZW1zLmZvckVhY2godmFsdWUgPT4gbmV4dC5kZWxldGUodmFsdWUpKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufVxuXG4vLyB0d2Vha2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0tlbGluMjAyNS9uYW5vY2xvbmUvYmxvYi8wYWJlYjc2MzViZGE5YjY4ZWYyMjc3MDkzZjc2ZGJlM2JmMzk0OGUxL3NyYy9pbmRleC5qc1xuZnVuY3Rpb24gY2xvbmUoc3JjLCBzZWVuID0gbmV3IE1hcCgpKSB7XG4gIGlmIChpc1NjaGVtYShzcmMpIHx8ICFzcmMgfHwgdHlwZW9mIHNyYyAhPT0gJ29iamVjdCcpIHJldHVybiBzcmM7XG4gIGlmIChzZWVuLmhhcyhzcmMpKSByZXR1cm4gc2Vlbi5nZXQoc3JjKTtcbiAgbGV0IGNvcHk7XG4gIGlmIChzcmMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgLy8gRGF0ZVxuICAgIGNvcHkgPSBuZXcgRGF0ZShzcmMuZ2V0VGltZSgpKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIFJlZ0V4cFxuICAgIGNvcHkgPSBuZXcgUmVnRXhwKHNyYyk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAvLyBBcnJheVxuICAgIGNvcHkgPSBuZXcgQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykgY29weVtpXSA9IGNsb25lKHNyY1tpXSwgc2Vlbik7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgLy8gTWFwXG4gICAgY29weSA9IG5ldyBNYXAoKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHNyYy5lbnRyaWVzKCkpIGNvcHkuc2V0KGssIGNsb25lKHYsIHNlZW4pKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAvLyBTZXRcbiAgICBjb3B5ID0gbmV3IFNldCgpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCB2IG9mIHNyYykgY29weS5hZGQoY2xvbmUodiwgc2VlbikpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8vIE9iamVjdFxuICAgIGNvcHkgPSB7fTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNyYykpIGNvcHlba10gPSBjbG9uZSh2LCBzZWVuKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGNsb25lICR7c3JjfWApO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG5jbGFzcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMudGVzdHMgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZGl0aW9ucyA9IFtdO1xuICAgIHRoaXMuX211dGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVybmFsVGVzdHMgPSB7fTtcbiAgICB0aGlzLl93aGl0ZWxpc3QgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgdGhpcy5fYmxhY2tsaXN0ID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgIHRoaXMuZXhjbHVzaXZlVGVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3R5cGVDaGVjayA9IHZvaWQgMDtcbiAgICB0aGlzLnNwZWMgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXN0cyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHlwZUVycm9yKG1peGVkLm5vdFR5cGUpO1xuICAgIH0pO1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB0aGlzLl90eXBlQ2hlY2sgPSBvcHRpb25zLmNoZWNrO1xuICAgIHRoaXMuc3BlYyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgc3RyaXA6IGZhbHNlLFxuICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgIGFib3J0RWFybHk6IHRydWUsXG4gICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICBudWxsYWJsZTogZmFsc2UsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGNvZXJjZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3BlYyk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24ocyA9PiB7XG4gICAgICBzLm5vbk51bGxhYmxlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiByZW1vdmVcbiAgZ2V0IF90eXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGlmICh0aGlzLl9tdXRhdGUpIHtcbiAgICAgIGlmIChzcGVjKSBPYmplY3QuYXNzaWduKHRoaXMuc3BlYywgc3BlYyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbmVzdGVkIHZhbHVlIGlzIGEgc2NoZW1hIHdlIGNhbiBza2lwIGNsb25pbmcsIHNpbmNlXG4gICAgLy8gdGhleSBhcmUgYWxyZWFkeSBpbW11dGFibGVcbiAgICBjb25zdCBuZXh0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIHJlYWRvbmx5XG4gICAgbmV4dC50eXBlID0gdGhpcy50eXBlO1xuICAgIG5leHQuX3R5cGVDaGVjayA9IHRoaXMuX3R5cGVDaGVjaztcbiAgICBuZXh0Ll93aGl0ZWxpc3QgPSB0aGlzLl93aGl0ZWxpc3QuY2xvbmUoKTtcbiAgICBuZXh0Ll9ibGFja2xpc3QgPSB0aGlzLl9ibGFja2xpc3QuY2xvbmUoKTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmludGVybmFsVGVzdHMpO1xuICAgIG5leHQuZXhjbHVzaXZlVGVzdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmV4Y2x1c2l2ZVRlc3RzKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyByZWFkb25seVxuICAgIG5leHQuZGVwcyA9IFsuLi50aGlzLmRlcHNdO1xuICAgIG5leHQuY29uZGl0aW9ucyA9IFsuLi50aGlzLmNvbmRpdGlvbnNdO1xuICAgIG5leHQudGVzdHMgPSBbLi4udGhpcy50ZXN0c107XG4gICAgbmV4dC50cmFuc2Zvcm1zID0gWy4uLnRoaXMudHJhbnNmb3Jtc107XG4gICAgbmV4dC5zcGVjID0gY2xvbmUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zcGVjLCBzcGVjKSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbGFiZWwobGFiZWwpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMubGFiZWwgPSBsYWJlbDtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBtZXRhKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnNwZWMubWV0YTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMubWV0YSA9IE9iamVjdC5hc3NpZ24obmV4dC5zcGVjLm1ldGEgfHwge30sIGFyZ3NbMF0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHdpdGhNdXRhdGlvbihmbikge1xuICAgIGxldCBiZWZvcmUgPSB0aGlzLl9tdXRhdGU7XG4gICAgdGhpcy5fbXV0YXRlID0gdHJ1ZTtcbiAgICBsZXQgcmVzdWx0ID0gZm4odGhpcyk7XG4gICAgdGhpcy5fbXV0YXRlID0gYmVmb3JlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uY2F0KHNjaGVtYSkge1xuICAgIGlmICghc2NoZW1hIHx8IHNjaGVtYSA9PT0gdGhpcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHNjaGVtYS50eXBlICE9PSB0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgY2Fubm90IFxcYGNvbmNhdCgpXFxgIHNjaGVtYSdzIG9mIGRpZmZlcmVudCB0eXBlczogJHt0aGlzLnR5cGV9IGFuZCAke3NjaGVtYS50eXBlfWApO1xuICAgIGxldCBiYXNlID0gdGhpcztcbiAgICBsZXQgY29tYmluZWQgPSBzY2hlbWEuY2xvbmUoKTtcbiAgICBjb25zdCBtZXJnZWRTcGVjID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZS5zcGVjLCBjb21iaW5lZC5zcGVjKTtcbiAgICBjb21iaW5lZC5zcGVjID0gbWVyZ2VkU3BlYztcbiAgICBjb21iaW5lZC5pbnRlcm5hbFRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZS5pbnRlcm5hbFRlc3RzLCBjb21iaW5lZC5pbnRlcm5hbFRlc3RzKTtcblxuICAgIC8vIG1hbnVhbGx5IG1lcmdlIHRoZSBibGFja2xpc3Qvd2hpdGVsaXN0ICh0aGUgb3RoZXIgYHNjaGVtYWAgdGFrZXNcbiAgICAvLyBwcmVjZWRlbmNlIGluIGNhc2Ugb2YgY29uZmxpY3RzKVxuICAgIGNvbWJpbmVkLl93aGl0ZWxpc3QgPSBiYXNlLl93aGl0ZWxpc3QubWVyZ2Uoc2NoZW1hLl93aGl0ZWxpc3QsIHNjaGVtYS5fYmxhY2tsaXN0KTtcbiAgICBjb21iaW5lZC5fYmxhY2tsaXN0ID0gYmFzZS5fYmxhY2tsaXN0Lm1lcmdlKHNjaGVtYS5fYmxhY2tsaXN0LCBzY2hlbWEuX3doaXRlbGlzdCk7XG5cbiAgICAvLyBzdGFydCB3aXRoIHRoZSBjdXJyZW50IHRlc3RzXG4gICAgY29tYmluZWQudGVzdHMgPSBiYXNlLnRlc3RzO1xuICAgIGNvbWJpbmVkLmV4Y2x1c2l2ZVRlc3RzID0gYmFzZS5leGNsdXNpdmVUZXN0cztcblxuICAgIC8vIG1hbnVhbGx5IGFkZCB0aGUgbmV3IHRlc3RzIHRvIGVuc3VyZVxuICAgIC8vIHRoZSBkZWR1cGluZyBsb2dpYyBpcyBjb25zaXN0ZW50XG4gICAgY29tYmluZWQud2l0aE11dGF0aW9uKG5leHQgPT4ge1xuICAgICAgc2NoZW1hLnRlc3RzLmZvckVhY2goZm4gPT4ge1xuICAgICAgICBuZXh0LnRlc3QoZm4uT1BUSU9OUyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb21iaW5lZC50cmFuc2Zvcm1zID0gWy4uLmJhc2UudHJhbnNmb3JtcywgLi4uY29tYmluZWQudHJhbnNmb3Jtc107XG4gICAgcmV0dXJuIGNvbWJpbmVkO1xuICB9XG4gIGlzVHlwZSh2KSB7XG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuc3BlYy5udWxsYWJsZSAmJiB2ID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnNwZWMub3B0aW9uYWwgJiYgdiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVDaGVjayh2KTtcbiAgfVxuICByZXNvbHZlKG9wdGlvbnMpIHtcbiAgICBsZXQgc2NoZW1hID0gdGhpcztcbiAgICBpZiAoc2NoZW1hLmNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBsZXQgY29uZGl0aW9ucyA9IHNjaGVtYS5jb25kaXRpb25zO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gICAgICBzY2hlbWEuY29uZGl0aW9ucyA9IFtdO1xuICAgICAgc2NoZW1hID0gY29uZGl0aW9ucy5yZWR1Y2UoKHByZXZTY2hlbWEsIGNvbmRpdGlvbikgPT4gY29uZGl0aW9uLnJlc29sdmUocHJldlNjaGVtYSwgb3B0aW9ucyksIHNjaGVtYSk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEucmVzb2x2ZShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICByZXNvbHZlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJHN0cmljdCwgX29wdGlvbnMkYWJvcnRFYXJseSwgX29wdGlvbnMkcmVjdXJzaXZlO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBmcm9tOiBvcHRpb25zLmZyb20gfHwgW10sXG4gICAgICBzdHJpY3Q6IChfb3B0aW9ucyRzdHJpY3QgPSBvcHRpb25zLnN0cmljdCkgIT0gbnVsbCA/IF9vcHRpb25zJHN0cmljdCA6IHRoaXMuc3BlYy5zdHJpY3QsXG4gICAgICBhYm9ydEVhcmx5OiAoX29wdGlvbnMkYWJvcnRFYXJseSA9IG9wdGlvbnMuYWJvcnRFYXJseSkgIT0gbnVsbCA/IF9vcHRpb25zJGFib3J0RWFybHkgOiB0aGlzLnNwZWMuYWJvcnRFYXJseSxcbiAgICAgIHJlY3Vyc2l2ZTogKF9vcHRpb25zJHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlKSAhPSBudWxsID8gX29wdGlvbnMkcmVjdXJzaXZlIDogdGhpcy5zcGVjLnJlY3Vyc2l2ZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgY29uZmlndXJlZCB0cmFuc2Zvcm0gcGlwZWxpbmUgb3ZlciBhbiBpbnB1dCB2YWx1ZS5cbiAgICovXG5cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHJlc29sdmVkU2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdmFsdWVcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgbGV0IGFsbG93T3B0aW9uYWxpdHkgPSBvcHRpb25zLmFzc2VydCA9PT0gJ2lnbm9yZS1vcHRpb25hbGl0eSc7XG4gICAgbGV0IHJlc3VsdCA9IHJlc29sdmVkU2NoZW1hLl9jYXN0KHZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5hc3NlcnQgIT09IGZhbHNlICYmICFyZXNvbHZlZFNjaGVtYS5pc1R5cGUocmVzdWx0KSkge1xuICAgICAgaWYgKGFsbG93T3B0aW9uYWxpdHkgJiYgaXNBYnNlbnQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gcHJpbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICBsZXQgZm9ybWF0dGVkUmVzdWx0ID0gcHJpbnRWYWx1ZShyZXN1bHQpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHZhbHVlIG9mICR7b3B0aW9ucy5wYXRoIHx8ICdmaWVsZCd9IGNvdWxkIG5vdCBiZSBjYXN0IHRvIGEgdmFsdWUgYCArIGB0aGF0IHNhdGlzZmllcyB0aGUgc2NoZW1hIHR5cGU6IFwiJHtyZXNvbHZlZFNjaGVtYS50eXBlfVwiLiBcXG5cXG5gICsgYGF0dGVtcHRlZCB2YWx1ZTogJHtmb3JtYXR0ZWRWYWx1ZX0gXFxuYCArIChmb3JtYXR0ZWRSZXN1bHQgIT09IGZvcm1hdHRlZFZhbHVlID8gYHJlc3VsdCBvZiBjYXN0OiAke2Zvcm1hdHRlZFJlc3VsdH1gIDogJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2FzdChyYXdWYWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZSA9IHJhd1ZhbHVlID09PSB1bmRlZmluZWQgPyByYXdWYWx1ZSA6IHRoaXMudHJhbnNmb3Jtcy5yZWR1Y2UoKHByZXZWYWx1ZSwgZm4pID0+IGZuLmNhbGwodGhpcywgcHJldlZhbHVlLCByYXdWYWx1ZSwgdGhpcyksIHJhd1ZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldERlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBvcmlnaW5hbFZhbHVlID0gX3ZhbHVlLFxuICAgICAgc3RyaWN0ID0gdGhpcy5zcGVjLnN0cmljdFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCB2YWx1ZSA9IF92YWx1ZTtcbiAgICBpZiAoIXN0cmljdCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jYXN0KHZhbHVlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYXNzZXJ0OiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBsZXQgaW5pdGlhbFRlc3RzID0gW107XG4gICAgZm9yIChsZXQgdGVzdCBvZiBPYmplY3QudmFsdWVzKHRoaXMuaW50ZXJuYWxUZXN0cykpIHtcbiAgICAgIGlmICh0ZXN0KSBpbml0aWFsVGVzdHMucHVzaCh0ZXN0KTtcbiAgICB9XG4gICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICBwYXRoLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHRlc3RzOiBpbml0aWFsVGVzdHNcbiAgICB9LCBwYW5pYywgaW5pdGlhbEVycm9ycyA9PiB7XG4gICAgICAvLyBldmVuIGlmIHdlIGFyZW4ndCBlbmRpbmcgZWFybHkgd2UgY2FuJ3QgcHJvY2VlZCBmdXJ0aGVyIGlmIHRoZSB0eXBlcyBhcmVuJ3QgY29ycmVjdFxuICAgICAgaWYgKGluaXRpYWxFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGluaXRpYWxFcnJvcnMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICBwYXRoLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdGVzdHM6IHRoaXMudGVzdHNcbiAgICAgIH0sIHBhbmljLCBuZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHNldCBvZiB2YWxpZGF0aW9ucywgZWl0aGVyIHNjaGVtYSwgcHJvZHVjZWQgVGVzdHMgb3IgYSBuZXN0ZWRcbiAgICogc2NoZW1hIHZhbGlkYXRlIHJlc3VsdC5cbiAgICovXG4gIHJ1blRlc3RzKHJ1bk9wdGlvbnMsIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IGZpcmVkID0gZmFsc2U7XG4gICAgbGV0IHtcbiAgICAgIHRlc3RzLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gcnVuT3B0aW9ucztcbiAgICBsZXQgcGFuaWNPbmNlID0gYXJnID0+IHtcbiAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgcGFuaWMoYXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBsZXQgbmV4dE9uY2UgPSBhcmcgPT4ge1xuICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBuZXh0KGFyZywgdmFsdWUpO1xuICAgIH07XG4gICAgbGV0IGNvdW50ID0gdGVzdHMubGVuZ3RoO1xuICAgIGxldCBuZXN0ZWRFcnJvcnMgPSBbXTtcbiAgICBpZiAoIWNvdW50KSByZXR1cm4gbmV4dE9uY2UoW10pO1xuICAgIGxldCBhcmdzID0ge1xuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBzY2hlbWE6IHRoaXNcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tpXTtcbiAgICAgIHRlc3QoYXJncywgcGFuaWNPbmNlLCBmdW5jdGlvbiBmaW5pc2hUZXN0UnVuKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbmVzdGVkRXJyb3JzID0gbmVzdGVkRXJyb3JzLmNvbmNhdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgtLWNvdW50IDw9IDApIHtcbiAgICAgICAgICBuZXh0T25jZShuZXN0ZWRFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXNOZXN0ZWRUZXN0KHtcbiAgICBrZXksXG4gICAgaW5kZXgsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGgsXG4gICAgb3JpZ2luYWxQYXJlbnQsXG4gICAgb3B0aW9uc1xuICB9KSB7XG4gICAgY29uc3QgayA9IGtleSAhPSBudWxsID8ga2V5IDogaW5kZXg7XG4gICAgaWYgKGsgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdNdXN0IGluY2x1ZGUgYGtleWAgb3IgYGluZGV4YCBmb3IgbmVzdGVkIHZhbGlkYXRpb25zJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzSW5kZXggPSB0eXBlb2YgayA9PT0gJ251bWJlcic7XG4gICAgbGV0IHZhbHVlID0gcGFyZW50W2tdO1xuICAgIGNvbnN0IHRlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgLy8gTmVzdGVkIHZhbGlkYXRpb25zIGZpZWxkcyBhcmUgYWx3YXlzIHN0cmljdDpcbiAgICAgIC8vICAgIDEuIHBhcmVudCBpc24ndCBzdHJpY3Qgc28gdGhlIGNhc3Rpbmcgd2lsbCBhbHNvIGhhdmUgY2FzdCBpbm5lciB2YWx1ZXNcbiAgICAgIC8vICAgIDIuIHBhcmVudCBpcyBzdHJpY3QgaW4gd2hpY2ggY2FzZSB0aGUgbmVzdGVkIHZhbHVlcyB3ZXJlbid0IGNhc3QgZWl0aGVyXG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBwYXJlbnQsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9yaWdpbmFsVmFsdWU6IG9yaWdpbmFsUGFyZW50W2tdLFxuICAgICAgLy8gRklYTUU6IHRlc3RzIGRlcGVuZCBvbiBgaW5kZXhgIGJlaW5nIHBhc3NlZCBhcm91bmQgZGVlcGx5LFxuICAgICAgLy8gICB3ZSBzaG91bGQgbm90IGxldCB0aGUgb3B0aW9ucy5rZXkvaW5kZXggYmxlZWQgdGhyb3VnaFxuICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAvLyBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgW2lzSW5kZXggPyAnaW5kZXgnIDogJ2tleSddOiBrLFxuICAgICAgcGF0aDogaXNJbmRleCB8fCBrLmluY2x1ZGVzKCcuJykgPyBgJHtwYXJlbnRQYXRoIHx8ICcnfVske3ZhbHVlID8gayA6IGBcIiR7a31cImB9XWAgOiAocGFyZW50UGF0aCA/IGAke3BhcmVudFBhdGh9LmAgOiAnJykgKyBrZXlcbiAgICB9KTtcbiAgICByZXR1cm4gKF8sIHBhbmljLCBuZXh0KSA9PiB0aGlzLnJlc29sdmUodGVzdE9wdGlvbnMpLl92YWxpZGF0ZSh2YWx1ZSwgdGVzdE9wdGlvbnMsIHBhbmljLCBuZXh0KTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWVcbiAgICB9KSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNjaGVtYS5fdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMsIChlcnJvciwgcGFyc2VkKSA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyb3IpKSBlcnJvci52YWx1ZSA9IHBhcnNlZDtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSwgKGVycm9ycywgdmFsaWRhdGVkKSA9PiB7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkgcmVqZWN0KG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyb3JzLCB2YWxpZGF0ZWQpKTtlbHNlIHJlc29sdmUodmFsaWRhdGVkKTtcbiAgICB9KSk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB2YWx1ZVxuICAgIH0pKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHNjaGVtYS5fdmFsaWRhdGUodmFsdWUsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHN5bmM6IHRydWVcbiAgICB9KSwgKGVycm9yLCBwYXJzZWQpID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnJvcikpIGVycm9yLnZhbHVlID0gcGFyc2VkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSwgKGVycm9ycywgdmFsaWRhdGVkKSA9PiB7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihlcnJvcnMsIHZhbHVlKTtcbiAgICAgIHJlc3VsdCA9IHZhbGlkYXRlZDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzVmFsaWQodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykudGhlbigoKSA9PiB0cnVlLCBlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuICBpc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIF9nZXREZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gdGhpcy5zcGVjLmRlZmF1bHQ7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRWYWx1ZS5jYWxsKHRoaXMsIG9wdGlvbnMpIDogY2xvbmUoZGVmYXVsdFZhbHVlKTtcbiAgfVxuICBnZXREZWZhdWx0KG9wdGlvbnNcbiAgLy8gSWYgc2NoZW1hIGlzIGRlZmF1bHRlZCB3ZSBrbm93IGl0J3MgYXQgbGVhc3Qgbm90IHVuZGVmaW5lZFxuICApIHtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKG9wdGlvbnMgfHwge30pO1xuICAgIHJldHVybiBzY2hlbWEuX2dldERlZmF1bHQob3B0aW9ucyk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldERlZmF1bHQoKTtcbiAgICB9XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIGRlZmF1bHQ6IGRlZlxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHN0cmljdChpc1N0cmljdCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7XG4gICAgICBzdHJpY3Q6IGlzU3RyaWN0XG4gICAgfSk7XG4gIH1cbiAgbnVsbGFiaWxpdHkobnVsbGFibGUsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBudWxsYWJsZVxuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy5udWxsYWJsZSA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdudWxsYWJsZScsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHRoaXMuc2NoZW1hLnNwZWMubnVsbGFibGUgOiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsaXR5KG9wdGlvbmFsLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgb3B0aW9uYWxcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMub3B0aW9uYWxpdHkgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnb3B0aW9uYWxpdHknLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuc2NoZW1hLnNwZWMub3B0aW9uYWwgOiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KHRydWUpO1xuICB9XG4gIGRlZmluZWQobWVzc2FnZSA9IG1peGVkLmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eShmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbiAgbnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFiaWxpdHkodHJ1ZSk7XG4gIH1cbiAgbm9uTnVsbGFibGUobWVzc2FnZSA9IG1peGVkLm5vdE51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5udWxsYWJpbGl0eShmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbiAgcmVxdWlyZWQobWVzc2FnZSA9IG1peGVkLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS53aXRoTXV0YXRpb24obmV4dCA9PiBuZXh0Lm5vbk51bGxhYmxlKG1lc3NhZ2UpLmRlZmluZWQobWVzc2FnZSkpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4gbmV4dC5udWxsYWJsZSgpLm9wdGlvbmFsKCkpO1xuICB9XG4gIHRyYW5zZm9ybShmbikge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQudHJhbnNmb3Jtcy5wdXNoKGZuKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdGVzdCBmdW5jdGlvbiB0byB0aGUgc2NoZW1hJ3MgcXVldWUgb2YgdGVzdHMuXG4gICAqIHRlc3RzIGNhbiBiZSBleGNsdXNpdmUgb3Igbm9uLWV4Y2x1c2l2ZS5cbiAgICpcbiAgICogLSBleGNsdXNpdmUgdGVzdHMsIHdpbGwgcmVwbGFjZSBhbnkgZXhpc3RpbmcgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICogLSBub24tZXhjbHVzaXZlOiBjYW4gYmUgc3RhY2tlZFxuICAgKlxuICAgKiBJZiBhIG5vbi1leGNsdXNpdmUgdGVzdCBpcyBhZGRlZCB0byBhIHNjaGVtYSB3aXRoIGFuIGV4Y2x1c2l2ZSB0ZXN0IG9mIHRoZSBzYW1lIG5hbWVcbiAgICogdGhlIGV4Y2x1c2l2ZSB0ZXN0IGlzIHJlbW92ZWQgYW5kIGZ1cnRoZXIgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZSB3aWxsIGJlIHN0YWNrZWQuXG4gICAqXG4gICAqIElmIGFuIGV4Y2x1c2l2ZSB0ZXN0IGlzIGFkZGVkIHRvIGEgc2NoZW1hIHdpdGggbm9uLWV4Y2x1c2l2ZSB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIHRoZSBwcmV2aW91cyB0ZXN0cyBhcmUgcmVtb3ZlZCBhbmQgZnVydGhlciB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lIHdpbGwgcmVwbGFjZSBlYWNoIG90aGVyLlxuICAgKi9cblxuICB0ZXN0KC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0cztcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgIHRlc3Q6IGFyZ3NbMF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMgPSBhcmdzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIHRlc3Q6IGFyZ3NbMV1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIG1lc3NhZ2U6IGFyZ3NbMV0sXG4gICAgICAgIHRlc3Q6IGFyZ3NbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRzLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCkgb3B0cy5tZXNzYWdlID0gbWl4ZWQuZGVmYXVsdDtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignYHRlc3RgIGlzIGEgcmVxdWlyZWQgcGFyYW1ldGVycycpO1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGxldCB2YWxpZGF0ZSA9IGNyZWF0ZVZhbGlkYXRpb24ob3B0cyk7XG4gICAgbGV0IGlzRXhjbHVzaXZlID0gb3B0cy5leGNsdXNpdmUgfHwgb3B0cy5uYW1lICYmIG5leHQuZXhjbHVzaXZlVGVzdHNbb3B0cy5uYW1lXSA9PT0gdHJ1ZTtcbiAgICBpZiAob3B0cy5leGNsdXNpdmUpIHtcbiAgICAgIGlmICghb3B0cy5uYW1lKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeGNsdXNpdmUgdGVzdHMgbXVzdCBwcm92aWRlIGEgdW5pcXVlIGBuYW1lYCBpZGVudGlmeWluZyB0aGUgdGVzdCcpO1xuICAgIH1cbiAgICBpZiAob3B0cy5uYW1lKSBuZXh0LmV4Y2x1c2l2ZVRlc3RzW29wdHMubmFtZV0gPSAhIW9wdHMuZXhjbHVzaXZlO1xuICAgIG5leHQudGVzdHMgPSBuZXh0LnRlc3RzLmZpbHRlcihmbiA9PiB7XG4gICAgICBpZiAoZm4uT1BUSU9OUy5uYW1lID09PSBvcHRzLm5hbWUpIHtcbiAgICAgICAgaWYgKGlzRXhjbHVzaXZlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChmbi5PUFRJT05TLnRlc3QgPT09IHZhbGlkYXRlLk9QVElPTlMudGVzdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgbmV4dC50ZXN0cy5wdXNoKHZhbGlkYXRlKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB3aGVuKGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykgJiYgdHlwZW9mIGtleXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0ga2V5cztcbiAgICAgIGtleXMgPSAnLic7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGxldCBkZXBzID0gdG9BcnJheShrZXlzKS5tYXAoa2V5ID0+IG5ldyBSZWZlcmVuY2Uoa2V5KSk7XG4gICAgZGVwcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlIHJlYWRvbmx5IGFycmF5XG4gICAgICBpZiAoZGVwLmlzU2libGluZykgbmV4dC5kZXBzLnB1c2goZGVwLmtleSk7XG4gICAgfSk7XG4gICAgbmV4dC5jb25kaXRpb25zLnB1c2godHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBuZXcgQ29uZGl0aW9uKGRlcHMsIG9wdGlvbnMpIDogQ29uZGl0aW9uLmZyb21PcHRpb25zKGRlcHMsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB0eXBlRXJyb3IobWVzc2FnZSkge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy50eXBlRXJyb3IgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAndHlwZUVycm9yJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2hlbWEuX3R5cGVDaGVjayh2YWx1ZSkpIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuc2NoZW1hLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvbmVPZihlbnVtcywgbWVzc2FnZSA9IG1peGVkLm9uZU9mKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgZW51bXMuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgbmV4dC5fd2hpdGVsaXN0LmFkZCh2YWwpO1xuICAgICAgbmV4dC5fYmxhY2tsaXN0LmRlbGV0ZSh2YWwpO1xuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy53aGl0ZUxpc3QgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnb25lT2YnLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbGlkcyA9IHRoaXMuc2NoZW1hLl93aGl0ZWxpc3Q7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHZhbGlkcy5yZXNvbHZlQWxsKHRoaXMucmVzb2x2ZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5pbmNsdWRlcyh2YWx1ZSkgPyB0cnVlIDogdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IEFycmF5LmZyb20odmFsaWRzKS5qb2luKCcsICcpLFxuICAgICAgICAgICAgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG5vdE9uZU9mKGVudW1zLCBtZXNzYWdlID0gbWl4ZWQubm90T25lT2YpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBlbnVtcy5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICBuZXh0Ll9ibGFja2xpc3QuYWRkKHZhbCk7XG4gICAgICBuZXh0Ll93aGl0ZWxpc3QuZGVsZXRlKHZhbCk7XG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLmJsYWNrbGlzdCA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdub3RPbmVPZicsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnZhbGlkcyA9IHRoaXMuc2NoZW1hLl9ibGFja2xpc3Q7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IGludmFsaWRzLnJlc29sdmVBbGwodGhpcy5yZXNvbHZlKTtcbiAgICAgICAgaWYgKHJlc29sdmVkLmluY2x1ZGVzKHZhbHVlKSkgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKGludmFsaWRzKS5qb2luKCcsICcpLFxuICAgICAgICAgICAgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzdHJpcChzdHJpcCA9IHRydWUpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMuc3RyaXAgPSBzdHJpcDtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzZXJpYWxpemVkIGRlc2NyaXB0aW9uIG9mIHRoZSBzY2hlbWEgaW5jbHVkaW5nIHZhbGlkYXRpb25zLCBmbGFncywgdHlwZXMgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBQcm92aWRlIGFueSBuZWVkZWQgY29udGV4dCBmb3IgcmVzb2x2aW5nIHJ1bnRpbWUgc2NoZW1hIGFsdGVyYXRpb25zIChsYXp5LCB3aGVuIGNvbmRpdGlvbnMsIGV0YykuXG4gICAqL1xuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbCxcbiAgICAgIG1ldGEsXG4gICAgICBvcHRpb25hbCxcbiAgICAgIG51bGxhYmxlXG4gICAgfSA9IG5leHQuc3BlYztcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBsYWJlbCxcbiAgICAgIG9wdGlvbmFsLFxuICAgICAgbnVsbGFibGUsXG4gICAgICBkZWZhdWx0OiBuZXh0LmdldERlZmF1bHQob3B0aW9ucyksXG4gICAgICB0eXBlOiBuZXh0LnR5cGUsXG4gICAgICBvbmVPZjogbmV4dC5fd2hpdGVsaXN0LmRlc2NyaWJlKCksXG4gICAgICBub3RPbmVPZjogbmV4dC5fYmxhY2tsaXN0LmRlc2NyaWJlKCksXG4gICAgICB0ZXN0czogbmV4dC50ZXN0cy5tYXAoZm4gPT4gKHtcbiAgICAgICAgbmFtZTogZm4uT1BUSU9OUy5uYW1lLFxuICAgICAgICBwYXJhbXM6IGZuLk9QVElPTlMucGFyYW1zXG4gICAgICB9KSkuZmlsdGVyKChuLCBpZHgsIGxpc3QpID0+IGxpc3QuZmluZEluZGV4KGMgPT4gYy5uYW1lID09PSBuLm5hbWUpID09PSBpZHgpXG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH1cbn1cbi8vIEB0cy1leHBlY3QtZXJyb3JcblNjaGVtYS5wcm90b3R5cGUuX19pc1l1cFNjaGVtYV9fID0gdHJ1ZTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIFsndmFsaWRhdGUnLCAndmFsaWRhdGVTeW5jJ10pIFNjaGVtYS5wcm90b3R5cGVbYCR7bWV0aG9kfUF0YF0gPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGgsXG4gICAgc2NoZW1hXG4gIH0gPSBnZXRJbih0aGlzLCBwYXRoLCB2YWx1ZSwgb3B0aW9ucy5jb250ZXh0KTtcbiAgcmV0dXJuIHNjaGVtYVttZXRob2RdKHBhcmVudCAmJiBwYXJlbnRbcGFyZW50UGF0aF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICBwYXJlbnQsXG4gICAgcGF0aFxuICB9KSk7XG59O1xuZm9yIChjb25zdCBhbGlhcyBvZiBbJ2VxdWFscycsICdpcyddKSBTY2hlbWEucHJvdG90eXBlW2FsaWFzXSA9IFNjaGVtYS5wcm90b3R5cGUub25lT2Y7XG5mb3IgKGNvbnN0IGFsaWFzIG9mIFsnbm90JywgJ25vcGUnXSkgU2NoZW1hLnByb3RvdHlwZVthbGlhc10gPSBTY2hlbWEucHJvdG90eXBlLm5vdE9uZU9mO1xuXG5jb25zdCByZXR1cm5zVHJ1ZSA9ICgpID0+IHRydWU7XG5mdW5jdGlvbiBjcmVhdGUkOChzcGVjKSB7XG4gIHJldHVybiBuZXcgTWl4ZWRTY2hlbWEoc3BlYyk7XG59XG5jbGFzcyBNaXhlZFNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBzdXBlcih0eXBlb2Ygc3BlYyA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogc3BlY1xuICAgIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogcmV0dXJuc1RydWVcbiAgICB9LCBzcGVjKSk7XG4gIH1cbn1cbmNyZWF0ZSQ4LnByb3RvdHlwZSA9IE1peGVkU2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlJDcoKSB7XG4gIHJldHVybiBuZXcgQm9vbGVhblNjaGVtYSgpO1xufVxuY2xhc3MgQm9vbGVhblNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBCb29sZWFuKSB2ID0gdi52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguc3BlYy5jb2VyY2UgJiYgIWN0eC5pc1R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKC9eKHRydWV8MSkkL2kudGVzdChTdHJpbmcodmFsdWUpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKC9eKGZhbHNlfDApJC9pLnRlc3QoU3RyaW5nKHZhbHVlKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpc1RydWUobWVzc2FnZSA9IGJvb2xlYW4uaXNWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdpcy12YWx1ZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgfSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpc0ZhbHNlKG1lc3NhZ2UgPSBib29sZWFuLmlzVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnaXMtdmFsdWUnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiAnZmFsc2UnXG4gICAgICB9LFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWZhdWx0KGRlZikge1xuICAgIHJldHVybiBzdXBlci5kZWZhdWx0KGRlZik7XG4gIH1cbiAgZGVmaW5lZChtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVmaW5lZChtc2cpO1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBzdXBlci5vcHRpb25hbCgpO1xuICB9XG4gIHJlcXVpcmVkKG1zZykge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZChtc2cpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBzdXBlci5ub3RSZXF1aXJlZCgpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci5udWxsYWJsZSgpO1xuICB9XG4gIG5vbk51bGxhYmxlKG1zZykge1xuICAgIHJldHVybiBzdXBlci5ub25OdWxsYWJsZShtc2cpO1xuICB9XG4gIHN0cmlwKHYpIHtcbiAgICByZXR1cm4gc3VwZXIuc3RyaXAodik7XG4gIH1cbn1cbmNyZWF0ZSQ3LnByb3RvdHlwZSA9IEJvb2xlYW5TY2hlbWEucHJvdG90eXBlO1xuXG4vLyBUYWtlbiBmcm9tIEhUTUwgc3BlYzogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xubGV0IHJFbWFpbCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xubGV0IHJVcmwgPVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vXigoaHR0cHM/fGZ0cCk6KT9cXC9cXC8oKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OikqQCk/KCgoXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pKXwoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4/KSg6XFxkKik/KShcXC8oKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKyhcXC8oKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkqKSopPyk/KFxcPygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8W1xcdUUwMDAtXFx1RjhGRl18XFwvfFxcPykqKT8oXFwjKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxcXC98XFw/KSopPyQvaTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5sZXQgclVVSUQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5sZXQgaXNUcmltbWVkID0gdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50cmltKCk7XG5sZXQgb2JqU3RyaW5nVGFnID0ge30udG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGNyZWF0ZSQ2KCkge1xuICByZXR1cm4gbmV3IFN0cmluZ1NjaGVtYSgpO1xufVxuY2xhc3MgU3RyaW5nU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgodmFsdWUsIF9yYXcsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoIWN0eC5zcGVjLmNvZXJjZSB8fCBjdHguaXNUeXBlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8vIGRvbid0IGV2ZXIgY29udmVydCBhcnJheXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNvbnN0IHN0clZhbHVlID0gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS50b1N0cmluZyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZTtcblxuICAgICAgICAvLyBubyBvbmUgd2FudHMgcGxhaW4gb2JqZWN0cyBjb252ZXJ0ZWQgdG8gW09iamVjdCBvYmplY3RdXG4gICAgICAgIGlmIChzdHJWYWx1ZSA9PT0gb2JqU3RyaW5nVGFnKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHJldHVybiBzdHJWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlcXVpcmVkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWQobWVzc2FnZSkud2l0aE11dGF0aW9uKHNjaGVtYSA9PiBzY2hlbWEudGVzdCh7XG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IG1peGVkLnJlcXVpcmVkLFxuICAgICAgbmFtZTogJ3JlcXVpcmVkJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiAhIXZhbHVlLmxlbmd0aFxuICAgIH0pKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gc3VwZXIubm90UmVxdWlyZWQoKS53aXRoTXV0YXRpb24oc2NoZW1hID0+IHtcbiAgICAgIHNjaGVtYS50ZXN0cyA9IHNjaGVtYS50ZXN0cy5maWx0ZXIodCA9PiB0Lk9QVElPTlMubmFtZSAhPT0gJ3JlcXVpcmVkJyk7XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH0pO1xuICB9XG4gIGxlbmd0aChsZW5ndGgsIG1lc3NhZ2UgPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gdGhpcy5yZXNvbHZlKGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IHN0cmluZy5taW4pIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IHRoaXMucmVzb2x2ZShtaW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXgsIG1lc3NhZ2UgPSBzdHJpbmcubWF4KSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWF4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXRjaGVzKHJlZ2V4LCBvcHRpb25zKSB7XG4gICAgbGV0IGV4Y2x1ZGVFbXB0eVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGxldCBuYW1lO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICh7XG4gICAgICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0gPSBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6IG5hbWUgfHwgJ21hdGNoZXMnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcubWF0Y2hlcyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICByZWdleFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gJycgJiYgZXhjbHVkZUVtcHR5U3RyaW5nIHx8IHZhbHVlLnNlYXJjaChyZWdleCkgIT09IC0xXG4gICAgfSk7XG4gIH1cbiAgZW1haWwobWVzc2FnZSA9IHN0cmluZy5lbWFpbCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMockVtYWlsLCB7XG4gICAgICBuYW1lOiAnZW1haWwnLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHVybChtZXNzYWdlID0gc3RyaW5nLnVybCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoclVybCwge1xuICAgICAgbmFtZTogJ3VybCcsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdXVpZChtZXNzYWdlID0gc3RyaW5nLnV1aWQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHJVVUlELCB7XG4gICAgICBuYW1lOiAndXVpZCcsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLy8tLSB0cmFuc2Zvcm1zIC0tXG4gIGVuc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0KCcnKS50cmFuc2Zvcm0odmFsID0+IHZhbCA9PT0gbnVsbCA/ICcnIDogdmFsKTtcbiAgfVxuICB0cmltKG1lc3NhZ2UgPSBzdHJpbmcudHJpbSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWwgPT4gdmFsICE9IG51bGwgPyB2YWwudHJpbSgpIDogdmFsKS50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAndHJpbScsXG4gICAgICB0ZXN0OiBpc1RyaW1tZWRcbiAgICB9KTtcbiAgfVxuICBsb3dlcmNhc2UobWVzc2FnZSA9IHN0cmluZy5sb3dlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICB9KTtcbiAgfVxuICB1cHBlcmNhc2UobWVzc2FnZSA9IHN0cmluZy51cHBlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICB9KTtcbiAgfVxufVxuY3JlYXRlJDYucHJvdG90eXBlID0gU3RyaW5nU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIFN0cmluZyBJbnRlcmZhY2VzXG4vL1xuXG5sZXQgaXNOYU4kMSA9IHZhbHVlID0+IHZhbHVlICE9ICt2YWx1ZTtcbmZ1bmN0aW9uIGNyZWF0ZSQ1KCkge1xuICByZXR1cm4gbmV3IE51bWJlclNjaGVtYSgpO1xufVxuY2xhc3MgTnVtYmVyU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4kMSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZWQucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgICBpZiAocGFyc2VkID09PSAnJykgcmV0dXJuIE5hTjtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgcGFyc2VGbG9hdCB0byBhdm9pZCBwb3NpdGl2ZXMgb24gYWxwaGEtbnVtZXJpYyBzdHJpbmdzXG4gICAgICAgICAgcGFyc2VkID0gK3BhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG51bGwgLT4gTmFOIGlzbid0IHVzZWZ1bDsgdHJlYXQgYWxsIG51bGxzIGFzIG51bGwgYW5kIGxldCBpdCBmYWlsIG9uXG4gICAgICAgIC8vIG51bGxhYmlsaXR5IGNoZWNrIHZzIFR5cGVFcnJvcnNcbiAgICAgICAgaWYgKGN0eC5pc1R5cGUocGFyc2VkKSB8fCBwYXJzZWQgPT09IG51bGwpIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnNlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gbnVtYmVyLm1pbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlID0gbnVtYmVyLm1heCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXNzVGhhbihsZXNzLCBtZXNzYWdlID0gbnVtYmVyLmxlc3NUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVzc1xuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IHRoaXMucmVzb2x2ZShsZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtb3JlVGhhbihtb3JlLCBtZXNzYWdlID0gbnVtYmVyLm1vcmVUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9yZVxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+IHRoaXMucmVzb2x2ZShtb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwb3NpdGl2ZShtc2cgPSBudW1iZXIucG9zaXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5tb3JlVGhhbigwLCBtc2cpO1xuICB9XG4gIG5lZ2F0aXZlKG1zZyA9IG51bWJlci5uZWdhdGl2ZSkge1xuICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKDAsIG1zZyk7XG4gIH1cbiAgaW50ZWdlcihtZXNzYWdlID0gbnVtYmVyLmludGVnZXIpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdpbnRlZ2VyJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsID0+IE51bWJlci5pc0ludGVnZXIodmFsKVxuICAgIH0pO1xuICB9XG4gIHRydW5jYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gdmFsdWUgfCAwIDogdmFsdWUpO1xuICB9XG4gIHJvdW5kKG1ldGhvZCkge1xuICAgIHZhciBfbWV0aG9kO1xuICAgIGxldCBhdmFpbCA9IFsnY2VpbCcsICdmbG9vcicsICdyb3VuZCcsICd0cnVuYyddO1xuICAgIG1ldGhvZCA9ICgoX21ldGhvZCA9IG1ldGhvZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZXRob2QudG9Mb3dlckNhc2UoKSkgfHwgJ3JvdW5kJztcblxuICAgIC8vIHRoaXMgZXhpc3RzIGZvciBzeW1lbXRyeSB3aXRoIHRoZSBuZXcgTWF0aC50cnVuY1xuICAgIGlmIChtZXRob2QgPT09ICd0cnVuYycpIHJldHVybiB0aGlzLnRydW5jYXRlKCk7XG4gICAgaWYgKGF2YWlsLmluZGV4T2YobWV0aG9kLnRvTG93ZXJDYXNlKCkpID09PSAtMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignT25seSB2YWxpZCBvcHRpb25zIGZvciByb3VuZCgpIGFyZTogJyArIGF2YWlsLmpvaW4oJywgJykpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gTWF0aFttZXRob2RdKHZhbHVlKSA6IHZhbHVlKTtcbiAgfVxufVxuY3JlYXRlJDUucHJvdG90eXBlID0gTnVtYmVyU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIE51bWJlciBJbnRlcmZhY2VzXG4vL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKlxuICogRGF0ZS5wYXJzZSB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50IGZvciBJU08gODYwMSA8aHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvanMtaXNvODYwMT5cbiAqIE5PTi1DT05GT1JNQU5UIEVESVRJT04uXG4gKiDCqSAyMDExIENvbGluIFNub3ZlciA8aHR0cDovL3pldGFmbGVldC5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqL1xuXG4vLyAgICAgICAgICAgICAgMSBZWVlZICAgICAgICAgICAgICAgICAyIE1NICAgICAgICAzIEREICAgICAgICAgICAgICA0IEhIICAgICA1IG1tICAgICAgICA2IHNzICAgICAgICAgICAgNyBtc2VjICAgICAgICAgOCBaIDkgwrEgICAgMTAgdHpISCAgICAxMSB0em1tXG52YXIgaXNvUmVnID0gL14oXFxkezR9fFsrXFwtXVxcZHs2fSkoPzotPyhcXGR7Mn0pKD86LT8oXFxkezJ9KSk/KT8oPzpbIFRdPyhcXGR7Mn0pOj8oXFxkezJ9KSg/Ojo/KFxcZHsyfSkoPzpbLFxcLl0oXFxkezEsfSkpPyk/KD86KFopfChbK1xcLV0pKFxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZUlzb0RhdGUoZGF0ZSkge1xuICB2YXIgbnVtZXJpY0tleXMgPSBbMSwgNCwgNSwgNiwgNywgMTAsIDExXSxcbiAgICBtaW51dGVzT2Zmc2V0ID0gMCxcbiAgICB0aW1lc3RhbXAsXG4gICAgc3RydWN0O1xuICBpZiAoc3RydWN0ID0gaXNvUmVnLmV4ZWMoZGF0ZSkpIHtcbiAgICAvLyBhdm9pZCBOYU4gdGltZXN0YW1wcyBjYXVzZWQgYnkg4oCcdW5kZWZpbmVk4oCdIHZhbHVlcyBiZWluZyBwYXNzZWQgdG8gRGF0ZS5VVENcbiAgICBmb3IgKHZhciBpID0gMCwgazsgayA9IG51bWVyaWNLZXlzW2ldOyArK2kpIHN0cnVjdFtrXSA9ICtzdHJ1Y3Rba10gfHwgMDtcblxuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBkYXlzIGFuZCBtb250aHNcbiAgICBzdHJ1Y3RbMl0gPSAoK3N0cnVjdFsyXSB8fCAxKSAtIDE7XG4gICAgc3RydWN0WzNdID0gK3N0cnVjdFszXSB8fCAxO1xuXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN1Yi1zZWNvbmQgcHJlY2lzaW9uIGJleW9uZCBtaWxsaXNlY29uZHNcbiAgICBzdHJ1Y3RbN10gPSBzdHJ1Y3RbN10gPyBTdHJpbmcoc3RydWN0WzddKS5zdWJzdHIoMCwgMykgOiAwO1xuXG4gICAgLy8gdGltZXN0YW1wcyB3aXRob3V0IHRpbWV6b25lIGlkZW50aWZpZXJzIHNob3VsZCBiZSBjb25zaWRlcmVkIGxvY2FsIHRpbWVcbiAgICBpZiAoKHN0cnVjdFs4XSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdFs4XSA9PT0gJycpICYmIChzdHJ1Y3RbOV0gPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3RbOV0gPT09ICcnKSkgdGltZXN0YW1wID0gK25ldyBEYXRlKHN0cnVjdFsxXSwgc3RydWN0WzJdLCBzdHJ1Y3RbM10sIHN0cnVjdFs0XSwgc3RydWN0WzVdLCBzdHJ1Y3RbNl0sIHN0cnVjdFs3XSk7ZWxzZSB7XG4gICAgICBpZiAoc3RydWN0WzhdICE9PSAnWicgJiYgc3RydWN0WzldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWludXRlc09mZnNldCA9IHN0cnVjdFsxMF0gKiA2MCArIHN0cnVjdFsxMV07XG4gICAgICAgIGlmIChzdHJ1Y3RbOV0gPT09ICcrJykgbWludXRlc09mZnNldCA9IDAgLSBtaW51dGVzT2Zmc2V0O1xuICAgICAgfVxuICAgICAgdGltZXN0YW1wID0gRGF0ZS5VVEMoc3RydWN0WzFdLCBzdHJ1Y3RbMl0sIHN0cnVjdFszXSwgc3RydWN0WzRdLCBzdHJ1Y3RbNV0gKyBtaW51dGVzT2Zmc2V0LCBzdHJ1Y3RbNl0sIHN0cnVjdFs3XSk7XG4gICAgfVxuICB9IGVsc2UgdGltZXN0YW1wID0gRGF0ZS5wYXJzZSA/IERhdGUucGFyc2UoZGF0ZSkgOiBOYU47XG4gIHJldHVybiB0aW1lc3RhbXA7XG59XG5cbi8vIEB0cy1pZ25vcmVcbmxldCBpbnZhbGlkRGF0ZSA9IG5ldyBEYXRlKCcnKTtcbmxldCBpc0RhdGUgPSBvYmogPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbmZ1bmN0aW9uIGNyZWF0ZSQ0KCkge1xuICByZXR1cm4gbmV3IERhdGVTY2hlbWEoKTtcbn1cbmNsYXNzIERhdGVTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnZGF0ZScsXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIHJldHVybiBpc0RhdGUodikgJiYgIWlzTmFOKHYuZ2V0VGltZSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgodmFsdWUsIF9yYXcsIGN0eCkgPT4ge1xuICAgICAgICAvLyBudWxsIC0+IEludmFsaWREYXRlIGlzbid0IHVzZWZ1bDsgdHJlYXQgYWxsIG51bGxzIGFzIG51bGwgYW5kIGxldCBpdCBmYWlsIG9uXG4gICAgICAgIC8vIG51bGxhYmlsaXR5IGNoZWNrIHZzIFR5cGVFcnJvcnNcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UgfHwgY3R4LmlzVHlwZSh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUlzb0RhdGUodmFsdWUpO1xuXG4gICAgICAgIC8vIDAgaXMgYSB2YWxpZCB0aW1lc3RhbXAgZXF1aXZhbGVudCB0byAxOTcwLTAxLTAxVDAwOjAwOjAwWih1bml4IGVwb2NoKSBvciBiZWZvcmUuXG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogRGF0ZVNjaGVtYS5JTlZBTElEX0RBVEU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBwcmVwYXJlUGFyYW0ocmVmLCBuYW1lKSB7XG4gICAgbGV0IHBhcmFtO1xuICAgIGlmICghUmVmZXJlbmNlLmlzUmVmKHJlZikpIHtcbiAgICAgIGxldCBjYXN0ID0gdGhpcy5jYXN0KHJlZik7XG4gICAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayhjYXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgXFxgJHtuYW1lfVxcYCBtdXN0IGJlIGEgRGF0ZSBvciBhIHZhbHVlIHRoYXQgY2FuIGJlIFxcYGNhc3QoKVxcYCB0byBhIERhdGVgKTtcbiAgICAgIHBhcmFtID0gY2FzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW0gPSByZWY7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gZGF0ZS5taW4pIHtcbiAgICBsZXQgbGltaXQgPSB0aGlzLnByZXBhcmVQYXJhbShtaW4sICdtaW4nKTtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy5yZXNvbHZlKGxpbWl0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlID0gZGF0ZS5tYXgpIHtcbiAgICBsZXQgbGltaXQgPSB0aGlzLnByZXBhcmVQYXJhbShtYXgsICdtYXgnKTtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gdGhpcy5yZXNvbHZlKGxpbWl0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuRGF0ZVNjaGVtYS5JTlZBTElEX0RBVEUgPSBpbnZhbGlkRGF0ZTtcbmNyZWF0ZSQ0LnByb3RvdHlwZSA9IERhdGVTY2hlbWEucHJvdG90eXBlO1xuY3JlYXRlJDQuSU5WQUxJRF9EQVRFID0gaW52YWxpZERhdGU7XG5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmZ1bmN0aW9uIHNvcnRGaWVsZHMoZmllbGRzLCBleGNsdWRlZEVkZ2VzID0gW10pIHtcbiAgbGV0IGVkZ2VzID0gW107XG4gIGxldCBub2RlcyA9IG5ldyBTZXQoKTtcbiAgbGV0IGV4Y2x1ZGVzID0gbmV3IFNldChleGNsdWRlZEVkZ2VzLm1hcCgoW2EsIGJdKSA9PiBgJHthfS0ke2J9YCkpO1xuICBmdW5jdGlvbiBhZGROb2RlKGRlcFBhdGgsIGtleSkge1xuICAgIGxldCBub2RlID0gc3BsaXQoZGVwUGF0aClbMF07XG4gICAgbm9kZXMuYWRkKG5vZGUpO1xuICAgIGlmICghZXhjbHVkZXMuaGFzKGAke2tleX0tJHtub2RlfWApKSBlZGdlcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgbGV0IHZhbHVlID0gZmllbGRzW2tleV07XG4gICAgbm9kZXMuYWRkKGtleSk7XG4gICAgaWYgKFJlZmVyZW5jZS5pc1JlZih2YWx1ZSkgJiYgdmFsdWUuaXNTaWJsaW5nKSBhZGROb2RlKHZhbHVlLnBhdGgsIGtleSk7ZWxzZSBpZiAoaXNTY2hlbWEodmFsdWUpICYmICdkZXBzJyBpbiB2YWx1ZSkgdmFsdWUuZGVwcy5mb3JFYWNoKHBhdGggPT4gYWRkTm9kZShwYXRoLCBrZXkpKTtcbiAgfVxuICByZXR1cm4gdG9wb3NvcnQuYXJyYXkoQXJyYXkuZnJvbShub2RlcyksIGVkZ2VzKS5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGVycikge1xuICBsZXQgaWR4ID0gSW5maW5pdHk7XG4gIGFyci5zb21lKChrZXksIGlpKSA9PiB7XG4gICAgdmFyIF9lcnIkcGF0aDtcbiAgICBpZiAoKF9lcnIkcGF0aCA9IGVyci5wYXRoKSAhPSBudWxsICYmIF9lcnIkcGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBpZHggPSBpaTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBzb3J0QnlLZXlPcmRlcihrZXlzKSB7XG4gIHJldHVybiAoYSwgYikgPT4ge1xuICAgIHJldHVybiBmaW5kSW5kZXgoa2V5cywgYSkgLSBmaW5kSW5kZXgoa2V5cywgYik7XG4gIH07XG59XG5cbmNvbnN0IHBhcnNlSnNvbiA9ICh2YWx1ZSwgXywgY3R4KSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGxldCBwYXJzZWQgPSB2YWx1ZTtcbiAgdHJ5IHtcbiAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLyogKi9cbiAgfVxuICByZXR1cm4gY3R4LmlzVHlwZShwYXJzZWQpID8gcGFyc2VkIDogdmFsdWU7XG59O1xuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBkZWVwUGFydGlhbChzY2hlbWEpIHtcbiAgaWYgKCdmaWVsZHMnIGluIHNjaGVtYSkge1xuICAgIGNvbnN0IHBhcnRpYWwgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGZpZWxkU2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEuZmllbGRzKSkge1xuICAgICAgcGFydGlhbFtrZXldID0gZGVlcFBhcnRpYWwoZmllbGRTY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLnNldEZpZWxkcyhwYXJ0aWFsKTtcbiAgfVxuICBpZiAoc2NoZW1hLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICBjb25zdCBuZXh0QXJyYXkgPSBzY2hlbWEub3B0aW9uYWwoKTtcbiAgICBpZiAobmV4dEFycmF5LmlubmVyVHlwZSkgbmV4dEFycmF5LmlubmVyVHlwZSA9IGRlZXBQYXJ0aWFsKG5leHRBcnJheS5pbm5lclR5cGUpO1xuICAgIHJldHVybiBuZXh0QXJyYXk7XG4gIH1cbiAgaWYgKHNjaGVtYS50eXBlID09PSAndHVwbGUnKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5vcHRpb25hbCgpLmNsb25lKHtcbiAgICAgIHR5cGVzOiBzY2hlbWEuc3BlYy50eXBlcy5tYXAoZGVlcFBhcnRpYWwpXG4gICAgfSk7XG4gIH1cbiAgaWYgKCdvcHRpb25hbCcgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5vcHRpb25hbCgpO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5jb25zdCBkZWVwSGFzID0gKG9iaiwgcCkgPT4ge1xuICBjb25zdCBwYXRoID0gWy4uLm5vcm1hbGl6ZVBhdGgocCldO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHJldHVybiBwYXRoWzBdIGluIG9iajtcbiAgbGV0IGxhc3QgPSBwYXRoLnBvcCgpO1xuICBsZXQgcGFyZW50ID0gZ2V0dGVyKGpvaW4ocGF0aCksIHRydWUpKG9iaik7XG4gIHJldHVybiAhIShwYXJlbnQgJiYgbGFzdCBpbiBwYXJlbnQpO1xufTtcbmxldCBpc09iamVjdCA9IG9iaiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5mdW5jdGlvbiB1bmtub3duKGN0eCwgdmFsdWUpIHtcbiAgbGV0IGtub3duID0gT2JqZWN0LmtleXMoY3R4LmZpZWxkcyk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGtleSA9PiBrbm93bi5pbmRleE9mKGtleSkgPT09IC0xKTtcbn1cbmNvbnN0IGRlZmF1bHRTb3J0ID0gc29ydEJ5S2V5T3JkZXIoW10pO1xuZnVuY3Rpb24gY3JlYXRlJDMoc3BlYykge1xuICByZXR1cm4gbmV3IE9iamVjdFNjaGVtYShzcGVjKTtcbn1cbmNsYXNzIE9iamVjdFNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIGNoZWNrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmllbGRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9zb3J0RXJyb3JzID0gZGVmYXVsdFNvcnQ7XG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICB0aGlzLl9leGNsdWRlZEVkZ2VzID0gW107XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zaGFwZShzcGVjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfY2FzdChfdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfb3B0aW9ucyRzdHJpcFVua25vd247XG4gICAgbGV0IHZhbHVlID0gc3VwZXIuX2Nhc3QoX3ZhbHVlLCBvcHRpb25zKTtcblxuICAgIC8vc2hvdWxkIGlnbm9yZSBudWxscyBoZXJlXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmdldERlZmF1bHQob3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgbGV0IGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgIGxldCBzdHJpcCA9IChfb3B0aW9ucyRzdHJpcFVua25vd24gPSBvcHRpb25zLnN0cmlwVW5rbm93bikgIT0gbnVsbCA/IF9vcHRpb25zJHN0cmlwVW5rbm93biA6IHRoaXMuc3BlYy5ub1Vua25vd247XG4gICAgbGV0IHByb3BzID0gW10uY29uY2F0KHRoaXMuX25vZGVzLCBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKHYgPT4gIXRoaXMuX25vZGVzLmluY2x1ZGVzKHYpKSk7XG4gICAgbGV0IGludGVybWVkaWF0ZVZhbHVlID0ge307IC8vIGlzIGZpbGxlZCBkdXJpbmcgdGhlIHRyYW5zZm9ybSBiZWxvd1xuICAgIGxldCBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IGludGVybWVkaWF0ZVZhbHVlLFxuICAgICAgX192YWxpZGF0aW5nOiBvcHRpb25zLl9fdmFsaWRhdGluZyB8fCBmYWxzZVxuICAgIH0pO1xuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1twcm9wXTtcbiAgICAgIGxldCBleGlzdHMgPSAocHJvcCBpbiB2YWx1ZSk7XG4gICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgbGV0IGZpZWxkVmFsdWU7XG4gICAgICAgIGxldCBpbnB1dFZhbHVlID0gdmFsdWVbcHJvcF07XG5cbiAgICAgICAgLy8gc2FmZSB0byBtdXRhdGUgc2luY2UgdGhpcyBpcyBmaXJlZCBpbiBzZXF1ZW5jZVxuICAgICAgICBpbm5lck9wdGlvbnMucGF0aCA9IChvcHRpb25zLnBhdGggPyBgJHtvcHRpb25zLnBhdGh9LmAgOiAnJykgKyBwcm9wO1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgICBwYXJlbnQ6IGludGVybWVkaWF0ZVZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmllbGRTcGVjID0gZmllbGQgaW5zdGFuY2VvZiBTY2hlbWEgPyBmaWVsZC5zcGVjIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc3RyaWN0ID0gZmllbGRTcGVjID09IG51bGwgPyB2b2lkIDAgOiBmaWVsZFNwZWMuc3RyaWN0O1xuICAgICAgICBpZiAoZmllbGRTcGVjICE9IG51bGwgJiYgZmllbGRTcGVjLnN0cmlwKSB7XG4gICAgICAgICAgaXNDaGFuZ2VkID0gaXNDaGFuZ2VkIHx8IHByb3AgaW4gdmFsdWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRWYWx1ZSA9ICFvcHRpb25zLl9fdmFsaWRhdGluZyB8fCAhc3RyaWN0ID9cbiAgICAgICAgLy8gVE9ETzogdXNlIF9jYXN0LCB0aGlzIGlzIGRvdWJsZSByZXNvbHZpbmdcbiAgICAgICAgZmllbGQuY2FzdCh2YWx1ZVtwcm9wXSwgaW5uZXJPcHRpb25zKSA6IHZhbHVlW3Byb3BdO1xuICAgICAgICBpZiAoZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWVbcHJvcF0gPSBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0cyAmJiAhc3RyaXApIHtcbiAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWVbcHJvcF0gPSB2YWx1ZVtwcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmIChleGlzdHMgIT09IHByb3AgaW4gaW50ZXJtZWRpYXRlVmFsdWUgfHwgaW50ZXJtZWRpYXRlVmFsdWVbcHJvcF0gIT09IHZhbHVlW3Byb3BdKSB7XG4gICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc0NoYW5nZWQgPyBpbnRlcm1lZGlhdGVWYWx1ZSA6IHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICBsZXQge1xuICAgICAgZnJvbSA9IFtdLFxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IF92YWx1ZSxcbiAgICAgIHJlY3Vyc2l2ZSA9IHRoaXMuc3BlYy5yZWN1cnNpdmVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBvcHRpb25zLmZyb20gPSBbe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdmFsdWU6IG9yaWdpbmFsVmFsdWVcbiAgICB9LCAuLi5mcm9tXTtcbiAgICAvLyB0aGlzIGZsYWcgaXMgbmVlZGVkIGZvciBoYW5kbGluZyBgc3RyaWN0YCBjb3JyZWN0bHkgaW4gdGhlIGNvbnRleHQgb2ZcbiAgICAvLyB2YWxpZGF0aW9uIHZzIGp1c3QgY2FzdGluZy4gZS5nIHN0cmljdCgpIG9uIGEgZmllbGQgaXMgb25seSB1c2VkIHdoZW4gdmFsaWRhdGluZ1xuICAgIG9wdGlvbnMuX192YWxpZGF0aW5nID0gdHJ1ZTtcbiAgICBvcHRpb25zLm9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbFZhbHVlO1xuICAgIHN1cGVyLl92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMsIHBhbmljLCAob2JqZWN0RXJyb3JzLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFyZWN1cnNpdmUgfHwgIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBuZXh0KG9iamVjdEVycm9ycywgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcmlnaW5hbFZhbHVlID0gb3JpZ2luYWxWYWx1ZSB8fCB2YWx1ZTtcbiAgICAgIGxldCB0ZXN0cyA9IFtdO1xuICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICAgIGxldCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgICAgIGlmICghZmllbGQgfHwgUmVmZXJlbmNlLmlzUmVmKGZpZWxkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRlc3RzLnB1c2goZmllbGQuYXNOZXN0ZWRUZXN0KHtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBwYXJlbnQ6IHZhbHVlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgICBvcmlnaW5hbFBhcmVudDogb3JpZ2luYWxWYWx1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgdGVzdHMsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBwYW5pYywgZmllbGRFcnJvcnMgPT4ge1xuICAgICAgICBuZXh0KGZpZWxkRXJyb3JzLnNvcnQodGhpcy5fc29ydEVycm9ycykuY29uY2F0KG9iamVjdEVycm9ycyksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBjb25zdCBuZXh0ID0gc3VwZXIuY2xvbmUoc3BlYyk7XG4gICAgbmV4dC5maWVsZHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZpZWxkcyk7XG4gICAgbmV4dC5fbm9kZXMgPSB0aGlzLl9ub2RlcztcbiAgICBuZXh0Ll9leGNsdWRlZEVkZ2VzID0gdGhpcy5fZXhjbHVkZWRFZGdlcztcbiAgICBuZXh0Ll9zb3J0RXJyb3JzID0gdGhpcy5fc29ydEVycm9ycztcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBjb25jYXQoc2NoZW1hKSB7XG4gICAgbGV0IG5leHQgPSBzdXBlci5jb25jYXQoc2NoZW1hKTtcbiAgICBsZXQgbmV4dEZpZWxkcyA9IG5leHQuZmllbGRzO1xuICAgIGZvciAobGV0IFtmaWVsZCwgc2NoZW1hT3JSZWZdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbmV4dEZpZWxkc1tmaWVsZF07XG4gICAgICBuZXh0RmllbGRzW2ZpZWxkXSA9IHRhcmdldCA9PT0gdW5kZWZpbmVkID8gc2NoZW1hT3JSZWYgOiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0LndpdGhNdXRhdGlvbihzID0+XG4gICAgLy8gWFhYOiBleGNsdWRlcyBoZXJlIGlzIHdyb25nXG4gICAgcy5zZXRGaWVsZHMobmV4dEZpZWxkcywgWy4uLnRoaXMuX2V4Y2x1ZGVkRWRnZXMsIC4uLnNjaGVtYS5fZXhjbHVkZWRFZGdlc10pKTtcbiAgfVxuICBfZ2V0RGVmYXVsdChvcHRpb25zKSB7XG4gICAgaWYgKCdkZWZhdWx0JyBpbiB0aGlzLnNwZWMpIHtcbiAgICAgIHJldHVybiBzdXBlci5fZ2V0RGVmYXVsdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBkZWZhdWx0IHNldCBpbnZlbnQgb25lXG4gICAgaWYgKCF0aGlzLl9ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBkZnQgPSB7fTtcbiAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICB2YXIgX2lubmVyT3B0aW9ucztcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHNba2V5XTtcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMudmFsdWUpIHtcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XG4gICAgICAgICAgcGFyZW50OiBpbm5lck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGZ0W2tleV0gPSBmaWVsZCAmJiAnZ2V0RGVmYXVsdCcgaW4gZmllbGQgPyBmaWVsZC5nZXREZWZhdWx0KGlubmVyT3B0aW9ucykgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRmdDtcbiAgfVxuICBzZXRGaWVsZHMoc2hhcGUsIGV4Y2x1ZGVkRWRnZXMpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LmZpZWxkcyA9IHNoYXBlO1xuICAgIG5leHQuX25vZGVzID0gc29ydEZpZWxkcyhzaGFwZSwgZXhjbHVkZWRFZGdlcyk7XG4gICAgbmV4dC5fc29ydEVycm9ycyA9IHNvcnRCeUtleU9yZGVyKE9iamVjdC5rZXlzKHNoYXBlKSk7XG4gICAgLy8gWFhYOiB0aGlzIGNhcnJpZXMgb3ZlciBlZGdlcyB3aGljaCBtYXkgbm90IGJlIHdoYXQgeW91IHdhbnRcbiAgICBpZiAoZXhjbHVkZWRFZGdlcykgbmV4dC5fZXhjbHVkZWRFZGdlcyA9IGV4Y2x1ZGVkRWRnZXM7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgc2hhcGUoYWRkaXRpb25zLCBleGNsdWRlcyA9IFtdKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS53aXRoTXV0YXRpb24obmV4dCA9PiB7XG4gICAgICBsZXQgZWRnZXMgPSBuZXh0Ll9leGNsdWRlZEVkZ2VzO1xuICAgICAgaWYgKGV4Y2x1ZGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhjbHVkZXNbMF0pKSBleGNsdWRlcyA9IFtleGNsdWRlc107XG4gICAgICAgIGVkZ2VzID0gWy4uLm5leHQuX2V4Y2x1ZGVkRWRnZXMsIC4uLmV4Y2x1ZGVzXTtcbiAgICAgIH1cblxuICAgICAgLy8gWFhYOiBleGNsdWRlcyBoZXJlIGlzIHdyb25nXG4gICAgICByZXR1cm4gbmV4dC5zZXRGaWVsZHMoT2JqZWN0LmFzc2lnbihuZXh0LmZpZWxkcywgYWRkaXRpb25zKSwgZWRnZXMpO1xuICAgIH0pO1xuICB9XG4gIHBhcnRpYWwoKSB7XG4gICAgY29uc3QgcGFydGlhbCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgc2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIHBhcnRpYWxba2V5XSA9ICdvcHRpb25hbCcgaW4gc2NoZW1hICYmIHNjaGVtYS5vcHRpb25hbCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gc2NoZW1hLm9wdGlvbmFsKCkgOiBzY2hlbWE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNldEZpZWxkcyhwYXJ0aWFsKTtcbiAgfVxuICBkZWVwUGFydGlhbCgpIHtcbiAgICBjb25zdCBuZXh0ID0gZGVlcFBhcnRpYWwodGhpcyk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgcGljayhrZXlzKSB7XG4gICAgY29uc3QgcGlja2VkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKHRoaXMuZmllbGRzW2tleV0pIHBpY2tlZFtrZXldID0gdGhpcy5maWVsZHNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0RmllbGRzKHBpY2tlZCk7XG4gIH1cbiAgb21pdChrZXlzKSB7XG4gICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWVsZHMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGRlbGV0ZSBmaWVsZHNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0RmllbGRzKGZpZWxkcyk7XG4gIH1cbiAgZnJvbShmcm9tLCB0bywgYWxpYXMpIHtcbiAgICBsZXQgZnJvbUdldHRlciA9IGdldHRlcihmcm9tLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqID0+IHtcbiAgICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuICAgICAgbGV0IG5ld09iaiA9IG9iajtcbiAgICAgIGlmIChkZWVwSGFzKG9iaiwgZnJvbSkpIHtcbiAgICAgICAgbmV3T2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgaWYgKCFhbGlhcykgZGVsZXRlIG5ld09ialtmcm9tXTtcbiAgICAgICAgbmV3T2JqW3RvXSA9IGZyb21HZXR0ZXIob2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSk7XG4gIH1cblxuICAvKiogUGFyc2UgYW4gaW5wdXQgSlNPTiBzdHJpbmcgdG8gYW4gb2JqZWN0ICovXG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHBhcnNlSnNvbik7XG4gIH1cbiAgbm9Vbmtub3duKG5vQWxsb3cgPSB0cnVlLCBtZXNzYWdlID0gb2JqZWN0Lm5vVW5rbm93bikge1xuICAgIGlmICh0eXBlb2Ygbm9BbGxvdyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtZXNzYWdlID0gbm9BbGxvdztcbiAgICAgIG5vQWxsb3cgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnbm9Vbmtub3duJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB1bmtub3duKHRoaXMuc2NoZW1hLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiAhbm9BbGxvdyB8fCB1bmtub3duS2V5cy5sZW5ndGggPT09IDAgfHwgdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB1bmtub3duOiB1bmtub3duS2V5cy5qb2luKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBuZXh0LnNwZWMubm9Vbmtub3duID0gbm9BbGxvdztcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB1bmtub3duKGFsbG93ID0gdHJ1ZSwgbWVzc2FnZSA9IG9iamVjdC5ub1Vua25vd24pIHtcbiAgICByZXR1cm4gdGhpcy5ub1Vua25vd24oIWFsbG93LCBtZXNzYWdlKTtcbiAgfVxuICB0cmFuc2Zvcm1LZXlzKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkgcmVzdWx0W2ZuKGtleSldID0gb2JqW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIGNhbWVsQ2FzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKGNhbWVsQ2FzZSk7XG4gIH1cbiAgc25ha2VDYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoc25ha2VDYXNlKTtcbiAgfVxuICBjb25zdGFudENhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhrZXkgPT4gc25ha2VDYXNlKGtleSkudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGxldCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XG4gICAgYmFzZS5maWVsZHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zMjtcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zMiA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zMi52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiYXNlLmZpZWxkc1trZXldID0gdmFsdWUuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn1cbmNyZWF0ZSQzLnByb3RvdHlwZSA9IE9iamVjdFNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZSQyKHR5cGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheVNjaGVtYSh0eXBlKTtcbn1cbmNsYXNzIEFycmF5U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIHR5cGVzOiB0eXBlXG4gICAgICB9LFxuICAgICAgY2hlY2sodikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGB1bmRlZmluZWRgIHNwZWNpZmljYWxseSBtZWFucyB1bmluaXRpYWxpemVkLCBhcyBvcHBvc2VkIHRvIFwibm8gc3VidHlwZVwiXG4gICAgdGhpcy5pbm5lclR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbm5lclR5cGUgPSB0eXBlO1xuICB9XG4gIF9jYXN0KF92YWx1ZSwgX29wdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLl9jYXN0KF92YWx1ZSwgX29wdHMpO1xuXG4gICAgLy8gc2hvdWxkIGlnbm9yZSBudWxscyBoZXJlXG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpIHx8ICF0aGlzLmlubmVyVHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgY2FzdEFycmF5ID0gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGNhc3RFbGVtZW50ID0gdGhpcy5pbm5lclR5cGUuY2FzdCh2LCBPYmplY3QuYXNzaWduKHt9LCBfb3B0cywge1xuICAgICAgICBwYXRoOiBgJHtfb3B0cy5wYXRoIHx8ICcnfVske2lkeH1dYFxuICAgICAgfSkpO1xuICAgICAgaWYgKGNhc3RFbGVtZW50ICE9PSB2KSB7XG4gICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FzdEVsZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGNhc3RBcnJheSA6IHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICB2YXIgX29wdGlvbnMkcmVjdXJzaXZlO1xuICAgIC8vIGxldCBzeW5jID0gb3B0aW9ucy5zeW5jO1xuICAgIC8vIGxldCBwYXRoID0gb3B0aW9ucy5wYXRoO1xuICAgIGxldCBpbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcbiAgICAvLyBsZXQgZW5kRWFybHkgPSBvcHRpb25zLmFib3J0RWFybHkgPz8gdGhpcy5zcGVjLmFib3J0RWFybHk7XG4gICAgbGV0IHJlY3Vyc2l2ZSA9IChfb3B0aW9ucyRyZWN1cnNpdmUgPSBvcHRpb25zLnJlY3Vyc2l2ZSkgIT0gbnVsbCA/IF9vcHRpb25zJHJlY3Vyc2l2ZSA6IHRoaXMuc3BlYy5yZWN1cnNpdmU7XG4gICAgb3B0aW9ucy5vcmlnaW5hbFZhbHVlICE9IG51bGwgPyBvcHRpb25zLm9yaWdpbmFsVmFsdWUgOiBfdmFsdWU7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsIChhcnJheUVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyO1xuICAgICAgaWYgKCFyZWN1cnNpdmUgfHwgIWlubmVyVHlwZSB8fCAhdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xuICAgICAgICBuZXh0KGFycmF5RXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gIzk1MCBFbnN1cmUgdGhhdCBzcGFyc2UgYXJyYXkgZW1wdHkgc2xvdHMgYXJlIHZhbGlkYXRlZFxuICAgICAgbGV0IHRlc3RzID0gbmV3IEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHU7XG4gICAgICAgIHRlc3RzW2luZGV4XSA9IGlubmVyVHlwZS5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUgOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRlc3RzLFxuICAgICAgICBvcmlnaW5hbFZhbHVlOiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgOiBfdmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBpbm5lclR5cGVFcnJvcnMgPT4gbmV4dChpbm5lclR5cGVFcnJvcnMuY29uY2F0KGFycmF5RXJyb3JzKSwgdmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IHN1cGVyLmNsb25lKHNwZWMpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLyoqIFBhcnNlIGFuIGlucHV0IEpTT04gc3RyaW5nIHRvIGFuIG9iamVjdCAqL1xuICBqc29uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShwYXJzZUpzb24pO1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBsZXQgbmV4dCA9IHN1cGVyLmNvbmNhdChzY2hlbWEpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgIG5leHQuaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUpXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgICBuZXh0LmlubmVyVHlwZSA9IG5leHQuaW5uZXJUeXBlID9cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTGF6eSBkb2Vzbid0IGhhdmUgY29uY2F0IGFuZCB3aWxsIGJyZWFrXG4gICAgICBuZXh0LmlubmVyVHlwZS5jb25jYXQoc2NoZW1hLmlubmVyVHlwZSkgOiBzY2hlbWEuaW5uZXJUeXBlO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9mKHNjaGVtYSkge1xuICAgIC8vIEZJWE1FOiB0aGlzIHNob3VsZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYXJyYXkgd2l0aG91dCB0aGUgZGVmYXVsdCB0byBiZVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFycmF5Lm9mKClgIHN1Yi1zY2hlbWEgbXVzdCBiZSBhIHZhbGlkIHl1cCBzY2hlbWEgbm90OiAnICsgcHJpbnRWYWx1ZShzY2hlbWEpKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHNjaGVtYTtcbiAgICBuZXh0LnNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXh0LnNwZWMsIHtcbiAgICAgIHR5cGVzOiBzY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBsZW5ndGgobGVuZ3RoLCBtZXNzYWdlID0gYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gdGhpcy5yZXNvbHZlKGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGFycmF5Lm1pbjtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgLy8gRklYTUUodHMpOiBBcnJheTx0eXBlb2YgVD5cbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgYXJyYXkubWF4O1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZW5zdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHQoKCkgPT4gW10pLnRyYW5zZm9ybSgodmFsLCBvcmlnaW5hbCkgPT4ge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gYG51bGxgIGZvciBudWxsYWJsZSBzY2hlbWFcbiAgICAgIGlmICh0aGlzLl90eXBlQ2hlY2sodmFsKSkgcmV0dXJuIHZhbDtcbiAgICAgIHJldHVybiBvcmlnaW5hbCA9PSBudWxsID8gW10gOiBbXS5jb25jYXQob3JpZ2luYWwpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBhY3QocmVqZWN0b3IpIHtcbiAgICBsZXQgcmVqZWN0ID0gIXJlamVjdG9yID8gdiA9PiAhIXYgOiAodiwgaSwgYSkgPT4gIXJlamVjdG9yKHYsIGksIGEpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZXMgPT4gdmFsdWVzICE9IG51bGwgPyB2YWx1ZXMuZmlsdGVyKHJlamVjdCkgOiB2YWx1ZXMpO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBsZXQgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmlubmVyVHlwZSkge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVbMF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiYXNlLmlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMi5wcm90b3R5cGUgPSBBcnJheVNjaGVtYS5wcm90b3R5cGU7XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGNyZWF0ZSQxKHNjaGVtYXMpIHtcbiAgcmV0dXJuIG5ldyBUdXBsZVNjaGVtYShzY2hlbWFzKTtcbn1cbmNsYXNzIFR1cGxlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Ioc2NoZW1hcykge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIHR5cGVzOiBzY2hlbWFzXG4gICAgICB9LFxuICAgICAgY2hlY2sodikge1xuICAgICAgICBjb25zdCB0eXBlcyA9IHRoaXMuc3BlYy50eXBlcztcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IHR5cGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnR5cGVFcnJvcih0dXBsZS5ub3RUeXBlKTtcbiAgICB9KTtcbiAgfVxuICBfY2FzdChpbnB1dFZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gdGhpcy5zcGVjO1xuICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuX2Nhc3QoaW5wdXRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYXN0QXJyYXkgPSB0eXBlcy5tYXAoKHR5cGUsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY2FzdEVsZW1lbnQgPSB0eXBlLmNhc3QodmFsdWVbaWR4XSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXRoOiBgJHtvcHRpb25zLnBhdGggfHwgJyd9WyR7aWR4fV1gXG4gICAgICB9KSk7XG4gICAgICBpZiAoY2FzdEVsZW1lbnQgIT09IHZhbHVlW2lkeF0pIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICByZXR1cm4gY2FzdEVsZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGNhc3RBcnJheSA6IHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICBsZXQgaXRlbVR5cGVzID0gdGhpcy5zcGVjLnR5cGVzO1xuICAgIHN1cGVyLl92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMsIHBhbmljLCAodHVwbGVFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1MjtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgbm90IHJlc3BlY3RpbmcgcmVjdXJzaXZlXG4gICAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dCh0dXBsZUVycm9ycywgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdGVzdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IFtpbmRleCwgaXRlbVNjaGVtYV0gb2YgaXRlbVR5cGVzLmVudHJpZXMoKSkge1xuICAgICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1O1xuICAgICAgICB0ZXN0c1tpbmRleF0gPSBpdGVtU2NoZW1hLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwYXJlbnQ6IHZhbHVlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgICBvcmlnaW5hbFBhcmVudDogKF9vcHRpb25zJG9yaWdpbmFsVmFsdSA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdSA6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdGVzdHMsXG4gICAgICAgIG9yaWdpbmFsVmFsdWU6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUyID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA6IF92YWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGlubmVyVHlwZUVycm9ycyA9PiBuZXh0KGlubmVyVHlwZUVycm9ycy5jb25jYXQodHVwbGVFcnJvcnMpLCB2YWx1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBsZXQgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGJhc2UuaW5uZXJUeXBlID0gdGhpcy5zcGVjLnR5cGVzLm1hcCgoc2NoZW1hLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVbaW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYS5kZXNjcmliZShpbm5lck9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMS5wcm90b3R5cGUgPSBUdXBsZVNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZShidWlsZGVyKSB7XG4gIHJldHVybiBuZXcgTGF6eShidWlsZGVyKTtcbn1cbmNsYXNzIExhenkge1xuICBjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG4gICAgdGhpcy50eXBlID0gJ2xhenknO1xuICAgIHRoaXMuX19pc1l1cFNjaGVtYV9fID0gdHJ1ZTtcbiAgICB0aGlzLnNwZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVzb2x2ZSA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBsZXQgc2NoZW1hID0gdGhpcy5idWlsZGVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF6eSgpIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIHZhbGlkIHNjaGVtYScpO1xuICAgICAgaWYgKHRoaXMuc3BlYy5vcHRpb25hbCkgc2NoZW1hID0gc2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICByZXR1cm4gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIHRoaXMuc3BlYyA9IHtcbiAgICAgIG1ldGE6IHVuZGVmaW5lZCxcbiAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBuZXcgTGF6eSh0aGlzLmJ1aWxkZXIpO1xuICAgIG5leHQuc3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3BlYywgc3BlYyk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb3B0aW9uYWxpdHkob3B0aW9uYWwpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBvcHRpb25hbFxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KHRydWUpO1xuICB9XG4gIHJlc29sdmUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKG9wdGlvbnMudmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGNhc3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuY2FzdCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgYXNOZXN0ZWRUZXN0KGNvbmZpZykge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBpbmRleCxcbiAgICAgIHBhcmVudCxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtpbmRleCAhPSBudWxsID8gaW5kZXggOiBrZXldO1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHBhcmVudFxuICAgIH0pKS5hc05lc3RlZFRlc3QoY29uZmlnKTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZUF0KHBhdGgsIHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICB2YWxpZGF0ZVN5bmNBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZVN5bmNBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgaXNWYWxpZCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5pc1ZhbGlkKHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBpc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5pc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpLmRlc2NyaWJlKG9wdGlvbnMpIDoge1xuICAgICAgdHlwZTogJ2xhenknLFxuICAgICAgbWV0YTogdGhpcy5zcGVjLm1ldGEsXG4gICAgICBsYWJlbDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuICBtZXRhKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnNwZWMubWV0YTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMubWV0YSA9IE9iamVjdC5hc3NpZ24obmV4dC5zcGVjLm1ldGEgfHwge30sIGFyZ3NbMF0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExvY2FsZShjdXN0b20pIHtcbiAgT2JqZWN0LmtleXMoY3VzdG9tKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3Qua2V5cyhjdXN0b21bdHlwZV0pLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxvY2FsZVt0eXBlXVttZXRob2RdID0gY3VzdG9tW3R5cGVdW21ldGhvZF07XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRNZXRob2Qoc2NoZW1hVHlwZSwgbmFtZSwgZm4pIHtcbiAgaWYgKCFzY2hlbWFUeXBlIHx8ICFpc1NjaGVtYShzY2hlbWFUeXBlLnByb3RvdHlwZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB5dXAgc2NoZW1hIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgTWV0aG9kIG5hbWUgbXVzdCBiZSBwcm92aWRlZCcpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXRob2QgZnVuY3Rpb24gbXVzdCBiZSBwcm92aWRlZCcpO1xuICBzY2hlbWFUeXBlLnByb3RvdHlwZVtuYW1lXSA9IGZuO1xufVxuXG5leHBvcnQgeyBBcnJheVNjaGVtYSwgQm9vbGVhblNjaGVtYSwgRGF0ZVNjaGVtYSwgTWl4ZWRTY2hlbWEsIE51bWJlclNjaGVtYSwgT2JqZWN0U2NoZW1hLCBTY2hlbWEsIFN0cmluZ1NjaGVtYSwgVHVwbGVTY2hlbWEsIFZhbGlkYXRpb25FcnJvciwgYWRkTWV0aG9kLCBjcmVhdGUkMiBhcyBhcnJheSwgY3JlYXRlJDcgYXMgYm9vbCwgY3JlYXRlJDcgYXMgYm9vbGVhbiwgY3JlYXRlJDQgYXMgZGF0ZSwgbG9jYWxlIGFzIGRlZmF1bHRMb2NhbGUsIGdldEluLCBpc1NjaGVtYSwgY3JlYXRlIGFzIGxhenksIGNyZWF0ZSQ4IGFzIG1peGVkLCBjcmVhdGUkNSBhcyBudW1iZXIsIGNyZWF0ZSQzIGFzIG9iamVjdCwgcHJpbnRWYWx1ZSwgcmVhY2gsIGNyZWF0ZSQ5IGFzIHJlZiwgc2V0TG9jYWxlLCBjcmVhdGUkNiBhcyBzdHJpbmcsIGNyZWF0ZSQxIGFzIHR1cGxlIH07XG4iXSwibmFtZXMiOlsiZ2V0dGVyIiwiZm9yRWFjaCIsInNwbGl0Iiwibm9ybWFsaXplUGF0aCIsImpvaW4iLCJjYW1lbENhc2UiLCJzbmFrZUNhc2UiLCJ0b3Bvc29ydCIsInRvU3RyaW5nIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiZXJyb3JUb1N0cmluZyIsIkVycm9yIiwicmVnRXhwVG9TdHJpbmciLCJSZWdFeHAiLCJzeW1ib2xUb1N0cmluZyIsIlN5bWJvbCIsIlNZTUJPTF9SRUdFWFAiLCJwcmludE51bWJlciIsInZhbCIsImlzTmVnYXRpdmVaZXJvIiwicHJpbnRTaW1wbGVWYWx1ZSIsInF1b3RlU3RyaW5ncyIsInR5cGVPZiIsIm5hbWUiLCJjYWxsIiwicmVwbGFjZSIsInRhZyIsInNsaWNlIiwiaXNOYU4iLCJnZXRUaW1lIiwidG9JU09TdHJpbmciLCJwcmludFZhbHVlIiwidmFsdWUiLCJyZXN1bHQiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5IiwidG9BcnJheSIsImNvbmNhdCIsInN0clJlZyIsIlZhbGlkYXRpb25FcnJvciIsImZvcm1hdEVycm9yIiwibWVzc2FnZSIsInBhcmFtcyIsInBhdGgiLCJsYWJlbCIsImFzc2lnbiIsIl8iLCJpc0Vycm9yIiwiZXJyIiwiY29uc3RydWN0b3IiLCJlcnJvck9yRXJyb3JzIiwiZmllbGQiLCJ0eXBlIiwiZXJyb3JzIiwiaW5uZXIiLCJwdXNoIiwibGVuZ3RoIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJtaXhlZCIsImRlZmF1bHQiLCJyZXF1aXJlZCIsImRlZmluZWQiLCJub3ROdWxsIiwib25lT2YiLCJub3RPbmVPZiIsIm5vdFR5cGUiLCJvcmlnaW5hbFZhbHVlIiwiY2FzdE1zZyIsInN0cmluZyIsIm1pbiIsIm1heCIsIm1hdGNoZXMiLCJlbWFpbCIsInVybCIsInV1aWQiLCJ0cmltIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibnVtYmVyIiwibGVzc1RoYW4iLCJtb3JlVGhhbiIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJpbnRlZ2VyIiwiZGF0ZSIsImJvb2xlYW4iLCJpc1ZhbHVlIiwib2JqZWN0Iiwibm9Vbmtub3duIiwiYXJyYXkiLCJ0dXBsZSIsInNwZWMiLCJ0eXBlTGVuIiwidHlwZXMiLCJBcnJheSIsImlzQXJyYXkiLCJsb2NhbGUiLCJjcmVhdGUiLCJpc1NjaGVtYSIsIm9iaiIsIl9faXNZdXBTY2hlbWFfXyIsIkNvbmRpdGlvbiIsImZyb21PcHRpb25zIiwicmVmcyIsImNvbmZpZyIsInRoZW4iLCJvdGhlcndpc2UiLCJUeXBlRXJyb3IiLCJpcyIsImNoZWNrIiwidmFsdWVzIiwiZXZlcnkiLCJzY2hlbWEiLCJfYnJhbmNoIiwiYnJhbmNoIiwiYnVpbGRlciIsImZuIiwicmVzb2x2ZSIsImJhc2UiLCJvcHRpb25zIiwibWFwIiwicmVmIiwiZ2V0VmFsdWUiLCJwYXJlbnQiLCJjb250ZXh0IiwidW5kZWZpbmVkIiwicHJlZml4ZXMiLCJjcmVhdGUkOSIsIlJlZmVyZW5jZSIsImlzQ29udGV4dCIsImlzU2libGluZyIsInByZWZpeCIsImNhc3QiLCJkZXNjcmliZSIsImlzUmVmIiwiX19pc1l1cFJlZiIsImlzQWJzZW50IiwiY3JlYXRlVmFsaWRhdGlvbiIsInZhbGlkYXRlIiwicGFuaWMiLCJuZXh0IiwidGVzdCIsInNraXBBYnNlbnQiLCJhYm9ydEVhcmx5IiwiaXRlbSIsImNyZWF0ZUVycm9yIiwib3ZlcnJpZGVzIiwibmV4dFBhcmFtcyIsImtleXMiLCJlcnJvciIsImludmFsaWQiLCJjdHgiLCJmcm9tIiwiaGFuZGxlUmVzdWx0IiwidmFsaWRPckVycm9yIiwiaGFuZGxlRXJyb3IiLCJzaG91bGRTa2lwIiwic3luYyIsIlByb21pc2UiLCJfcmVzdWx0IiwiT1BUSU9OUyIsImdldEluIiwibGFzdFBhcnQiLCJsYXN0UGFydERlYnVnIiwicGFyZW50UGF0aCIsIl9wYXJ0IiwiaXNCcmFja2V0IiwicGFydCIsImlzVHVwbGUiLCJpZHgiLCJwYXJzZUludCIsImlubmVyVHlwZSIsImZpZWxkcyIsInJlYWNoIiwiUmVmZXJlbmNlU2V0IiwiU2V0IiwiZGVzY3JpcHRpb24iLCJyZXNvbHZlQWxsIiwiY2xvbmUiLCJtZXJnZSIsIm5ld0l0ZW1zIiwicmVtb3ZlSXRlbXMiLCJhZGQiLCJkZWxldGUiLCJzcmMiLCJzZWVuIiwiTWFwIiwiaGFzIiwiZ2V0IiwiY29weSIsIkRhdGUiLCJzZXQiLCJpIiwiayIsInYiLCJlbnRyaWVzIiwiU2NoZW1hIiwiZGVwcyIsInRlc3RzIiwidHJhbnNmb3JtcyIsImNvbmRpdGlvbnMiLCJfbXV0YXRlIiwiaW50ZXJuYWxUZXN0cyIsIl93aGl0ZWxpc3QiLCJfYmxhY2tsaXN0IiwiZXhjbHVzaXZlVGVzdHMiLCJfdHlwZUNoZWNrIiwid2l0aE11dGF0aW9uIiwidHlwZUVycm9yIiwic3RyaXAiLCJzdHJpY3QiLCJyZWN1cnNpdmUiLCJudWxsYWJsZSIsIm9wdGlvbmFsIiwiY29lcmNlIiwicyIsIm5vbk51bGxhYmxlIiwiX3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIm1ldGEiLCJhcmdzIiwiYmVmb3JlIiwiY29tYmluZWQiLCJtZXJnZWRTcGVjIiwiaXNUeXBlIiwicmVkdWNlIiwicHJldlNjaGVtYSIsImNvbmRpdGlvbiIsInJlc29sdmVPcHRpb25zIiwiX29wdGlvbnMkc3RyaWN0IiwiX29wdGlvbnMkYWJvcnRFYXJseSIsIl9vcHRpb25zJHJlY3Vyc2l2ZSIsInJlc29sdmVkU2NoZW1hIiwiYWxsb3dPcHRpb25hbGl0eSIsImFzc2VydCIsIl9jYXN0IiwiZm9ybWF0dGVkVmFsdWUiLCJmb3JtYXR0ZWRSZXN1bHQiLCJyYXdWYWx1ZSIsInByZXZWYWx1ZSIsImdldERlZmF1bHQiLCJfdmFsaWRhdGUiLCJfdmFsdWUiLCJpbml0aWFsVGVzdHMiLCJydW5UZXN0cyIsImluaXRpYWxFcnJvcnMiLCJydW5PcHRpb25zIiwiZmlyZWQiLCJwYW5pY09uY2UiLCJhcmciLCJuZXh0T25jZSIsImNvdW50IiwibmVzdGVkRXJyb3JzIiwiZmluaXNoVGVzdFJ1biIsImFzTmVzdGVkVGVzdCIsImluZGV4Iiwib3JpZ2luYWxQYXJlbnQiLCJpc0luZGV4IiwidGVzdE9wdGlvbnMiLCJpbmNsdWRlcyIsInJlamVjdCIsInBhcnNlZCIsInZhbGlkYXRlZCIsInZhbGlkYXRlU3luYyIsImlzVmFsaWQiLCJpc1ZhbGlkU3luYyIsIl9nZXREZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwiZGVmIiwiYXJndW1lbnRzIiwiaXNTdHJpY3QiLCJudWxsYWJpbGl0eSIsIm9wdGlvbmFsaXR5Iiwibm90UmVxdWlyZWQiLCJ0cmFuc2Zvcm0iLCJvcHRzIiwiaXNFeGNsdXNpdmUiLCJleGNsdXNpdmUiLCJmaWx0ZXIiLCJ3aGVuIiwiZGVwIiwiZW51bXMiLCJ3aGl0ZUxpc3QiLCJ2YWxpZHMiLCJyZXNvbHZlZCIsImJsYWNrbGlzdCIsImludmFsaWRzIiwibiIsImxpc3QiLCJmaW5kSW5kZXgiLCJjIiwibWV0aG9kIiwiYWxpYXMiLCJyZXR1cm5zVHJ1ZSIsImNyZWF0ZSQ4IiwiTWl4ZWRTY2hlbWEiLCJjcmVhdGUkNyIsIkJvb2xlYW5TY2hlbWEiLCJCb29sZWFuIiwidmFsdWVPZiIsIl9yYXciLCJTdHJpbmciLCJpc1RydWUiLCJpc0ZhbHNlIiwibXNnIiwickVtYWlsIiwiclVybCIsInJVVUlEIiwiaXNUcmltbWVkIiwib2JqU3RyaW5nVGFnIiwiY3JlYXRlJDYiLCJTdHJpbmdTY2hlbWEiLCJzdHJWYWx1ZSIsInQiLCJyZWdleCIsImV4Y2x1ZGVFbXB0eVN0cmluZyIsInNlYXJjaCIsImVuc3VyZSIsInRvTG93ZXJDYXNlIiwidG9VcHBlckNhc2UiLCJpc05hTiQxIiwiY3JlYXRlJDUiLCJOdW1iZXJTY2hlbWEiLCJOdW1iZXIiLCJOYU4iLCJwYXJzZUZsb2F0IiwibGVzcyIsIm1vcmUiLCJpc0ludGVnZXIiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiX21ldGhvZCIsImF2YWlsIiwiaW5kZXhPZiIsIk1hdGgiLCJpc29SZWciLCJwYXJzZUlzb0RhdGUiLCJudW1lcmljS2V5cyIsIm1pbnV0ZXNPZmZzZXQiLCJ0aW1lc3RhbXAiLCJzdHJ1Y3QiLCJleGVjIiwic3Vic3RyIiwiVVRDIiwicGFyc2UiLCJpbnZhbGlkRGF0ZSIsImlzRGF0ZSIsImNyZWF0ZSQ0IiwiRGF0ZVNjaGVtYSIsIklOVkFMSURfREFURSIsInByZXBhcmVQYXJhbSIsInBhcmFtIiwibGltaXQiLCJzb3J0RmllbGRzIiwiZXhjbHVkZWRFZGdlcyIsImVkZ2VzIiwibm9kZXMiLCJleGNsdWRlcyIsImEiLCJiIiwiYWRkTm9kZSIsImRlcFBhdGgiLCJub2RlIiwicmV2ZXJzZSIsImFyciIsIkluZmluaXR5Iiwic29tZSIsImlpIiwiX2VyciRwYXRoIiwic29ydEJ5S2V5T3JkZXIiLCJwYXJzZUpzb24iLCJkZWVwUGFydGlhbCIsInBhcnRpYWwiLCJmaWVsZFNjaGVtYSIsInNldEZpZWxkcyIsIm5leHRBcnJheSIsImRlZXBIYXMiLCJwIiwibGFzdCIsInBvcCIsImlzT2JqZWN0IiwidW5rbm93biIsImtub3duIiwiZGVmYXVsdFNvcnQiLCJjcmVhdGUkMyIsIk9iamVjdFNjaGVtYSIsIl9zb3J0RXJyb3JzIiwiX25vZGVzIiwiX2V4Y2x1ZGVkRWRnZXMiLCJzaGFwZSIsIl9vcHRpb25zJHN0cmlwVW5rbm93biIsInN0cmlwVW5rbm93biIsInByb3BzIiwiaW50ZXJtZWRpYXRlVmFsdWUiLCJpbm5lck9wdGlvbnMiLCJfX3ZhbGlkYXRpbmciLCJpc0NoYW5nZWQiLCJwcm9wIiwiZXhpc3RzIiwiZmllbGRWYWx1ZSIsImlucHV0VmFsdWUiLCJmaWVsZFNwZWMiLCJvYmplY3RFcnJvcnMiLCJmaWVsZEVycm9ycyIsInNvcnQiLCJuZXh0RmllbGRzIiwic2NoZW1hT3JSZWYiLCJ0YXJnZXQiLCJkZnQiLCJfaW5uZXJPcHRpb25zIiwiYWRkaXRpb25zIiwiRnVuY3Rpb24iLCJwaWNrIiwicGlja2VkIiwib21pdCIsInRvIiwiZnJvbUdldHRlciIsIm5ld09iaiIsImpzb24iLCJub0FsbG93IiwidW5rbm93bktleXMiLCJhbGxvdyIsInRyYW5zZm9ybUtleXMiLCJjb25zdGFudENhc2UiLCJfaW5uZXJPcHRpb25zMiIsImNyZWF0ZSQyIiwiQXJyYXlTY2hlbWEiLCJfb3B0cyIsImNhc3RBcnJheSIsImNhc3RFbGVtZW50IiwiYXJyYXlFcnJvcnMiLCJfb3B0aW9ucyRvcmlnaW5hbFZhbHUyIiwiX29wdGlvbnMkb3JpZ2luYWxWYWx1IiwiaW5uZXJUeXBlRXJyb3JzIiwib2YiLCJvcmlnaW5hbCIsImNvbXBhY3QiLCJyZWplY3RvciIsImNyZWF0ZSQxIiwic2NoZW1hcyIsIlR1cGxlU2NoZW1hIiwiaXRlbVR5cGVzIiwidHVwbGVFcnJvcnMiLCJpdGVtU2NoZW1hIiwiTGF6eSIsIl9yZXNvbHZlIiwidmFsaWRhdGVBdCIsInZhbGlkYXRlU3luY0F0Iiwic2V0TG9jYWxlIiwiY3VzdG9tIiwiYWRkTWV0aG9kIiwic2NoZW1hVHlwZSIsImJvb2wiLCJkZWZhdWx0TG9jYWxlIiwibGF6eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8412\n")}}]);