"use strict";(self.webpackChunkelder_books_fe=self.webpackChunkelder_books_fe||[]).push([[6410],{4641:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  zt: () => (/* reexport */ components_Provider),\n  I0: () => (/* reexport */ useDispatch),\n  v9: () => (/* reexport */ useSelector)\n});\n\n// UNUSED EXPORTS: ReactReduxContext, batch, connect, createDispatchHook, createSelectorHook, createStoreHook, shallowEqual, useStore\n\n// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/index.js\nvar shim = __webpack_require__(4952);\n// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/with-selector.js\nvar with_selector = __webpack_require__(2345);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(6116);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/reactBatchedUpdates.js\n\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/batch.js\n// Default to a dummy \"batch\" implementation that just runs the callback\nfunction defaultNoopBatch(callback) {\n  callback();\n}\nlet batch = defaultNoopBatch; // Allow injecting another batching function later\n\nconst setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings\n\nconst getBatch = () => batch;\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(5466);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/Context.js\n\nconst ContextKey = Symbol.for(`react-redux-context`);\nconst gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\nfunction getContext() {\n  var _gT$ContextKey;\n  if (!react.createContext) return {};\n  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = new Map();\n  let realContext = contextMap.get(react.createContext);\n  if (!realContext) {\n    realContext = react.createContext(null);\n    if (false) {}\n    contextMap.set(react.createContext, realContext);\n  }\n  return realContext;\n}\nconst Context_ReactReduxContext = /*#__PURE__*/getContext();\n/* harmony default export */ const Context = ((/* unused pure expression or super */ null && (Context_ReactReduxContext)));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useReduxContext.js\n\n\n\n/**\n * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useReduxContext` hook bound to the specified context.\n */\nfunction createReduxContextHook(context = Context_ReactReduxContext) {\n  return function useReduxContext() {\n    const contextValue = (0,react.useContext)(context);\n    if (false) {}\n    return contextValue;\n  };\n}\n/**\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @returns {any} the value of the `ReactReduxContext`\n *\n * @example\n *\n * import React from 'react'\n * import { useReduxContext } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const { store } = useReduxContext()\n *   return <div>{store.getState()}</div>\n * }\n */\n\nconst useReduxContext_useReduxContext = /*#__PURE__*/createReduxContextHook();\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/useSyncExternalStore.js\nconst useSyncExternalStore_notInitialized = () => {\n  throw new Error('uSES not initialized!');\n};\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useSelector.js\n\n\n\n\nlet useSyncExternalStoreWithSelector = useSyncExternalStore_notInitialized;\nconst initializeUseSelector = fn => {\n  useSyncExternalStoreWithSelector = fn;\n};\nconst refEquality = (a, b) => a === b;\n/**\n * Hook factory, which creates a `useSelector` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useSelector` hook bound to the specified context.\n */\n\nfunction createSelectorHook(context = Context_ReactReduxContext) {\n  const useReduxContext = context === Context_ReactReduxContext ? useReduxContext_useReduxContext : createReduxContextHook(context);\n  return function useSelector(selector, equalityFnOrOptions = {}) {\n    const {\n      equalityFn = refEquality,\n      stabilityCheck = undefined,\n      noopCheck = undefined\n    } = typeof equalityFnOrOptions === 'function' ? {\n      equalityFn: equalityFnOrOptions\n    } : equalityFnOrOptions;\n    if (false) {}\n    const {\n      store,\n      subscription,\n      getServerState,\n      stabilityCheck: globalStabilityCheck,\n      noopCheck: globalNoopCheck\n    } = useReduxContext();\n    const firstRun = (0,react.useRef)(true);\n    const wrappedSelector = (0,react.useCallback)({\n      [selector.name](state) {\n        const selected = selector(state);\n        if (false) {}\n        return selected;\n      }\n    }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);\n    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    (0,react.useDebugValue)(selectedState);\n    return selectedState;\n  };\n}\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\n\nconst useSelector = /*#__PURE__*/createSelectorHook();\n// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(7773);\n// EXTERNAL MODULE: ./node_modules/react-is/index.js\nvar react_is = __webpack_require__(9972);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/warning.js\n/* provided dependency */ var console = __webpack_require__(1283);\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning_warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/verifySubselectors.js\n\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {\n    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {\n      warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, 'mapStateToProps');\n  verify(mapDispatchToProps, 'mapDispatchToProps');\n  verify(mergeProps, 'mergeProps');\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/selectorFactory.js\n\nconst _excluded = (/* unused pure expression or super */ null && ([\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"]));\n\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\n// TODO: Add more comments\n// The selector returned by selectorFactory will memoize its results,\n// allowing connect's shouldComponentUpdate to return false if final\n// props have not changed.\nfunction finalPropsSelectorFactory(dispatch, _ref) {\n  let {\n      initMapStateToProps,\n      initMapDispatchToProps,\n      initMergeProps\n    } = _ref,\n    options = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n  if (false) {}\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/verifyPlainObject.js\n\n\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/wrapMapToProps.js\n\nfunction wrapMapToProps_wrapMapToPropsConstant(\n// * Note:\n//  It seems that the dispatch argument\n//  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\n//  and a state object in some others (ex: whenMapStateToPropsIsMissing)\n// eslint-disable-next-line no-unused-vars\ngetConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\n\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\n\nfunction wrapMapToProps_wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, {\n    displayName\n  }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, undefined);\n    }; // allow detectFactoryAndVerify to get ownProps\n\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === 'function') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (false) {}\n      return props;\n    };\n    return proxy;\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapDispatchToProps.js\n\n\n\nfunction mapDispatchToProps_mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(dispatch =>\n  // @ts-ignore\n  bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant(dispatch => ({\n    dispatch\n  })) : typeof mapDispatchToProps === 'function' ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : createInvalidArgFactory(mapDispatchToProps, 'mapDispatchToProps');\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapStateToProps.js\n\n\nfunction mapStateToProps_mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === 'function' ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : createInvalidArgFactory(mapStateToProps, 'mapStateToProps');\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mergeProps.js\n\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  // @ts-ignore\n  return _extends({}, ownProps, stateProps, dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, {\n    displayName,\n    areMergedPropsEqual\n  }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (false) {}\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergeProps_mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, 'mergeProps');\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/Subscription.js\n // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\nfunction createListenerCollection() {\n  const batch = getBatch();\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n    notify() {\n      batch(() => {\n        let listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get() {\n      let listeners = [];\n      let listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe(callback) {\n      let isSubscribed = true;\n      let listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nconst nullListeners = {\n  notify() {},\n  get: () => []\n};\nfunction Subscription_createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n  function addNestedSub(listener) {\n    trySubscribe();\n    return listeners.subscribe(listener);\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return Boolean(unsubscribe);\n  }\n  function trySubscribe() {\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    if (unsubscribe) {\n      unsubscribe();\n      unsubscribe = undefined;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe,\n    tryUnsubscribe,\n    getListeners: () => listeners\n  };\n  return subscription;\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js\n // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n// Matches logic in React's `shared/ExecutionEnvironment` file\n\nconst canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\nconst useIsomorphicLayoutEffect_useIsomorphicLayoutEffect = canUseDOM ? react.useLayoutEffect : react.useEffect;\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/connect.js\n\n\nconst connect_excluded = (/* unused pure expression or super */ null && ([\"reactReduxForwardedRef\"]));\n\n/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet useSyncExternalStore = (/* unused pure expression or super */ null && (notInitialized));\nconst initializeConnect = fn => {\n  useSyncExternalStore = fn;\n}; // Define some constant arrays just to avoid re-creating these\n\nconst EMPTY_ARRAY = (/* unused pure expression or super */ null && ([null, 0]));\nconst NO_SUBSCRIPTION_ARRAY = (/* unused pure expression or super */ null && ([null, null])); // Attempts to stringify whatever not-really-a-component value we were given\n// for logging in an error message\n\nconst stringifyComponent = Comp => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\n\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\n// - we extract this to a separate function to avoid closing over values\n//   and causing memory leaks\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n} // Effect callback, extracted: assign the latest props values to refs for later usage\n\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps,\n// actualChildProps: unknown,\nchildPropsFromStoreUpdate, notifyNestedSubs) {\n  // We want to capture the wrapper props and child props we used for later comparisons\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update\n\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n} // Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\n// check for updates after dispatched actions, and trigger re-renders.\n\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs,\n// forceComponentUpdateDispatch: React.Dispatch<any>,\nadditionalSubscribeListener) {\n  // If we're not subscribed to the store, nothing to do here\n  if (!shouldHandleStateChanges) return () => {}; // Capture values for checking if and when this component unmounts\n\n  let didUnsubscribe = false;\n  let lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component\n\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      // Don't run stale listeners.\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n      return;\n    } // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\n\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n    try {\n      // Actually run the selector with the most recent store state and wrapper props\n      // to determine what the child props should be\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    } // If the child props haven't changed, nothing to do here - cascade the subscription update\n\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n      // forcing another re-render, which we don't want.\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true; // TODO This is hacky and not how `uSES` is meant to be used\n      // Trigger the React `useSyncExternalStore` subscriber\n\n      additionalSubscribeListener();\n    }\n  }; // Actually subscribe to the nearest connected ancestor (or store)\n\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe(); // Pull data from the store after first render in case the store has\n  // changed since we began.\n\n  checkForUpdates();\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      // It's possible that we caught an error due to a bad mapState function, but the\n      // parent re-rendered without this component and we're about to unmount.\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\n      // if we ever do those wrong, this throw will surface the error in our tests.\n      // In that case, throw the error from here so it doesn't get lost.\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n} // Reducer initial state creation for our update reducer\n\nconst initStateUpdates = () => EMPTY_ARRAY;\nfunction strictEqual(a, b) {\n  return a === b;\n}\n/**\n * Infers the type of props that a connector will inject into a component.\n */\n\nlet hasWarnedAboutDeprecatedPureOption = false;\n/**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior / props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that's\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user's responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps A function that extracts values from state\n * @param mapDispatchToProps Setup for dispatching actions\n * @param mergeProps Optional callback to merge state and dispatch props together\n * @param options Options for configuring the connection\n *\n */\n\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React's forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = ReactReduxContext\n} = {}) {\n  if (false) {}\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n  const wrapWithConnect = WrappedComponent => {\n    if (false) {}\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {\n        // Distinguish between actual \"data\" props that were passed to the wrapper component,\n        // and values needed to control behavior (forwarded refs, alternate context instances).\n        // To maintain the wrapperProps object reference, memoize this destructuring.\n        const {\n            reactReduxForwardedRef\n          } = props,\n          wrapperProps = _objectWithoutPropertiesLoose(props, connect_excluded);\n        return [props.context, reactReduxForwardedRef, wrapperProps];\n      }, [props]);\n      const ContextToUse = React.useMemo(() => {\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n        // Memoize the check that determines which context instance we should use.\n        return propsContext && propsContext.Consumer &&\n        // @ts-ignore\n        isContextConsumer( /*#__PURE__*/React.createElement(propsContext.Consumer, null)) ? propsContext : Context;\n      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available\n\n      const contextValue = React.useContext(ContextToUse); // The store _must_ exist as either a prop or in context.\n      // We'll check to see if it _looks_ like a Redux store first.\n      // This allows us to pass through a `store` prop that is just a plain value.\n\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if (false) {} // Based on the previous check, one of these must be true\n\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = React.useMemo(() => {\n        // The child props selector needs the store reference as an input.\n        // Re-create this selector whenever the store changes.\n        return defaultSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n\n        const subscription = createSubscription(store, didStoreComeFromProps ? undefined : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `subscription` will then be null. This can\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\n        // that have been unsubscribed in the  middle of the notification loop.\n\n        const notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);\n        return [subscription, notifyNestedSubs];\n      }, [store, didStoreComeFromProps, contextValue]); // Determine what {store, subscription} value should be put into nested context, if necessary,\n      // and memoize that value to avoid unnecessary context updates.\n\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          // This component is directly subscribed to a store from props.\n          // We don't want descendants reading from this store - pass down whatever\n          // the existing context value is from the nearest connected ancestor.\n          return contextValue;\n        } // Otherwise, put this component's subscription instance into context, so that\n        // connected descendants won't update until after this component is done\n\n        return _extends({}, contextValue, {\n          subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]); // Set up refs to coordinate values between the subscription effect and the render logic\n\n      const lastChildProps = React.useRef();\n      const lastWrapperProps = React.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = React.useRef();\n      const renderIsScheduled = React.useRef(false);\n      const isProcessingDispatch = React.useRef(false);\n      const isMounted = React.useRef(false);\n      const latestSubscriptionCallbackError = React.useRef();\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          // Tricky logic here:\n          // - This render may have been triggered by a Redux store update that produced new child props\n          // - However, we may have gotten new wrapper props after that\n          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n          // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          } // TODO We're reading the store directly in render() here. Bad idea?\n          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n          // to determine what the child props should be.\n\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n      // just useEffect instead to avoid the warning, since neither will run anyway.\n\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = reactListener => {\n          if (!subscription) {\n            return () => {};\n          }\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription,\n          // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      let actualChildProps;\n      try {\n        actualChildProps = useSyncExternalStore(\n        // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact,\n        // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`;\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = undefined;\n        childPropsFromStoreUpdate.current = undefined;\n        lastChildProps.current = actualChildProps;\n      }); // Now that all that's done, we can finally try to actually render the child component.\n      // We memoize the elements for the rendered child component as an optimization.\n\n      const renderedWrappedComponent = React.useMemo(() => {\n        return /*#__PURE__*/(\n          // @ts-ignore\n          React.createElement(WrappedComponent, _extends({}, actualChildProps, {\n            ref: reactReduxForwardedRef\n          }))\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          // If this component is subscribed to store updates, we need to pass its own\n          // subscription instance down to our descendants. That means rendering the same\n          // Context instance, and putting a different value into the context.\n          return /*#__PURE__*/React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    const _Connect = React.memo(ConnectFunction);\n\n    // Add a hacky cast to get the right output type\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        // @ts-ignore\n        return /*#__PURE__*/React.createElement(Connect, _extends({}, props, {\n          reactReduxForwardedRef: ref\n        }));\n      });\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return hoistStatics(forwarded, WrappedComponent);\n    }\n    return hoistStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\n/* harmony default export */ const components_connect = ((/* unused pure expression or super */ null && (connect)));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/Provider.js\n\n\n\n\nfunction Provider({\n  store,\n  context,\n  children,\n  serverState,\n  stabilityCheck = 'once',\n  noopCheck = 'once'\n}) {\n  const contextValue = react.useMemo(() => {\n    const subscription = Subscription_createSubscription(store);\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : undefined,\n      stabilityCheck,\n      noopCheck\n    };\n  }, [store, serverState, stabilityCheck, noopCheck]);\n  const previousState = react.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect_useIsomorphicLayoutEffect(() => {\n    const {\n      subscription\n    } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = undefined;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || Context_ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype\n\n  return /*#__PURE__*/react.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n/* harmony default export */ const components_Provider = (Provider);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useStore.js\n\n\n/**\n * Hook factory, which creates a `useStore` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useStore` hook bound to the specified context.\n */\n\nfunction createStoreHook(context = Context_ReactReduxContext) {\n  const useReduxContext =\n  // @ts-ignore\n  context === Context_ReactReduxContext ? useReduxContext_useReduxContext :\n  // @ts-ignore\n  createReduxContextHook(context);\n  return function useStore() {\n    const {\n      store\n    } = useReduxContext(); // @ts-ignore\n\n    return store;\n  };\n}\n/**\n * A hook to access the redux store.\n *\n * @returns {any} the redux store\n *\n * @example\n *\n * import React from 'react'\n * import { useStore } from 'react-redux'\n *\n * export const ExampleComponent = () => {\n *   const store = useStore()\n *   return <div>{store.getState()}</div>\n * }\n */\n\nconst useStore_useStore = /*#__PURE__*/createStoreHook();\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useDispatch.js\n\n\n/**\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useDispatch` hook bound to the specified context.\n */\n\nfunction createDispatchHook(context = Context_ReactReduxContext) {\n  const useStore =\n  // @ts-ignore\n  context === Context_ReactReduxContext ? useStore_useStore : createStoreHook(context);\n  return function useDispatch() {\n    const store = useStore(); // @ts-ignore\n\n    return store.dispatch;\n  };\n}\n/**\n * A hook to access the redux `dispatch` function.\n *\n * @returns {any|function} redux store's `dispatch` function\n *\n * @example\n *\n * import React, { useCallback } from 'react'\n * import { useDispatch } from 'react-redux'\n *\n * export const CounterComponent = ({ value }) => {\n *   const dispatch = useDispatch()\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\n *   return (\n *     <div>\n *       <span>{value}</span>\n *       <button onClick={increaseCounter}>Increase counter</button>\n *     </div>\n *   )\n * }\n */\n\nconst useDispatch = /*#__PURE__*/createDispatchHook();\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/exports.js\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/index.js\n// The primary entry point assumes we're working with standard ReactDOM/RN, but\n// older versions that do not include `useSyncExternalStore` (React 16.9 - 17.x).\n// Because of that, the useSyncExternalStore compat shim is needed.\n\n\n\n\n\n\ninitializeUseSelector(with_selector.useSyncExternalStoreWithSelector);\ninitializeConnect(shim.useSyncExternalStore); // Enable batched updates in our subscriptions for use\n// with standard React renderers (ReactDOM, React Native)\n\nsetBatch(react_dom.unstable_batchedUpdates);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QnJPLE9BQU8sS0FBS0gseUJBQWlCLEdBQUd5TyxpQkFBZSxHQUFHRixlQUFlLENBQUNwTyxPQUFPLENBQUM7RUFDMUUsT0FBTyxTQUFTd08sV0FBV0EsQ0FBQSxFQUFHO0lBQzVCLE1BQU1qTixLQUFLLEdBQUc4TSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBRTFCLE9BQU85TSxLQUFLLENBQUNxQyxRQUFRO0VBQ3ZCLENBQUM7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxNQUFNNEssV0FBVyxHQUFHLGFBQWFELGtCQUFrQixDQUFDLENBQUMsQzs7QUN4Q2Y7QUFDRjtBQUNjO0FBQ2E7QUFDQTtBQUNUO0FBQ2I7QUFDeEI7OztBQ1B4QjtBQUNBO0FBQ0E7QUFDb0U7QUFDMEI7QUFDZjtBQUN0QztBQUNtQjtBQUNIO0FBQ3pEN04scUJBQXFCLENBQUNELDhDQUFnQyxDQUFDO0FBQ3ZEb0osaUJBQWlCLENBQUNELHlCQUFvQixDQUFDLENBQUMsQ0FBQztBQUN6Qzs7QUFFQXBMLFFBQVEsQ0FBQ0QsaUNBQUssQ0FBQztBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvcmVhY3RCYXRjaGVkVXBkYXRlcy5qcz9mNWY1Iiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL2JhdGNoLmpzPzRkZjIiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Db250ZXh0LmpzPzhlODciLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlUmVkdXhDb250ZXh0LmpzPzk4MjUiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdXNlU3luY0V4dGVybmFsU3RvcmUuanM/YjQ4MCIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTZWxlY3Rvci5qcz8zMzljIiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanM/ZDk1ZiIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcz8xMGZjIiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LmpzPzc5MDYiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanM/NGNiMiIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLmpzPzI0MjUiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanM/MmY1ZCIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcz9lNDU3Iiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qcz9iZjRjIiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qcz83OWQ2Iiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QuanM/NTdlNiIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL2Nvbm5lY3QuanM/YzhkYSIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzPzExZjgiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlU3RvcmUuanM/Y2I4NyIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VEaXNwYXRjaC5qcz9lZTI0Iiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2V4cG9ydHMuanM/NGE3MSIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qcz9mY2MyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSAncmVhY3QtZG9tJzsiLCIvLyBEZWZhdWx0IHRvIGEgZHVtbXkgXCJiYXRjaFwiIGltcGxlbWVudGF0aW9uIHRoYXQganVzdCBydW5zIHRoZSBjYWxsYmFja1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG5sZXQgYmF0Y2ggPSBkZWZhdWx0Tm9vcEJhdGNoOyAvLyBBbGxvdyBpbmplY3RpbmcgYW5vdGhlciBiYXRjaGluZyBmdW5jdGlvbiBsYXRlclxuXG5leHBvcnQgY29uc3Qgc2V0QmF0Y2ggPSBuZXdCYXRjaCA9PiBiYXRjaCA9IG5ld0JhdGNoOyAvLyBTdXBwbHkgYSBnZXR0ZXIganVzdCB0byBza2lwIGRlYWxpbmcgd2l0aCBFU00gYmluZGluZ3NcblxuZXhwb3J0IGNvbnN0IGdldEJhdGNoID0gKCkgPT4gYmF0Y2g7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuY29uc3QgQ29udGV4dEtleSA9IFN5bWJvbC5mb3IoYHJlYWN0LXJlZHV4LWNvbnRleHRgKTtcbmNvbnN0IGdUID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDpcbi8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xue307XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIHZhciBfZ1QkQ29udGV4dEtleTtcblxuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpIHJldHVybiB7fTtcbiAgY29uc3QgY29udGV4dE1hcCA9IChfZ1QkQ29udGV4dEtleSA9IGdUW0NvbnRleHRLZXldKSAhPSBudWxsID8gX2dUJENvbnRleHRLZXkgOiBnVFtDb250ZXh0S2V5XSA9IG5ldyBNYXAoKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG5cbiAgaWYgKCFyZWFsQ29udGV4dCkge1xuICAgIHJlYWxDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdSZWFjdFJlZHV4JztcbiAgICB9XG5cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmVhbENvbnRleHQ7XG59XG5cbmV4cG9ydCBjb25zdCBSZWFjdFJlZHV4Q29udGV4dCA9IC8qI19fUFVSRV9fKi9nZXRDb250ZXh0KCk7XG5leHBvcnQgZGVmYXVsdCBSZWFjdFJlZHV4Q29udGV4dDsiLCJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnO1xuXG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VSZWR1eENvbnRleHRgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LiBUaGlzIGlzIGEgbG93LWxldmVsXG4gKiBob29rIHRoYXQgeW91IHNob3VsZCB1c3VhbGx5IG5vdCBuZWVkIHRvIGNhbGwgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVJlZHV4Q29udGV4dGAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0KCkge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZUNvbnRleHQoY29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPicpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gIH07XG59XG4vKipcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgLiBUaGlzIGlzIGEgbG93LWxldmVsXG4gKiBob29rIHRoYXQgeW91IHNob3VsZCB1c3VhbGx5IG5vdCBuZWVkIHRvIGNhbGwgZGlyZWN0bHkuXG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VSZWR1eENvbnRleHQgfSBmcm9tICdyZWFjdC1yZWR1eCdcbiAqXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgeyBzdG9yZSB9ID0gdXNlUmVkdXhDb250ZXh0KClcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XG4gKiB9XG4gKi9cblxuZXhwb3J0IGNvbnN0IHVzZVJlZHV4Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVSZWR1eENvbnRleHRIb29rKCk7IiwiZXhwb3J0IGNvbnN0IG5vdEluaXRpYWxpemVkID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3VTRVMgbm90IGluaXRpYWxpemVkIScpO1xufTsiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUmVkdXhDb250ZXh0SG9vaywgdXNlUmVkdXhDb250ZXh0IGFzIHVzZURlZmF1bHRSZWR1eENvbnRleHQgfSBmcm9tICcuL3VzZVJlZHV4Q29udGV4dCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyBub3RJbml0aWFsaXplZCB9IGZyb20gJy4uL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbmxldCB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IG5vdEluaXRpYWxpemVkO1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVVc2VTZWxlY3RvciA9IGZuID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmbjtcbn07XG5cbmNvbnN0IHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VTZWxlY3RvcmAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVNlbGVjdG9yYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dCA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlRGVmYXVsdFJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VTZWxlY3RvcihzZWxlY3RvciwgZXF1YWxpdHlGbk9yT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgZXF1YWxpdHlGbiA9IHJlZkVxdWFsaXR5LFxuICAgICAgc3RhYmlsaXR5Q2hlY2sgPSB1bmRlZmluZWQsXG4gICAgICBub29wQ2hlY2sgPSB1bmRlZmluZWRcbiAgICB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zXG4gICAgfSA6IGVxdWFsaXR5Rm5Pck9wdGlvbnM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGFuIGVxdWFsaXR5IGZ1bmN0aW9uIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSxcbiAgICAgIHN0YWJpbGl0eUNoZWNrOiBnbG9iYWxTdGFiaWxpdHlDaGVjayxcbiAgICAgIG5vb3BDaGVjazogZ2xvYmFsTm9vcENoZWNrXG4gICAgfSA9IHVzZVJlZHV4Q29udGV4dCgpO1xuICAgIGNvbnN0IGZpcnN0UnVuID0gdXNlUmVmKHRydWUpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IHVzZUNhbGxiYWNrKHtcbiAgICAgIFtzZWxlY3Rvci5uYW1lXShzdGF0ZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdG9yKHN0YXRlKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnN0IGZpbmFsU3RhYmlsaXR5Q2hlY2sgPSB0eXBlb2Ygc3RhYmlsaXR5Q2hlY2sgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsU3RhYmlsaXR5Q2hlY2sgOiBzdGFiaWxpdHlDaGVjaztcblxuICAgICAgICAgIGlmIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSAnYWx3YXlzJyB8fCBmaW5hbFN0YWJpbGl0eUNoZWNrID09PSAnb25jZScgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgdG9Db21wYXJlID0gc2VsZWN0b3Ioc3RhdGUpO1xuXG4gICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZWxlY3RvciAnICsgKHNlbGVjdG9yLm5hbWUgfHwgJ3Vua25vd24nKSArICcgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gY2FsbGVkIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycy4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuJyArICdcXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gYSBuZXcgcmVmZXJlbmNlIChzdWNoIGFzIGFuIG9iamVjdCBvciBhbiBhcnJheSkgc2hvdWxkIGJlIG1lbW9pemVkOiBodHRwczovL3JlZHV4LmpzLm9yZy91c2FnZS9kZXJpdmluZy1kYXRhLXNlbGVjdG9ycyNvcHRpbWl6aW5nLXNlbGVjdG9ycy13aXRoLW1lbW9pemF0aW9uJywge1xuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkMjogdG9Db21wYXJlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZpbmFsTm9vcENoZWNrID0gdHlwZW9mIG5vb3BDaGVjayA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxOb29wQ2hlY2sgOiBub29wQ2hlY2s7XG5cbiAgICAgICAgICBpZiAoZmluYWxOb29wQ2hlY2sgPT09ICdhbHdheXMnIHx8IGZpbmFsTm9vcENoZWNrID09PSAnb25jZScgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NlbGVjdG9yICcgKyAoc2VsZWN0b3IubmFtZSB8fCAndW5rbm93bicpICsgJyByZXR1cm5lZCB0aGUgcm9vdCBzdGF0ZSB3aGVuIGNhbGxlZC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuJyArICdcXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZSBhcmUgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UsIGFzIHRoZXkgd2lsbCBjYXVzZSBhIHJlcmVuZGVyIHdoZW5ldmVyICphbnl0aGluZyogaW4gc3RhdGUgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmlyc3RSdW4uY3VycmVudCkgZmlyc3RSdW4uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuXG4gICAgfVtzZWxlY3Rvci5uYW1lXSwgW3NlbGVjdG9yLCBnbG9iYWxTdGFiaWxpdHlDaGVjaywgc3RhYmlsaXR5Q2hlY2tdKTtcbiAgICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaXB0aW9uLmFkZE5lc3RlZFN1Yiwgc3RvcmUuZ2V0U3RhdGUsIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLCB3cmFwcGVkU2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xuICAgIHVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG4gIH07XG59XG4vKipcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHJlZHV4IHN0b3JlJ3Mgc3RhdGUuIFRoaXMgaG9vayB0YWtlcyBhIHNlbGVjdG9yIGZ1bmN0aW9uXG4gKiBhcyBhbiBhcmd1bWVudC4gVGhlIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBzdG9yZSBzdGF0ZS5cbiAqXG4gKiBUaGlzIGhvb2sgdGFrZXMgYW4gb3B0aW9uYWwgZXF1YWxpdHkgY29tcGFyaXNvbiBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxuICogdGhhdCBhbGxvd3MgeW91IHRvIGN1c3RvbWl6ZSB0aGUgd2F5IHRoZSBzZWxlY3RlZCBzdGF0ZSBpcyBjb21wYXJlZCB0byBkZXRlcm1pbmVcbiAqIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBuZWVkcyB0byBiZSByZS1yZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciB0aGUgc2VsZWN0b3IgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBlcXVhbGl0eUZuIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHlcbiAqXG4gKiBAcmV0dXJucyB7YW55fSB0aGUgc2VsZWN0ZWQgc3RhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IHVzZVNlbGVjdG9yIH0gZnJvbSAncmVhY3QtcmVkdXgnXG4gKlxuICogZXhwb3J0IGNvbnN0IENvdW50ZXJDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IGNvdW50ZXIgPSB1c2VTZWxlY3RvcihzdGF0ZSA9PiBzdGF0ZS5jb3VudGVyKVxuICogICByZXR1cm4gPGRpdj57Y291bnRlcn08L2Rpdj5cbiAqIH1cbiAqL1xuXG5leHBvcnQgY29uc3QgdXNlU2VsZWN0b3IgPSAvKiNfX1BVUkVfXyovY3JlYXRlU2VsZWN0b3JIb29rKCk7IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG5cbn0iLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgZm9yICR7bWV0aG9kTmFtZX0gaW4gY29ubmVjdC5gKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCAnZGVwZW5kc09uT3duUHJvcHMnKSkge1xuICAgICAgd2FybmluZyhgVGhlIHNlbGVjdG9yIGZvciAke21ldGhvZE5hbWV9IG9mIGNvbm5lY3QgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLmApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gIHZlcmlmeShtZXJnZVByb3BzLCAnbWVyZ2VQcm9wcycpO1xufSIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wiaW5pdE1hcFN0YXRlVG9Qcm9wc1wiLCBcImluaXRNYXBEaXNwYXRjaFRvUHJvcHNcIiwgXCJpbml0TWVyZ2VQcm9wc1wiXTtcbmltcG9ydCB2ZXJpZnlTdWJzZWxlY3RvcnMgZnJvbSAnLi92ZXJpZnlTdWJzZWxlY3RvcnMnO1xuZXhwb3J0IGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwge1xuICBhcmVTdGF0ZXNFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsXG59KSB7XG4gIGxldCBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGxldCBvd25Qcm9wcztcbiAgbGV0IHN0YXRlUHJvcHM7XG4gIGxldCBkaXNwYXRjaFByb3BzO1xuICBsZXQgbWVyZ2VkUHJvcHM7XG5cbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBmaXJzdE93blByb3BzO1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIGNvbnN0IG5leHRTdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgY29uc3Qgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgaWYgKHN0YXRlUHJvcHNDaGFuZ2VkKSBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChuZXh0U3RhdGUsIHN0YXRlLCBuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHMoKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3U3RhdGUoKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufVxuLy8gVE9ETzogQWRkIG1vcmUgY29tbWVudHNcbi8vIFRoZSBzZWxlY3RvciByZXR1cm5lZCBieSBzZWxlY3RvckZhY3Rvcnkgd2lsbCBtZW1vaXplIGl0cyByZXN1bHRzLFxuLy8gYWxsb3dpbmcgY29ubmVjdCdzIHNob3VsZENvbXBvbmVudFVwZGF0ZSB0byByZXR1cm4gZmFsc2UgaWYgZmluYWxcbi8vIHByb3BzIGhhdmUgbm90IGNoYW5nZWQuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KGRpc3BhdGNoLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgIGluaXRNZXJnZVByb3BzXG4gIH0gPSBfcmVmLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gaW5pdE1hcFN0YXRlVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcbiAgfVxuXG4gIHJldHVybiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufSIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3dhcm5pbmcnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKGAke21ldGhvZE5hbWV9KCkgaW4gJHtkaXNwbGF5TmFtZX0gbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHt2YWx1ZX0uYCk7XG4gIH1cbn0iLCJpbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoIC8vICogTm90ZTpcbi8vICBJdCBzZWVtcyB0aGF0IHRoZSBkaXNwYXRjaCBhcmd1bWVudFxuLy8gIGNvdWxkIGJlIGEgZGlzcGF0Y2ggZnVuY3Rpb24gaW4gc29tZSBjYXNlcyAoZXg6IHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcpXG4vLyAgYW5kIGEgc3RhdGUgb2JqZWN0IGluIHNvbWUgb3RoZXJzIChleDogd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZylcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCk7XG5cbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cblxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn0gLy8gZGVwZW5kc09uT3duUHJvcHMgaXMgdXNlZCBieSBjcmVhdGVNYXBUb1Byb3BzUHJveHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGFzcyBwcm9wcyBhcyBhcmdzXG4vLyB0byB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyB3cmFwcGVkLiBJdCBpcyBhbHNvIHVzZWQgYnkgbWFrZVB1cmVQcm9wc1NlbGVjdG9yIHRvIGRldGVybWluZVxuLy8gd2hldGhlciBtYXBUb1Byb3BzIG5lZWRzIHRvIGJlIGludm9rZWQgd2hlbiBwcm9wcyBoYXZlIGNoYW5nZWQuXG4vL1xuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cbi8vIFRPRE8gQ2FuIHRoaXMgZ2V0IHB1bGxlZCBvdXQgc28gdGhhdCB3ZSBjYW4gc3Vic2NyaWJlIGRpcmVjdGx5IHRvIHRoZSBzdG9yZSBpZiB3ZSBkb24ndCBuZWVkIG93blByb3BzP1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn0gLy8gVXNlZCBieSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiBhbmQgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sXG4vLyB0aGlzIGZ1bmN0aW9uIHdyYXBzIG1hcFRvUHJvcHMgaW4gYSBwcm94eSBmdW5jdGlvbiB3aGljaCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuLy9cbi8vICAqIERldGVjdHMgd2hldGhlciB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgZGVwZW5kcyBvbiBwcm9wcywgd2hpY2hcbi8vICAgIGlzIHVzZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHRvIGRlY2lkZSBpZiBpdCBzaG91bGQgcmVpbnZva2Ugb24gcHJvcHMgY2hhbmdlcy5cbi8vXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCBoYW5kbGVzIG1hcFRvUHJvcHMgaWYgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLCBhbmQgdHJlYXRzIHRoYXRcbi8vICAgIG5ldyBmdW5jdGlvbiBhcyB0aGUgdHJ1ZSBtYXBUb1Byb3BzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuLy9cbi8vICAqIE9uIGZpcnN0IGNhbGwsIHZlcmlmaWVzIHRoZSBmaXJzdCByZXN1bHQgaXMgYSBwbGFpbiBvYmplY3QsIGluIG9yZGVyIHRvIHdhcm5cbi8vICAgIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGVpciBtYXBUb1Byb3BzIGZ1bmN0aW9uIGlzIG5vdCByZXR1cm5pbmcgYSB2YWxpZCByZXN1bHQuXG4vL1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7XG4gICAgZGlzcGxheU5hbWVcbiAgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdW5kZWZpbmVkKTtcbiAgICB9OyAvLyBhbGxvdyBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IHRvIGdldCBvd25Qcm9wc1xuXG5cbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG5cbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufSIsImltcG9ydCBiaW5kQWN0aW9uQ3JlYXRvcnMgZnJvbSAnLi4vdXRpbHMvYmluZEFjdGlvbkNyZWF0b3JzJztcbmltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkgfSBmcm9tICcuL2ludmFsaWRBcmdGYWN0b3J5JztcbmV4cG9ydCBmdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdvYmplY3QnID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChkaXNwYXRjaCA9PiAvLyBAdHMtaWdub3JlXG4gIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKSkgOiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChkaXNwYXRjaCA9PiAoe1xuICAgIGRpc3BhdGNoXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyAvLyBAdHMtaWdub3JlXG4gIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xufSIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkgfSBmcm9tICcuL2ludmFsaWRBcmdGYWN0b3J5JztcbmV4cG9ydCBmdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcFN0YXRlVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKCkgPT4gKHt9KSkgOiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gLy8gQHRzLWlnbm9yZVxuICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSB9IGZyb20gJy4vaW52YWxpZEFyZ0ZhY3RvcnknO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvd25Qcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIHtcbiAgICBkaXNwbGF5TmFtZSxcbiAgICBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gIH0pIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIGxldCBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKSBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgJ21lcmdlUHJvcHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgJ21lcmdlUHJvcHMnKTtcbn0iLCJpbXBvcnQgeyBnZXRCYXRjaCB9IGZyb20gJy4vYmF0Y2gnOyAvLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGNvbnN0IGJhdGNoID0gZ2V0QmF0Y2goKTtcbiAgbGV0IGZpcnN0ID0gbnVsbDtcbiAgbGV0IGxhc3QgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGNsZWFyKCkge1xuICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgbGFzdCA9IG51bGw7XG4gICAgfSxcblxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3Q7XG5cbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXQoKSB7XG4gICAgICBsZXQgbGlzdGVuZXJzID0gW107XG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcblxuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgIH0sXG5cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgbGV0IGxpc3RlbmVyID0gbGFzdCA9IHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHByZXY6IGxhc3RcbiAgICAgIH07XG5cbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufVxuXG5jb25zdCBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnkoKSB7fSxcblxuICBnZXQ6ICgpID0+IFtdXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gIGxldCB1bnN1YnNjcmliZTtcbiAgbGV0IGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG5cbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuIGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICBsaXN0ZW5lcnMubm90aWZ5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odW5zdWJzY3JpYmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIGxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gdW5kZWZpbmVkO1xuICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICBhZGROZXN0ZWRTdWIsXG4gICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICBoYW5kbGVDaGFuZ2VXcmFwcGVyLFxuICAgIGlzU3Vic2NyaWJlZCxcbiAgICB0cnlTdWJzY3JpYmUsXG4gICAgdHJ5VW5zdWJzY3JpYmUsXG4gICAgZ2V0TGlzdGVuZXJzOiAoKSA9PiBsaXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbn0iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7IC8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLiBXZSBuZWVkIHVzZUxheW91dEVmZmVjdCB0byBlbnN1cmUgdGhlIHN0b3JlXG4vLyBzdWJzY3JpcHRpb24gY2FsbGJhY2sgYWx3YXlzIGhhcyB0aGUgc2VsZWN0b3IgZnJvbSB0aGUgbGF0ZXN0IHJlbmRlciBjb21taXRcbi8vIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc3RvcmUgdXBkYXRlIG1heSBoYXBwZW4gYmV0d2VlbiByZW5kZXIgYW5kIHRoZSBlZmZlY3QsXG4vLyB3aGljaCBtYXkgY2F1c2UgbWlzc2VkIHVwZGF0ZXM7IHdlIGFsc28gbXVzdCBlbnN1cmUgdGhlIHN0b3JlIHN1YnNjcmlwdGlvblxuLy8gaXMgY3JlYXRlZCBzeW5jaHJvbm91c2x5LCBvdGhlcndpc2UgYSBzdG9yZSB1cGRhdGUgbWF5IG9jY3VyIGJlZm9yZSB0aGVcbi8vIHN1YnNjcmlwdGlvbiBpcyBjcmVhdGVkIGFuZCBhbiBpbmNvbnNpc3RlbnQgc3RhdGUgbWF5IGJlIG9ic2VydmVkXG4vLyBNYXRjaGVzIGxvZ2ljIGluIFJlYWN0J3MgYHNoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudGAgZmlsZVxuXG5leHBvcnQgY29uc3QgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5leHBvcnQgY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wicmVhY3RSZWR1eEZvcndhcmRlZFJlZlwiXTtcblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc1ZhbGlkRWxlbWVudFR5cGUsIGlzQ29udGV4dENvbnN1bWVyIH0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgZnJvbSAnLi4vY29ubmVjdC9zZWxlY3RvckZhY3RvcnknO1xuaW1wb3J0IHsgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeSB9IGZyb20gJy4uL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzJztcbmltcG9ydCB7IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkgfSBmcm9tICcuLi9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcyc7XG5pbXBvcnQgeyBtZXJnZVByb3BzRmFjdG9yeSB9IGZyb20gJy4uL2Nvbm5lY3QvbWVyZ2VQcm9wcyc7XG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpcHRpb24gfSBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4uL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QnO1xuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuLi91dGlscy9zaGFsbG93RXF1YWwnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vdXRpbHMvd2FybmluZyc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vQ29udGV4dCc7XG5pbXBvcnQgeyBub3RJbml0aWFsaXplZCB9IGZyb20gJy4uL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbmxldCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IG5vdEluaXRpYWxpemVkO1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVDb25uZWN0ID0gZm4gPT4ge1xuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZuO1xufTsgLy8gRGVmaW5lIHNvbWUgY29uc3RhbnQgYXJyYXlzIGp1c3QgdG8gYXZvaWQgcmUtY3JlYXRpbmcgdGhlc2VcblxuY29uc3QgRU1QVFlfQVJSQVkgPSBbbnVsbCwgMF07XG5jb25zdCBOT19TVUJTQ1JJUFRJT05fQVJSQVkgPSBbbnVsbCwgbnVsbF07IC8vIEF0dGVtcHRzIHRvIHN0cmluZ2lmeSB3aGF0ZXZlciBub3QtcmVhbGx5LWEtY29tcG9uZW50IHZhbHVlIHdlIHdlcmUgZ2l2ZW5cbi8vIGZvciBsb2dnaW5nIGluIGFuIGVycm9yIG1lc3NhZ2VcblxuY29uc3Qgc3RyaW5naWZ5Q29tcG9uZW50ID0gQ29tcCA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuXG4vLyBUaGlzIGlzIFwianVzdFwiIGEgYHVzZUxheW91dEVmZmVjdGAsIGJ1dCB3aXRoIHR3byBtb2RpZmljYXRpb25zOlxuLy8gLSB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byBgdXNlRWZmZWN0YCBpbiBTU1IgdG8gYXZvaWQgYW5ub3lpbmcgd2FybmluZ3Ncbi8vIC0gd2UgZXh0cmFjdCB0aGlzIHRvIGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgY2xvc2luZyBvdmVyIHZhbHVlc1xuLy8gICBhbmQgY2F1c2luZyBtZW1vcnkgbGVha3NcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhlZmZlY3RGdW5jLCBlZmZlY3RBcmdzLCBkZXBlbmRlbmNpZXMpIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBlZmZlY3RGdW5jKC4uLmVmZmVjdEFyZ3MpLCBkZXBlbmRlbmNpZXMpO1xufSAvLyBFZmZlY3QgY2FsbGJhY2ssIGV4dHJhY3RlZDogYXNzaWduIHRoZSBsYXRlc3QgcHJvcHMgdmFsdWVzIHRvIHJlZnMgZm9yIGxhdGVyIHVzYWdlXG5cblxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgLy8gYWN0dWFsQ2hpbGRQcm9wczogdW5rbm93bixcbmNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMpIHtcbiAgLy8gV2Ugd2FudCB0byBjYXB0dXJlIHRoZSB3cmFwcGVyIHByb3BzIGFuZCBjaGlsZCBwcm9wcyB3ZSB1c2VkIGZvciBsYXRlciBjb21wYXJpc29uc1xuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHM7XG4gIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIHJlbmRlciB3YXMgZnJvbSBhIHN0b3JlIHVwZGF0ZSwgY2xlYXIgb3V0IHRoYXQgcmVmZXJlbmNlIGFuZCBjYXNjYWRlIHRoZSBzdWJzY3JpYmVyIHVwZGF0ZVxuXG4gIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQpIHtcbiAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBudWxsO1xuICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgfVxufSAvLyBFZmZlY3QgY2FsbGJhY2ssIGV4dHJhY3RlZDogc3Vic2NyaWJlIHRvIHRoZSBSZWR1eCBzdG9yZSBvciBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3Rvcixcbi8vIGNoZWNrIGZvciB1cGRhdGVzIGFmdGVyIGRpc3BhdGNoZWQgYWN0aW9ucywgYW5kIHRyaWdnZXIgcmUtcmVuZGVycy5cblxuXG5mdW5jdGlvbiBzdWJzY3JpYmVVcGRhdGVzKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcywgc3RvcmUsIHN1YnNjcmlwdGlvbiwgY2hpbGRQcm9wc1NlbGVjdG9yLCBsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIGlzTW91bnRlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgLy8gZm9yY2VDb21wb25lbnRVcGRhdGVEaXNwYXRjaDogUmVhY3QuRGlzcGF0Y2g8YW55PixcbmFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcikge1xuICAvLyBJZiB3ZSdyZSBub3Qgc3Vic2NyaWJlZCB0byB0aGUgc3RvcmUsIG5vdGhpbmcgdG8gZG8gaGVyZVxuICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuICgpID0+IHt9OyAvLyBDYXB0dXJlIHZhbHVlcyBmb3IgY2hlY2tpbmcgaWYgYW5kIHdoZW4gdGhpcyBjb21wb25lbnQgdW5tb3VudHNcblxuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUaHJvd25FcnJvciA9IG51bGw7IC8vIFdlJ2xsIHJ1biB0aGlzIGNhbGxiYWNrIGV2ZXJ5IHRpbWUgYSBzdG9yZSBzdWJzY3JpcHRpb24gdXBkYXRlIHByb3BhZ2F0ZXMgdG8gdGhpcyBjb21wb25lbnRcblxuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgLy8gRG9uJ3QgcnVuIHN0YWxlIGxpc3RlbmVycy5cbiAgICAgIC8vIFJlZHV4IGRvZXNuJ3QgZ3VhcmFudGVlIHVuc3Vic2NyaXB0aW9ucyBoYXBwZW4gdW50aWwgbmV4dCBkaXNwYXRjaC5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRPRE8gV2UncmUgY3VycmVudGx5IGNhbGxpbmcgZ2V0U3RhdGUgb3Vyc2VsdmVzIGhlcmUsIHJhdGhlciB0aGFuIGxldHRpbmcgYHVTRVNgIGRvIGl0XG5cblxuICAgIGNvbnN0IGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvcjtcblxuICAgIHRyeSB7XG4gICAgICAvLyBBY3R1YWxseSBydW4gdGhlIHNlbGVjdG9yIHdpdGggdGhlIG1vc3QgcmVjZW50IHN0b3JlIHN0YXRlIGFuZCB3cmFwcGVyIHByb3BzXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlXG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKGxhdGVzdFN0b3JlU3RhdGUsIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlO1xuICAgICAgbGFzdFRocm93bkVycm9yID0gZTtcbiAgICB9XG5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH0gLy8gSWYgdGhlIGNoaWxkIHByb3BzIGhhdmVuJ3QgY2hhbmdlZCwgbm90aGluZyB0byBkbyBoZXJlIC0gY2FzY2FkZSB0aGUgc3Vic2NyaXB0aW9uIHVwZGF0ZVxuXG5cbiAgICBpZiAobmV3Q2hpbGRQcm9wcyA9PT0gbGFzdENoaWxkUHJvcHMuY3VycmVudCkge1xuICAgICAgaWYgKCFyZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50KSB7XG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2F2ZSByZWZlcmVuY2VzIHRvIHRoZSBuZXcgY2hpbGQgcHJvcHMuICBOb3RlIHRoYXQgd2UgdHJhY2sgdGhlIFwiY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGVcIlxuICAgICAgLy8gYXMgYSByZWYgaW5zdGVhZCBvZiBhIHVzZVN0YXRlL3VzZVJlZHVjZXIgYmVjYXVzZSB3ZSBuZWVkIGEgd2F5IHRvIGRldGVybWluZSBpZiB0aGF0IHZhbHVlIGhhc1xuICAgICAgLy8gYmVlbiBwcm9jZXNzZWQuICBJZiB0aGlzIHdlbnQgaW50byB1c2VTdGF0ZS91c2VSZWR1Y2VyLCB3ZSBjb3VsZG4ndCBjbGVhciBvdXQgdGhlIHZhbHVlIHdpdGhvdXRcbiAgICAgIC8vIGZvcmNpbmcgYW5vdGhlciByZS1yZW5kZXIsIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTsgLy8gVE9ETyBUaGlzIGlzIGhhY2t5IGFuZCBub3QgaG93IGB1U0VTYCBpcyBtZWFudCB0byBiZSB1c2VkXG4gICAgICAvLyBUcmlnZ2VyIHRoZSBSZWFjdCBgdXNlU3luY0V4dGVybmFsU3RvcmVgIHN1YnNjcmliZXJcblxuICAgICAgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKCk7XG4gICAgfVxuICB9OyAvLyBBY3R1YWxseSBzdWJzY3JpYmUgdG8gdGhlIG5lYXJlc3QgY29ubmVjdGVkIGFuY2VzdG9yIChvciBzdG9yZSlcblxuXG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xuICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7IC8vIFB1bGwgZGF0YSBmcm9tIHRoZSBzdG9yZSBhZnRlciBmaXJzdCByZW5kZXIgaW4gY2FzZSB0aGUgc3RvcmUgaGFzXG4gIC8vIGNoYW5nZWQgc2luY2Ugd2UgYmVnYW4uXG5cbiAgY2hlY2tGb3JVcGRhdGVzKCk7XG5cbiAgY29uc3QgdW5zdWJzY3JpYmVXcmFwcGVyID0gKCkgPT4ge1xuICAgIGRpZFVuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IG51bGw7XG5cbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgd2UgY2F1Z2h0IGFuIGVycm9yIGR1ZSB0byBhIGJhZCBtYXBTdGF0ZSBmdW5jdGlvbiwgYnV0IHRoZVxuICAgICAgLy8gcGFyZW50IHJlLXJlbmRlcmVkIHdpdGhvdXQgdGhpcyBjb21wb25lbnQgYW5kIHdlJ3JlIGFib3V0IHRvIHVubW91bnQuXG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYXMgbG9uZyBhcyB3ZSBkbyB0b3AtZG93biBzdWJzY3JpcHRpb25zIGNvcnJlY3RseSwgYnV0XG4gICAgICAvLyBpZiB3ZSBldmVyIGRvIHRob3NlIHdyb25nLCB0aGlzIHRocm93IHdpbGwgc3VyZmFjZSB0aGUgZXJyb3IgaW4gb3VyIHRlc3RzLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aHJvdyB0aGUgZXJyb3IgZnJvbSBoZXJlIHNvIGl0IGRvZXNuJ3QgZ2V0IGxvc3QuXG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59IC8vIFJlZHVjZXIgaW5pdGlhbCBzdGF0ZSBjcmVhdGlvbiBmb3Igb3VyIHVwZGF0ZSByZWR1Y2VyXG5cblxuY29uc3QgaW5pdFN0YXRlVXBkYXRlcyA9ICgpID0+IEVNUFRZX0FSUkFZO1xuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuLyoqXG4gKiBJbmZlcnMgdGhlIHR5cGUgb2YgcHJvcHMgdGhhdCBhIGNvbm5lY3RvciB3aWxsIGluamVjdCBpbnRvIGEgY29tcG9uZW50LlxuICovXG5cblxubGV0IGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbi8qKlxuICogQ29ubmVjdHMgYSBSZWFjdCBjb21wb25lbnQgdG8gYSBSZWR1eCBzdG9yZS5cbiAqXG4gKiAtIFdpdGhvdXQgYXJndW1lbnRzLCBqdXN0IHdyYXBzIHRoZSBjb21wb25lbnQsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIGJlaGF2aW9yIC8gcHJvcHNcbiAqXG4gKiAtIElmIDIgcGFyYW1zIGFyZSBwYXNzZWQgKDNyZCBwYXJhbSwgbWVyZ2VQcm9wcywgaXMgc2tpcHBlZCksIGRlZmF1bHQgYmVoYXZpb3JcbiAqIGlzIHRvIG92ZXJyaWRlIG93blByb3BzIChhcyBzdGF0ZWQgaW4gdGhlIGRvY3MpLCBzbyB3aGF0IHJlbWFpbnMgaXMgZXZlcnl0aGluZyB0aGF0J3NcbiAqIG5vdCBhIHN0YXRlIG9yIGRpc3BhdGNoIHByb3BcbiAqXG4gKiAtIFdoZW4gM3JkIHBhcmFtIGlzIHBhc3NlZCwgd2UgZG9uJ3Qga25vdyBpZiBvd25Qcm9wcyBwcm9wYWdhdGUgYW5kIHdoZXRoZXIgdGhleVxuICogc2hvdWxkIGJlIHZhbGlkIGNvbXBvbmVudCBwcm9wcywgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIG1lcmdlUHJvcHMgaW1wbGVtZW50YXRpb24uXG4gKiBBcyBzdWNoLCBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGV4dGVuZCBvd25Qcm9wcyBpbnRlcmZhY2UgZnJvbSBzdGF0ZSBvclxuICogZGlzcGF0Y2ggcHJvcHMgb3IgYm90aCB3aGVuIGFwcGxpY2FibGVcbiAqXG4gKiBAcGFyYW0gbWFwU3RhdGVUb1Byb3BzIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB2YWx1ZXMgZnJvbSBzdGF0ZVxuICogQHBhcmFtIG1hcERpc3BhdGNoVG9Qcm9wcyBTZXR1cCBmb3IgZGlzcGF0Y2hpbmcgYWN0aW9uc1xuICogQHBhcmFtIG1lcmdlUHJvcHMgT3B0aW9uYWwgY2FsbGJhY2sgdG8gbWVyZ2Ugc3RhdGUgYW5kIGRpc3BhdGNoIHByb3BzIHRvZ2V0aGVyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgY29ubmVjdGlvblxuICpcbiAqL1xuXG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCB7XG4gIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBwdXJlLFxuICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIC8vIHVzZSBSZWFjdCdzIGZvcndhcmRSZWYgdG8gZXhwb3NlIGEgcmVmIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudFxuICBmb3J3YXJkUmVmID0gZmFsc2UsXG4gIC8vIHRoZSBjb250ZXh0IGNvbnN1bWVyIHRvIHVzZVxuICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHRcbn0gPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChwdXJlICE9PSB1bmRlZmluZWQgJiYgIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24pIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSB0cnVlO1xuICAgICAgd2FybmluZygnVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gYGNvbm5lY3RgIGlzIG5vdyBhbHdheXMgYSBcInB1cmUvbWVtb2l6ZWRcIiBjb21wb25lbnQnKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dDtcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKTtcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuXG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IFdyYXBwZWRDb21wb25lbnQgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc1ZhbGlkRWxlbWVudFR5cGUoV3JhcHBlZENvbXBvbmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3N0cmluZ2lmeUNvbXBvbmVudChXcmFwcGVkQ29tcG9uZW50KX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYENvbm5lY3QoJHt3cmFwcGVkQ29tcG9uZW50TmFtZX0pYDtcbiAgICBjb25zdCBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0ge1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzLFxuICAgICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIGNvbnN0IFtwcm9wc0NvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgLy8gRGlzdGluZ3Vpc2ggYmV0d2VlbiBhY3R1YWwgXCJkYXRhXCIgcHJvcHMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlciBjb21wb25lbnQsXG4gICAgICAgIC8vIGFuZCB2YWx1ZXMgbmVlZGVkIHRvIGNvbnRyb2wgYmVoYXZpb3IgKGZvcndhcmRlZCByZWZzLCBhbHRlcm5hdGUgY29udGV4dCBpbnN0YW5jZXMpLlxuICAgICAgICAvLyBUbyBtYWludGFpbiB0aGUgd3JhcHBlclByb3BzIG9iamVjdCByZWZlcmVuY2UsIG1lbW9pemUgdGhpcyBkZXN0cnVjdHVyaW5nLlxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICB9ID0gcHJvcHMsXG4gICAgICAgICAgICAgIHdyYXBwZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgIHJldHVybiBbcHJvcHMuY29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXTtcbiAgICAgIH0sIFtwcm9wc10pO1xuICAgICAgY29uc3QgQ29udGV4dFRvVXNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIFVzZXJzIG1heSBvcHRpb25hbGx5IHBhc3MgaW4gYSBjdXN0b20gY29udGV4dCBpbnN0YW5jZSB0byB1c2UgaW5zdGVhZCBvZiBvdXIgUmVhY3RSZWR1eENvbnRleHQuXG4gICAgICAgIC8vIE1lbW9pemUgdGhlIGNoZWNrIHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBjb250ZXh0IGluc3RhbmNlIHdlIHNob3VsZCB1c2UuXG4gICAgICAgIHJldHVybiBwcm9wc0NvbnRleHQgJiYgcHJvcHNDb250ZXh0LkNvbnN1bWVyICYmIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaXNDb250ZXh0Q29uc3VtZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbCkpID8gcHJvcHNDb250ZXh0IDogQ29udGV4dDtcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKTsgLy8gUmV0cmlldmUgdGhlIHN0b3JlIGFuZCBhbmNlc3RvciBzdWJzY3JpcHRpb24gdmlhIGNvbnRleHQsIGlmIGF2YWlsYWJsZVxuXG4gICAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHRUb1VzZSk7IC8vIFRoZSBzdG9yZSBfbXVzdF8gZXhpc3QgYXMgZWl0aGVyIGEgcHJvcCBvciBpbiBjb250ZXh0LlxuICAgICAgLy8gV2UnbGwgY2hlY2sgdG8gc2VlIGlmIGl0IF9sb29rc18gbGlrZSBhIFJlZHV4IHN0b3JlIGZpcnN0LlxuICAgICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcGFzcyB0aHJvdWdoIGEgYHN0b3JlYCBwcm9wIHRoYXQgaXMganVzdCBhIHBsYWluIHZhbHVlLlxuXG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPSBCb29sZWFuKHByb3BzLnN0b3JlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmdldFN0YXRlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID0gQm9vbGVhbihjb250ZXh0VmFsdWUpICYmIEJvb2xlYW4oY29udGV4dFZhbHVlLnN0b3JlKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gdGhlIGNvbnRleHQgb2YgYCArIGBcIiR7ZGlzcGxheU5hbWV9XCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sIGAgKyBgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIGAgKyBgUmVhY3QgY29udGV4dCBjb25zdW1lciB0byAke2Rpc3BsYXlOYW1lfSBpbiBjb25uZWN0IG9wdGlvbnMuYCk7XG4gICAgICB9IC8vIEJhc2VkIG9uIHRoZSBwcmV2aW91cyBjaGVjaywgb25lIG9mIHRoZXNlIG11c3QgYmUgdHJ1ZVxuXG5cbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICBjb25zdCBnZXRTZXJ2ZXJTdGF0ZSA9IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID8gY29udGV4dFZhbHVlLmdldFNlcnZlclN0YXRlIDogc3RvcmUuZ2V0U3RhdGU7XG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgLy8gVGhlIGNoaWxkIHByb3BzIHNlbGVjdG9yIG5lZWRzIHRoZSBzdG9yZSByZWZlcmVuY2UgYXMgYW4gaW5wdXQuXG4gICAgICAgIC8vIFJlLWNyZWF0ZSB0aGlzIHNlbGVjdG9yIHdoZW5ldmVyIHRoZSBzdG9yZSBjaGFuZ2VzLlxuICAgICAgICByZXR1cm4gZGVmYXVsdFNlbGVjdG9yRmFjdG9yeShzdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICB9LCBbc3RvcmVdKTtcbiAgICAgIGNvbnN0IFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZOyAvLyBUaGlzIFN1YnNjcmlwdGlvbidzIHNvdXJjZSBzaG91bGQgbWF0Y2ggd2hlcmUgc3RvcmUgY2FtZSBmcm9tOiBwcm9wcyB2cy4gY29udGV4dC4gQSBjb21wb25lbnRcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIHRoZSBzdG9yZSB2aWEgcHJvcHMgc2hvdWxkbid0IHVzZSBzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0LCBvciB2aWNlIHZlcnNhLlxuXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzID8gdW5kZWZpbmVkIDogY29udGV4dFZhbHVlLnN1YnNjcmlwdGlvbik7IC8vIGBub3RpZnlOZXN0ZWRTdWJzYCBpcyBkdXBsaWNhdGVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZCBpblxuICAgICAgICAvLyB0aGUgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcCwgd2hlcmUgYHN1YnNjcmlwdGlvbmAgd2lsbCB0aGVuIGJlIG51bGwuIFRoaXMgY2FuXG4gICAgICAgIC8vIHByb2JhYmx5IGJlIGF2b2lkZWQgaWYgU3Vic2NyaXB0aW9uJ3MgbGlzdGVuZXJzIGxvZ2ljIGlzIGNoYW5nZWQgdG8gbm90IGNhbGwgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRoYXQgaGF2ZSBiZWVuIHVuc3Vic2NyaWJlZCBpbiB0aGUgIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AuXG5cbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3VicyA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdO1xuICAgICAgfSwgW3N0b3JlLCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZV0pOyAvLyBEZXRlcm1pbmUgd2hhdCB7c3RvcmUsIHN1YnNjcmlwdGlvbn0gdmFsdWUgc2hvdWxkIGJlIHB1dCBpbnRvIG5lc3RlZCBjb250ZXh0LCBpZiBuZWNlc3NhcnksXG4gICAgICAvLyBhbmQgbWVtb2l6ZSB0aGF0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnRleHQgdXBkYXRlcy5cblxuICAgICAgY29uc3Qgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZGlkU3RvcmVDb21lRnJvbVByb3BzKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wb25lbnQgaXMgZGlyZWN0bHkgc3Vic2NyaWJlZCB0byBhIHN0b3JlIGZyb20gcHJvcHMuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCBkZXNjZW5kYW50cyByZWFkaW5nIGZyb20gdGhpcyBzdG9yZSAtIHBhc3MgZG93biB3aGF0ZXZlclxuICAgICAgICAgIC8vIHRoZSBleGlzdGluZyBjb250ZXh0IHZhbHVlIGlzIGZyb20gdGhlIG5lYXJlc3QgY29ubmVjdGVkIGFuY2VzdG9yLlxuICAgICAgICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gICAgICAgIH0gLy8gT3RoZXJ3aXNlLCBwdXQgdGhpcyBjb21wb25lbnQncyBzdWJzY3JpcHRpb24gaW5zdGFuY2UgaW50byBjb250ZXh0LCBzbyB0aGF0XG4gICAgICAgIC8vIGNvbm5lY3RlZCBkZXNjZW5kYW50cyB3b24ndCB1cGRhdGUgdW50aWwgYWZ0ZXIgdGhpcyBjb21wb25lbnQgaXMgZG9uZVxuXG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjb250ZXh0VmFsdWUsIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgICAgfSk7XG4gICAgICB9LCBbZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWUsIHN1YnNjcmlwdGlvbl0pOyAvLyBTZXQgdXAgcmVmcyB0byBjb29yZGluYXRlIHZhbHVlcyBiZXR3ZWVuIHRoZSBzdWJzY3JpcHRpb24gZWZmZWN0IGFuZCB0aGUgcmVuZGVyIGxvZ2ljXG5cbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc1Byb2Nlc3NpbmdEaXNwYXRjaCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZigpO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIC8vIFRyaWNreSBsb2dpYyBoZXJlOlxuICAgICAgICAgIC8vIC0gVGhpcyByZW5kZXIgbWF5IGhhdmUgYmVlbiB0cmlnZ2VyZWQgYnkgYSBSZWR1eCBzdG9yZSB1cGRhdGUgdGhhdCBwcm9kdWNlZCBuZXcgY2hpbGQgcHJvcHNcbiAgICAgICAgICAvLyAtIEhvd2V2ZXIsIHdlIG1heSBoYXZlIGdvdHRlbiBuZXcgd3JhcHBlciBwcm9wcyBhZnRlciB0aGF0XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBuZXcgY2hpbGQgcHJvcHMsIGFuZCB0aGUgc2FtZSB3cmFwcGVyIHByb3BzLCB3ZSBrbm93IHdlIHNob3VsZCB1c2UgdGhlIG5ldyBjaGlsZCBwcm9wcyBhcy1pcy5cbiAgICAgICAgICAvLyBCdXQsIGlmIHdlIGhhdmUgbmV3IHdyYXBwZXIgcHJvcHMsIHRob3NlIG1pZ2h0IGNoYW5nZSB0aGUgY2hpbGQgcHJvcHMsIHNvIHdlIGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhpbmdzLlxuICAgICAgICAgIC8vIFNvLCB3ZSdsbCB1c2UgdGhlIGNoaWxkIHByb3BzIGZyb20gc3RvcmUgdXBkYXRlIG9ubHkgaWYgdGhlIHdyYXBwZXIgcHJvcHMgYXJlIHRoZSBzYW1lIGFzIGxhc3QgdGltZS5cbiAgICAgICAgICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmIHdyYXBwZXJQcm9wcyA9PT0gbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50O1xuICAgICAgICAgIH0gLy8gVE9ETyBXZSdyZSByZWFkaW5nIHRoZSBzdG9yZSBkaXJlY3RseSBpbiByZW5kZXIoKSBoZXJlLiBCYWQgaWRlYT9cbiAgICAgICAgICAvLyBUaGlzIHdpbGwgbGlrZWx5IGNhdXNlIEJhZCBUaGluZ3MgKFRNKSB0byBoYXBwZW4gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBkbyB0aGlzIGJlY2F1c2Ugb24gcmVuZGVycyBfbm90XyBjYXVzZWQgYnkgc3RvcmUgdXBkYXRlcywgd2UgbmVlZCB0aGUgbGF0ZXN0IHN0b3JlIHN0YXRlXG4gICAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoYXQgdGhlIGNoaWxkIHByb3BzIHNob3VsZCBiZS5cblxuXG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH0sIFtzdG9yZSwgd3JhcHBlclByb3BzXSk7IC8vIFdlIG5lZWQgdGhpcyB0byBleGVjdXRlIHN5bmNocm9ub3VzbHkgZXZlcnkgdGltZSB3ZSByZS1yZW5kZXIuIEhvd2V2ZXIsIFJlYWN0IHdhcm5zXG4gICAgICAvLyBhYm91dCB1c2VMYXlvdXRFZmZlY3QgaW4gU1NSLCBzbyB3ZSB0cnkgdG8gZGV0ZWN0IGVudmlyb25tZW50IGFuZCBmYWxsIGJhY2sgdG9cbiAgICAgIC8vIGp1c3QgdXNlRWZmZWN0IGluc3RlYWQgdG8gYXZvaWQgdGhlIHdhcm5pbmcsIHNpbmNlIG5laXRoZXIgd2lsbCBydW4gYW55d2F5LlxuXG4gICAgICBjb25zdCBzdWJzY3JpYmVGb3JSZWFjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmUgPSByZWFjdExpc3RlbmVyID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVVcGRhdGVzKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcywgc3RvcmUsIHN1YnNjcmlwdGlvbiwgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBpc01vdW50ZWQsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMsIHJlYWN0TGlzdGVuZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmU7XG4gICAgICB9LCBbc3Vic2NyaXB0aW9uXSk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoY2FwdHVyZVdyYXBwZXJQcm9wcywgW2xhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzXSk7XG4gICAgICBsZXQgYWN0dWFsQ2hpbGRQcm9wcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0dWFsQ2hpbGRQcm9wcyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKCAvLyBUT0RPIFdlJ3JlIHBhc3NpbmcgdGhyb3VnaCBhIGJpZyB3cmFwcGVyIHRoYXQgZG9lcyBhIGJ1bmNoIG9mIGV4dHJhIHNpZGUgZWZmZWN0cyBiZXNpZGVzIHN1YnNjcmliaW5nXG4gICAgICAgIHN1YnNjcmliZUZvclJlYWN0LCAvLyBUT0RPIFRoaXMgaXMgaW5jcmVkaWJseSBoYWNreS4gV2UndmUgYWxyZWFkeSBwcm9jZXNzZWQgdGhlIHN0b3JlIHVwZGF0ZSBhbmQgY2FsY3VsYXRlZCBuZXcgY2hpbGQgcHJvcHMsXG4gICAgICAgIC8vIFRPRE8gYW5kIHdlJ3JlIGp1c3QgcGFzc2luZyB0aGF0IHRocm91Z2ggc28gaXQgdHJpZ2dlcnMgYSByZS1yZW5kZXIgZm9yIHVzIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gYHVTRVNgLlxuICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsIGdldFNlcnZlclN0YXRlID8gKCkgPT4gY2hpbGRQcm9wc1NlbGVjdG9yKGdldFNlcnZlclN0YXRlKCksIHdyYXBwZXJQcm9wcykgOiBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XFxuJHtsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2t9XFxuXFxuYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIH0pOyAvLyBOb3cgdGhhdCBhbGwgdGhhdCdzIGRvbmUsIHdlIGNhbiBmaW5hbGx5IHRyeSB0byBhY3R1YWxseSByZW5kZXIgdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgIC8vIFdlIG1lbW9pemUgdGhlIGVsZW1lbnRzIGZvciB0aGUgcmVuZGVyZWQgY2hpbGQgY29tcG9uZW50IGFzIGFuIG9wdGltaXphdGlvbi5cblxuICAgICAgY29uc3QgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCBhY3R1YWxDaGlsZFByb3BzLCB7XG4gICAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICAgIH0sIFtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCBXcmFwcGVkQ29tcG9uZW50LCBhY3R1YWxDaGlsZFByb3BzXSk7IC8vIElmIFJlYWN0IHNlZXMgdGhlIGV4YWN0IHNhbWUgZWxlbWVudCByZWZlcmVuY2UgYXMgbGFzdCB0aW1lLCBpdCBiYWlscyBvdXQgb2YgcmUtcmVuZGVyaW5nXG4gICAgICAvLyB0aGF0IGNoaWxkLCBzYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIFJlYWN0Lm1lbW8oKSBvciByZXR1cm5lZCBmYWxzZSBmcm9tIHNob3VsZENvbXBvbmVudFVwZGF0ZS5cblxuICAgICAgY29uc3QgcmVuZGVyZWRDaGlsZCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgaXMgc3Vic2NyaWJlZCB0byBzdG9yZSB1cGRhdGVzLCB3ZSBuZWVkIHRvIHBhc3MgaXRzIG93blxuICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBkb3duIHRvIG91ciBkZXNjZW5kYW50cy4gVGhhdCBtZWFucyByZW5kZXJpbmcgdGhlIHNhbWVcbiAgICAgICAgICAvLyBDb250ZXh0IGluc3RhbmNlLCBhbmQgcHV0dGluZyBhIGRpZmZlcmVudCB2YWx1ZSBpbnRvIHRoZSBjb250ZXh0LlxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlXG4gICAgICAgICAgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKTtcbiAgICAgIHJldHVybiByZW5kZXJlZENoaWxkO1xuICAgIH1cblxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pO1xuXG4gICAgLy8gQWRkIGEgaGFja3kgY2FzdCB0byBnZXQgdGhlIHJpZ2h0IG91dHB1dCB0eXBlXG4gICAgY29uc3QgQ29ubmVjdCA9IF9Db25uZWN0O1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IENvbm5lY3RGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuXG4gICAgaWYgKGZvcndhcmRSZWYpIHtcbiAgICAgIGNvbnN0IF9mb3J3YXJkZWQgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmb3J3YXJkZWQgPSBfZm9yd2FyZGVkO1xuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICBmb3J3YXJkZWQuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICByZXR1cm4gaG9pc3RTdGF0aWNzKGZvcndhcmRlZCwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvaXN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcblxuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0OyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCB7IGNyZWF0ZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCc7XG5cbmZ1bmN0aW9uIFByb3ZpZGVyKHtcbiAgc3RvcmUsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICBzZXJ2ZXJTdGF0ZSxcbiAgc3RhYmlsaXR5Q2hlY2sgPSAnb25jZScsXG4gIG5vb3BDaGVjayA9ICdvbmNlJ1xufSkge1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdW5kZWZpbmVkLFxuICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICBub29wQ2hlY2tcbiAgICB9O1xuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlLCBzdGFiaWxpdHlDaGVjaywgbm9vcENoZWNrXSk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHN0b3JlLmdldFN0YXRlKCksIFtzdG9yZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY29udGV4dFZhbHVlO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuXG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHN0b3JlLmdldFN0YXRlKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfSwgW2NvbnRleHRWYWx1ZSwgcHJldmlvdXNTdGF0ZV0pO1xuICBjb25zdCBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDsgLy8gQHRzLWlnbm9yZSAnQW55QWN0aW9uJyBpcyBhc3NpZ25hYmxlIHRvIHRoZSBjb25zdHJhaW50IG9mIHR5cGUgJ0EnLCBidXQgJ0EnIGNvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGEgZGlmZmVyZW50IHN1YnR5cGVcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBQcm92aWRlcjsiLCJpbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VSZWR1eENvbnRleHQgYXMgdXNlRGVmYXVsdFJlZHV4Q29udGV4dCwgY3JlYXRlUmVkdXhDb250ZXh0SG9vayB9IGZyb20gJy4vdXNlUmVkdXhDb250ZXh0Jztcbi8qKlxuICogSG9vayBmYWN0b3J5LCB3aGljaCBjcmVhdGVzIGEgYHVzZVN0b3JlYCBob29rIGJvdW5kIHRvIGEgZ2l2ZW4gY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0LkNvbnRleHR9IFtjb250ZXh0PVJlYWN0UmVkdXhDb250ZXh0XSBDb250ZXh0IHBhc3NlZCB0byB5b3VyIGA8UHJvdmlkZXI+YC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlU3RvcmVgIGhvb2sgYm91bmQgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dCA9IC8vIEB0cy1pZ25vcmVcbiAgY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IDogLy8gQHRzLWlnbm9yZVxuICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RvcmVcbiAgICB9ID0gdXNlUmVkdXhDb250ZXh0KCk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHJldHVybiBzdG9yZTtcbiAgfTtcbn1cbi8qKlxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggc3RvcmUuXG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHJlZHV4IHN0b3JlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBFeGFtcGxlQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKClcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XG4gKiB9XG4gKi9cblxuZXhwb3J0IGNvbnN0IHVzZVN0b3JlID0gLyojX19QVVJFX18qL2NyZWF0ZVN0b3JlSG9vaygpOyIsImltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCB7IHVzZVN0b3JlIGFzIHVzZURlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmVIb29rIH0gZnJvbSAnLi91c2VTdG9yZSc7XG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VEaXNwYXRjaGAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZURpc3BhdGNoYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VTdG9yZSA9IC8vIEB0cy1pZ25vcmVcbiAgY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0U3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VEaXNwYXRjaCgpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaDtcbiAgfTtcbn1cbi8qKlxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggYGRpc3BhdGNoYCBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7YW55fGZ1bmN0aW9ufSByZWR1eCBzdG9yZSdzIGBkaXNwYXRjaGAgZnVuY3Rpb25cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuICogaW1wb3J0IHsgdXNlRGlzcGF0Y2ggfSBmcm9tICdyZWFjdC1yZWR1eCdcbiAqXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICh7IHZhbHVlIH0pID0+IHtcbiAqICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpXG4gKiAgIGNvbnN0IGluY3JlYXNlQ291bnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IGRpc3BhdGNoKHsgdHlwZTogJ2luY3JlYXNlLWNvdW50ZXInIH0pLCBbXSlcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPHNwYW4+e3ZhbHVlfTwvc3Bhbj5cbiAqICAgICAgIDxidXR0b24gb25DbGljaz17aW5jcmVhc2VDb3VudGVyfT5JbmNyZWFzZSBjb3VudGVyPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIClcbiAqIH1cbiAqL1xuXG5leHBvcnQgY29uc3QgdXNlRGlzcGF0Y2ggPSAvKiNfX1BVUkVfXyovY3JlYXRlRGlzcGF0Y2hIb29rKCk7IiwiaW1wb3J0IFByb3ZpZGVyIGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcic7XG5pbXBvcnQgY29ubmVjdCBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCB7IHVzZURpc3BhdGNoLCBjcmVhdGVEaXNwYXRjaEhvb2sgfSBmcm9tICcuL2hvb2tzL3VzZURpc3BhdGNoJztcbmltcG9ydCB7IHVzZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3Rvckhvb2sgfSBmcm9tICcuL2hvb2tzL3VzZVNlbGVjdG9yJztcbmltcG9ydCB7IHVzZVN0b3JlLCBjcmVhdGVTdG9yZUhvb2sgfSBmcm9tICcuL2hvb2tzL3VzZVN0b3JlJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi91dGlscy9zaGFsbG93RXF1YWwnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgeyBQcm92aWRlciwgUmVhY3RSZWR1eENvbnRleHQsIGNvbm5lY3QsIHVzZURpc3BhdGNoLCBjcmVhdGVEaXNwYXRjaEhvb2ssIHVzZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3Rvckhvb2ssIHVzZVN0b3JlLCBjcmVhdGVTdG9yZUhvb2ssIHNoYWxsb3dFcXVhbCB9OyIsIi8vIFRoZSBwcmltYXJ5IGVudHJ5IHBvaW50IGFzc3VtZXMgd2UncmUgd29ya2luZyB3aXRoIHN0YW5kYXJkIFJlYWN0RE9NL1JOLCBidXRcbi8vIG9sZGVyIHZlcnNpb25zIHRoYXQgZG8gbm90IGluY2x1ZGUgYHVzZVN5bmNFeHRlcm5hbFN0b3JlYCAoUmVhY3QgMTYuOSAtIDE3LngpLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGUgdXNlU3luY0V4dGVybmFsU3RvcmUgY29tcGF0IHNoaW0gaXMgbmVlZGVkLlxuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltJztcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yJztcbmltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIGFzIGJhdGNoIH0gZnJvbSAnLi91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzJztcbmltcG9ydCB7IHNldEJhdGNoIH0gZnJvbSAnLi91dGlscy9iYXRjaCc7XG5pbXBvcnQgeyBpbml0aWFsaXplVXNlU2VsZWN0b3IgfSBmcm9tICcuL2hvb2tzL3VzZVNlbGVjdG9yJztcbmltcG9ydCB7IGluaXRpYWxpemVDb25uZWN0IH0gZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3QnO1xuaW5pdGlhbGl6ZVVzZVNlbGVjdG9yKHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKTtcbmluaXRpYWxpemVDb25uZWN0KHVzZVN5bmNFeHRlcm5hbFN0b3JlKTsgLy8gRW5hYmxlIGJhdGNoZWQgdXBkYXRlcyBpbiBvdXIgc3Vic2NyaXB0aW9ucyBmb3IgdXNlXG4vLyB3aXRoIHN0YW5kYXJkIFJlYWN0IHJlbmRlcmVycyAoUmVhY3RET00sIFJlYWN0IE5hdGl2ZSlcblxuc2V0QmF0Y2goYmF0Y2gpO1xuZXhwb3J0IHsgYmF0Y2ggfTtcbmV4cG9ydCAqIGZyb20gJy4vZXhwb3J0cyc7Il0sIm5hbWVzIjpbInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiZGVmYXVsdE5vb3BCYXRjaCIsImNhbGxiYWNrIiwiYmF0Y2giLCJzZXRCYXRjaCIsIm5ld0JhdGNoIiwiZ2V0QmF0Y2giLCJSZWFjdCIsIkNvbnRleHRLZXkiLCJTeW1ib2wiLCJmb3IiLCJnVCIsImdsb2JhbFRoaXMiLCJnZXRDb250ZXh0IiwiX2dUJENvbnRleHRLZXkiLCJjcmVhdGVDb250ZXh0IiwiY29udGV4dE1hcCIsIk1hcCIsInJlYWxDb250ZXh0IiwiZ2V0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiLCJzZXQiLCJSZWFjdFJlZHV4Q29udGV4dCIsInVzZUNvbnRleHQiLCJjcmVhdGVSZWR1eENvbnRleHRIb29rIiwiY29udGV4dCIsInVzZVJlZHV4Q29udGV4dCIsImNvbnRleHRWYWx1ZSIsIkVycm9yIiwibm90SW5pdGlhbGl6ZWQiLCJ1c2VDYWxsYmFjayIsInVzZURlYnVnVmFsdWUiLCJ1c2VSZWYiLCJ1c2VEZWZhdWx0UmVkdXhDb250ZXh0IiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJpbml0aWFsaXplVXNlU2VsZWN0b3IiLCJmbiIsInJlZkVxdWFsaXR5IiwiYSIsImIiLCJjcmVhdGVTZWxlY3Rvckhvb2siLCJ1c2VTZWxlY3RvciIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbk9yT3B0aW9ucyIsImVxdWFsaXR5Rm4iLCJzdGFiaWxpdHlDaGVjayIsInVuZGVmaW5lZCIsIm5vb3BDaGVjayIsInN0b3JlIiwic3Vic2NyaXB0aW9uIiwiZ2V0U2VydmVyU3RhdGUiLCJnbG9iYWxTdGFiaWxpdHlDaGVjayIsImdsb2JhbE5vb3BDaGVjayIsImZpcnN0UnVuIiwid3JhcHBlZFNlbGVjdG9yIiwibmFtZSIsInN0YXRlIiwic2VsZWN0ZWQiLCJmaW5hbFN0YWJpbGl0eUNoZWNrIiwiY3VycmVudCIsInRvQ29tcGFyZSIsImNvbnNvbGUiLCJ3YXJuIiwic2VsZWN0ZWQyIiwiZmluYWxOb29wQ2hlY2siLCJzZWxlY3RlZFN0YXRlIiwiYWRkTmVzdGVkU3ViIiwiZ2V0U3RhdGUiLCJ3YXJuaW5nIiwibWVzc2FnZSIsImVycm9yIiwiZSIsInZlcmlmeSIsIm1ldGhvZE5hbWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2ZXJpZnlTdWJzZWxlY3RvcnMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJtZXJnZVByb3BzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJfZXhjbHVkZWQiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImRpc3BhdGNoIiwiYXJlU3RhdGVzRXF1YWwiLCJhcmVPd25Qcm9wc0VxdWFsIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiaGFzUnVuQXRMZWFzdE9uY2UiLCJvd25Qcm9wcyIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwibWVyZ2VkUHJvcHMiLCJoYW5kbGVGaXJzdENhbGwiLCJmaXJzdFN0YXRlIiwiZmlyc3RPd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUiLCJkZXBlbmRzT25Pd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzIiwiaGFuZGxlTmV3U3RhdGUiLCJuZXh0U3RhdGVQcm9wcyIsInN0YXRlUHJvcHNDaGFuZ2VkIiwiaGFuZGxlU3Vic2VxdWVudENhbGxzIiwibmV4dFN0YXRlIiwibmV4dE93blByb3BzIiwicHJvcHNDaGFuZ2VkIiwic3RhdGVDaGFuZ2VkIiwicHVyZUZpbmFsUHJvcHNTZWxlY3RvciIsImZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkiLCJfcmVmIiwiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsImluaXRNYXBEaXNwYXRjaFRvUHJvcHMiLCJpbml0TWVyZ2VQcm9wcyIsIm9wdGlvbnMiLCJpc1BsYWluT2JqZWN0IiwidmVyaWZ5UGxhaW5PYmplY3QiLCJ2YWx1ZSIsIndyYXBNYXBUb1Byb3BzQ29uc3RhbnQiLCJnZXRDb25zdGFudCIsImluaXRDb25zdGFudFNlbGVjdG9yIiwiY29uc3RhbnQiLCJjb25zdGFudFNlbGVjdG9yIiwiZ2V0RGVwZW5kc09uT3duUHJvcHMiLCJtYXBUb1Byb3BzIiwiQm9vbGVhbiIsImxlbmd0aCIsIndyYXBNYXBUb1Byb3BzRnVuYyIsImluaXRQcm94eVNlbGVjdG9yIiwicHJveHkiLCJtYXBUb1Byb3BzUHJveHkiLCJzdGF0ZU9yRGlzcGF0Y2giLCJkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IiwicHJvcHMiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IiwiX2V4dGVuZHMiLCJkZWZhdWx0TWVyZ2VQcm9wcyIsIndyYXBNZXJnZVByb3BzRnVuYyIsImluaXRNZXJnZVByb3BzUHJveHkiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiaGFzUnVuT25jZSIsIm1lcmdlUHJvcHNQcm94eSIsIm5leHRNZXJnZWRQcm9wcyIsIm1lcmdlUHJvcHNGYWN0b3J5IiwiY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uIiwiZmlyc3QiLCJsYXN0IiwiY2xlYXIiLCJub3RpZnkiLCJsaXN0ZW5lciIsIm5leHQiLCJsaXN0ZW5lcnMiLCJwdXNoIiwic3Vic2NyaWJlIiwiaXNTdWJzY3JpYmVkIiwicHJldiIsInVuc3Vic2NyaWJlIiwibnVsbExpc3RlbmVycyIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInBhcmVudFN1YiIsInRyeVN1YnNjcmliZSIsIm5vdGlmeU5lc3RlZFN1YnMiLCJoYW5kbGVDaGFuZ2VXcmFwcGVyIiwib25TdGF0ZUNoYW5nZSIsInRyeVVuc3Vic2NyaWJlIiwiZ2V0TGlzdGVuZXJzIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsImhvaXN0U3RhdGljcyIsImlzVmFsaWRFbGVtZW50VHlwZSIsImlzQ29udGV4dENvbnN1bWVyIiwiZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSIsInNoYWxsb3dFcXVhbCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwiaW5pdGlhbGl6ZUNvbm5lY3QiLCJFTVBUWV9BUlJBWSIsIk5PX1NVQlNDUklQVElPTl9BUlJBWSIsInN0cmluZ2lmeUNvbXBvbmVudCIsIkNvbXAiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyIiwiU3RyaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzIiwiZWZmZWN0RnVuYyIsImVmZmVjdEFyZ3MiLCJkZXBlbmRlbmNpZXMiLCJjYXB0dXJlV3JhcHBlclByb3BzIiwibGFzdFdyYXBwZXJQcm9wcyIsImxhc3RDaGlsZFByb3BzIiwicmVuZGVySXNTY2hlZHVsZWQiLCJ3cmFwcGVyUHJvcHMiLCJjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlIiwic3Vic2NyaWJlVXBkYXRlcyIsInNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyIsImNoaWxkUHJvcHNTZWxlY3RvciIsImlzTW91bnRlZCIsImFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lciIsImRpZFVuc3Vic2NyaWJlIiwibGFzdFRocm93bkVycm9yIiwiY2hlY2tGb3JVcGRhdGVzIiwibGF0ZXN0U3RvcmVTdGF0ZSIsIm5ld0NoaWxkUHJvcHMiLCJ1bnN1YnNjcmliZVdyYXBwZXIiLCJpbml0U3RhdGVVcGRhdGVzIiwic3RyaWN0RXF1YWwiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uIiwiY29ubmVjdCIsInB1cmUiLCJmb3J3YXJkUmVmIiwiQ29udGV4dCIsIndyYXBXaXRoQ29ubmVjdCIsIldyYXBwZWRDb21wb25lbnQiLCJ3cmFwcGVkQ29tcG9uZW50TmFtZSIsInNlbGVjdG9yRmFjdG9yeU9wdGlvbnMiLCJDb25uZWN0RnVuY3Rpb24iLCJwcm9wc0NvbnRleHQiLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmIiwidXNlTWVtbyIsIkNvbnRleHRUb1VzZSIsIkNvbnN1bWVyIiwiZGlkU3RvcmVDb21lRnJvbVByb3BzIiwiZGlkU3RvcmVDb21lRnJvbUNvbnRleHQiLCJiaW5kIiwib3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSIsImlzUHJvY2Vzc2luZ0Rpc3BhdGNoIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInN1YnNjcmliZUZvclJlYWN0IiwicmVhY3RMaXN0ZW5lciIsImFjdHVhbENoaWxkUHJvcHMiLCJzdGFjayIsInJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCIsInJlZiIsInJlbmRlcmVkQ2hpbGQiLCJQcm92aWRlciIsIl9Db25uZWN0IiwibWVtbyIsIkNvbm5lY3QiLCJfZm9yd2FyZGVkIiwiZm9yd2FyZENvbm5lY3RSZWYiLCJmb3J3YXJkZWQiLCJjaGlsZHJlbiIsInNlcnZlclN0YXRlIiwicHJldmlvdXNTdGF0ZSIsImNyZWF0ZVN0b3JlSG9vayIsInVzZVN0b3JlIiwidXNlRGVmYXVsdFN0b3JlIiwiY3JlYXRlRGlzcGF0Y2hIb29rIiwidXNlRGlzcGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4641\n")},72:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aj: () => (/* binding */ createBrowserRouter),\n/* harmony export */   rU: () => (/* binding */ Link)\n/* harmony export */ });\n/* unused harmony exports BrowserRouter, Form, HashRouter, NavLink, ScrollRestoration, UNSAFE_useScrollRestoration, createHashRouter, createSearchParams, unstable_HistoryRouter, unstable_usePrompt, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5466);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1807);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1300);\n/* provided dependency */ var console = __webpack_require__(1283);\n/**\n * React Router DOM v6.16.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nconst defaultMethod = "get";\nconst defaultEncType = "application/x-www-form-urlencoded";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === "string";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === "_self") &&\n  // Let browser handle "target=_blank" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don\'t want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     [\'sort\', \'name\'],\n *     [\'sort\', \'price\']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: [\'name\', \'price\']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = "";\n  }\n  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n    // web extensions. Relevant Bugzilla tickets:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement("form"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n     false ? 0 : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we\'ll\n    // re-prefix in the router\n    let attr = target.getAttribute("action");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute("method") || defaultMethod;\n    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error("Cannot submit a <button> or <input type=\\"submit\\"> without a <form>");\n    }\n    // <button>/<input type="submit"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we\'ll\n    // re-prefix in the router\n    let attr = target.getAttribute("formaction") || form.getAttribute("action");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;\n    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn\'t support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === "image") {\n        let prefix = name ? name + "." : "";\n        formData.append(prefix + "x", "0");\n        formData.append(prefix + "y", "0");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\\"submit|image\\">");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType="text/plain" so we encode it into text\n  if (formData && encType === "text/plain") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\nconst _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],\n  _excluded2 = (/* unused pure expression or super */ null && (["aria-current", "caseSensitive", "className", "end", "style", "to", "children"])),\n  _excluded3 = (/* unused pure expression or super */ null && (["reloadDocument", "replace", "state", "method", "action", "onSubmit", "submit", "relative", "preventScrollReset"]));\nfunction createBrowserRouter(routes, opts) {\n  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .createRouter */ .p7)({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .createBrowserHistory */ .lX)({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_mapRouteProperties */ .us\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === "RouteErrorResponse") {\n      serialized[key] = new _remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_ErrorResponseImpl */ .OF(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === "Error") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === "function") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don\'t serialize SSR stack traces for security reasons\n            error.stack = "";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don\'t serialize SSR stack traces for security reasons\n        error.stack = "";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn\'t exist in `React`:\n  * import { startTransition } from "react"\n  * import * as React from from "react";\n    "startTransition" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from "react";\n    "startTransition" in React ? React["startTransition"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from "react";\n    const START_TRANSITION = "startTransition";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = "startTransition";\nconst startTransitionImpl = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[START_TRANSITION];\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref2) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref2;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It\'s important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref3;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\nif (false) {}\nconst isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware <a>.\n */\nconst Link = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref4, ref) {\n  let {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset\n    } = _ref4,\n    rest = _objectWithoutPropertiesLoose(_ref4, _excluded);\n  let {\n    basename\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_NavigationContext */ .Us);\n  // Rendered into <a href> for absolute URLs\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .stripBasename */ .Zn)(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can\'t do external URL detection without a valid URL\n         false ? 0 : void 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .useHref */ .oQ)(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return /*#__PURE__*/(\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (false) {}\n/**\n * A <Link> wrapper that knows if it\'s "active" or not.\n */\nconst NavLink = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef(function NavLinkWithRef(_ref5, ref) {\n  let {\n      "aria-current": ariaCurrentProp = "page",\n      caseSensitive = false,\n      className: classNameProp = "",\n      end = false,\n      style: styleProp,\n      to,\n      children\n    } = _ref5,\n    rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\n  let {\n    navigator\n  } = React.useContext(UNSAFE_NavigationContext);\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n  if (typeof classNameProp === "function") {\n    className = classNameProp({\n      isActive,\n      isPending\n    });\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");\n  }\n  let style = typeof styleProp === "function" ? styleProp({\n    isActive,\n    isPending\n  }) : styleProp;\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\n    "aria-current": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to\n  }), typeof children === "function" ? children({\n    isActive,\n    isPending\n  }) : children);\n})));\nif (false) {}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nconst Form = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef((props, ref) => {\n  let submit = useSubmit();\n  return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n    submit: submit,\n    ref: ref\n  }));\n})));\nif (false) {}\nconst FormImpl = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef((_ref6, forwardedRef) => {\n  let {\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      submit,\n      relative,\n      preventScrollReset\n    } = _ref6,\n    props = _objectWithoutPropertiesLoose(_ref6, _excluded3);\n  let formMethod = method.toLowerCase() === "get" ? "get" : "post";\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;\n    submit(submitter || event.currentTarget, {\n      method: submitMethod,\n      replace,\n      state,\n      relative,\n      preventScrollReset\n    });\n  };\n  return /*#__PURE__*/React.createElement("form", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n})));\nif (false) {}\n/**\n * This component will emulate the browser\'s scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref7) {\n  let {\n    getKey,\n    storageKey\n  } = _ref7;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (false) {}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";\n  DataRouterHook["UseSubmit"] = "useSubmit";\n  DataRouterHook["UseSubmitFetcher"] = "useSubmitFetcher";\n  DataRouterHook["UseFetcher"] = "useFetcher";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook["UseFetchers"] = "useFetchers";\n  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\n  !ctx ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\n  !state ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n  return state;\n}\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .useNavigate */ .s0)();\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .useLocation */ .TH)();\n  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .useResolvedPath */ .WU)(to, {\n    relative\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn\'t changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      let replace = replaceProp !== undefined ? replaceProp : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .createPath */ .Ep)(location) === (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .createPath */ .Ep)(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n   false ? 0 : void 0;\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React.useRef(false);\n  let location = useLocation();\n  let searchParams = React.useMemo(() =>\n  // Only merge in the defaults if we haven\'t yet called setSearchParams.\n  // Once we call that we want those to take precedence, otherwise you can\'t\n  // remove a param with setSearchParams({}) if it has an initial value\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate("?" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === "undefined") {\n    throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");\n  }\n}\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let currentRouteId = UNSAFE_useRouteId();\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    router.navigate(options.action || action, {\n      preventScrollReset: options.preventScrollReset,\n      formData,\n      body,\n      formMethod: options.method || method,\n      formEncType: options.encType || encType,\n      replace: options.replace,\n      state: options.state,\n      fromRouteId: currentRouteId\n    });\n  }, [router, basename, currentRouteId]);\n}\n/**\n * Returns the implementation for fetcher.submit\n */\nfunction useSubmitFetcher(fetcherKey, fetcherRouteId) {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmitFetcher);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    !(fetcherRouteId != null) ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, fetcherRouteId, options.action || action, {\n      preventScrollReset: options.preventScrollReset,\n      formData,\n      body,\n      formMethod: options.method || method,\n      formEncType: options.encType || encType\n    });\n  }, [router, basename, fetcherKey, fetcherRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let routeContext = React.useContext(UNSAFE_RouteContext);\n  !routeContext ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = _extends({}, useResolvedPath(action ? action : ".", {\n    relative\n  }));\n  // Previously we set the default action to ".". The problem with this is that\n  // `useResolvedPath(".")` excludes search params of the resolved URL. This is\n  // the intended behavior of when "." is specifically provided as\n  // the form action, but inconsistent w/ browsers when the action is omitted.\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to this directly here since if action was undefined, we\n    // would have called useResolvedPath(".") which will never include a search\n    path.search = location.search;\n    // When grabbing search params from the URL, remove the automatically\n    // inserted ?index param so we match the useResolvedPath search behavior\n    // which would not include ?index\n    if (match.route.index) {\n      let params = new URLSearchParams(path.search);\n      params.delete("index");\n      path.search = params.toString() ? "?" + params.toString() : "";\n    }\n  }\n  if ((!action || action === ".") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, "?index&") : "?index";\n  }\n  // If we\'re operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== "/") {\n    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction createFetcherForm(fetcherKey, routeId) {\n  let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n    let submit = useSubmitFetcher(fetcherKey, routeId);\n    return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n      ref: ref,\n      submit: submit\n    }));\n  });\n  if (false) {}\n  return FetcherForm;\n}\nlet fetcherId = 0;\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher() {\n  var _route$matches;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let route = React.useContext(UNSAFE_RouteContext);\n  !route ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !(routeId != null) ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n  let [fetcherKey] = React.useState(() => String(++fetcherId));\n  let [Form] = React.useState(() => {\n    !routeId ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n    return createFetcherForm(fetcherKey, routeId);\n  });\n  let [load] = React.useState(() => href => {\n    !router ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n    !routeId ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href);\n  });\n  let submit = useSubmitFetcher(fetcherKey, routeId);\n  let fetcher = router.getFetcher(fetcherKey);\n  let fetcherWithComponents = React.useMemo(() => _extends({\n    Form,\n    submit,\n    load\n  }, fetcher), [fetcher, Form, submit, load]);\n  React.useEffect(() => {\n    // Is this busted when the React team gets real weird and calls effects\n    // twice on mount?  We really just need to garbage collect here when this\n    // fetcher is no longer around.\n    return () => {\n      if (!router) {\n        console.warn("No router available to clean up from useFetcher()");\n        return;\n      }\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return [...state.fetchers.values()];\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp3) {\n  let {\n    getKey,\n    storageKey\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  // Trigger manual scroll restoration while we\'re active\n  React.useEffect(() => {\n    window.history.scrollRestoration = "manual";\n    return () => {\n      window.history.scrollRestoration = "auto";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(React.useCallback(() => {\n    if (navigation.state === "idle") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    window.history.scrollRestoration = "auto";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== "undefined") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== "/" ? (location, matches) => getKey(\n      // Strip the basename to match useLocation()\n      _extends({}, location, {\n        pathname: stripBasename(location.pathname, basename) || location.pathname\n      }), matches) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don\'t do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === "number") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don\'t reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window\'s `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener("beforeunload", callback, opts);\n    return () => {\n      window.removeEventListener("beforeunload", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window\'s `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener("pagehide", callback, opts);\n    return () => {\n      window.removeEventListener("pagehide", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref8) {\n  let {\n    when,\n    message\n  } = _ref8;\n  let blocker = unstable_useBlocker(when);\n  React.useEffect(() => {\n    if (blocker.state === "blocked") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        // This timeout is needed to avoid a weird "race" on POP navigations\n        // between the `window.history` revert navigation and the result of\n        // `window.confirm`\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React.useEffect(() => {\n    if (blocker.state === "blocked" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPTyxNQUFNQSxhQUFhLEdBQW1CLEtBQUs7QUFDbEQsTUFBTUMsY0FBYyxHQUFnQixtQ0FBbUM7QUFFakUsU0FBVUMsYUFBYUEsQ0FBQ0MsTUFBVztFQUN2QyxPQUFPQSxNQUFNLElBQUksSUFBSSxJQUFJLE9BQU9BLE1BQU0sQ0FBQ0MsT0FBTyxLQUFLLFFBQVE7QUFDN0Q7QUFFTSxTQUFVQyxlQUFlQSxDQUFDRixNQUFXO0VBQ3pDLE9BQU9ELGFBQWEsQ0FBQ0MsTUFBTSxDQUFDLElBQUlBLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDRSxXQUFXLEVBQUUsS0FBSyxRQUFRO0FBQzNFO0FBRU0sU0FBVUMsYUFBYUEsQ0FBQ0osTUFBVztFQUN2QyxPQUFPRCxhQUFhLENBQUNDLE1BQU0sQ0FBQyxJQUFJQSxNQUFNLENBQUNDLE9BQU8sQ0FBQ0UsV0FBVyxFQUFFLEtBQUssTUFBTTtBQUN6RTtBQUVNLFNBQVVFLGNBQWNBLENBQUNMLE1BQVc7RUFDeEMsT0FBT0QsYUFBYSxDQUFDQyxNQUFNLENBQUMsSUFBSUEsTUFBTSxDQUFDQyxPQUFPLENBQUNFLFdBQVcsRUFBRSxLQUFLLE9BQU87QUFDMUU7QUFPQSxTQUFTRyxlQUFlQSxDQUFDQyxLQUF3QjtFQUMvQyxPQUFPLENBQUMsRUFBRUEsS0FBSyxDQUFDQyxPQUFPLElBQUlELEtBQUssQ0FBQ0UsTUFBTSxJQUFJRixLQUFLLENBQUNHLE9BQU8sSUFBSUgsS0FBSyxDQUFDSSxRQUFRLENBQUM7QUFDN0U7QUFFZ0IsU0FBQUMsc0JBQXNCQSxDQUNwQ0wsS0FBd0IsRUFDeEJNLE1BQWU7RUFFZixPQUNFTixLQUFLLENBQUNPLE1BQU0sS0FBSyxDQUFDO0VBQUk7RUFDckIsQ0FBQ0QsTUFBTSxJQUFJQSxNQUFNLEtBQUssT0FBTyxDQUFDO0VBQUk7RUFDbkMsQ0FBQ1AsZUFBZSxDQUFDQyxLQUFLLENBQUM7RUFBQTtBQUUzQjtBQVVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CRztBQUNhLFNBQUFRLGtCQUFrQkEsQ0FDaENDLElBQUEsRUFBOEI7RUFBQSxJQUE5QkEsSUFBQTtJQUFBQSxJQUFBLEdBQTRCLEVBQUU7RUFBQTtFQUU5QixPQUFPLElBQUlDLGVBQWUsQ0FDeEIsT0FBT0QsSUFBSSxLQUFLLFFBQVEsSUFDeEJFLEtBQUssQ0FBQ0MsT0FBTyxDQUFDSCxJQUFJLENBQUMsSUFDbkJBLElBQUksWUFBWUMsZUFBZSxHQUMzQkQsSUFBSSxHQUNKSSxNQUFNLENBQUNDLElBQUksQ0FBQ0wsSUFBSSxDQUFDLENBQUNNLE1BQU0sQ0FBQyxDQUFDQyxJQUFJLEVBQUVDLEdBQUcsS0FBSTtJQUNyQyxJQUFJQyxLQUFLLEdBQUdULElBQUksQ0FBQ1EsR0FBRyxDQUFDO0lBQ3JCLE9BQU9ELElBQUksQ0FBQ0csTUFBTSxDQUNoQlIsS0FBSyxDQUFDQyxPQUFPLENBQUNNLEtBQUssQ0FBQyxHQUFHQSxLQUFLLENBQUNFLEdBQUcsQ0FBRUMsQ0FBQyxJQUFLLENBQUNKLEdBQUcsRUFBRUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUNKLEdBQUcsRUFBRUMsS0FBSyxDQUFDLENBQUMsQ0FDbkU7R0FDRixFQUFFLEVBQXlCLENBQUMsQ0FDbEM7QUFDSDtBQUVnQixTQUFBSSwwQkFBMEJBLENBQ3hDQyxjQUFzQixFQUN0QkMsbUJBQTJDO0VBRTNDLElBQUlDLFlBQVksR0FBR2pCLGtCQUFrQixDQUFDZSxjQUFjLENBQUM7RUFFckQsSUFBSUMsbUJBQW1CLEVBQUU7SUFDdkI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBQSxtQkFBbUIsQ0FBQ0UsT0FBTyxDQUFDLENBQUNDLENBQUMsRUFBRVYsR0FBRyxLQUFJO01BQ3JDLElBQUksQ0FBQ1EsWUFBWSxDQUFDRyxHQUFHLENBQUNYLEdBQUcsQ0FBQyxFQUFFO1FBQzFCTyxtQkFBbUIsQ0FBQ0ssTUFBTSxDQUFDWixHQUFHLENBQUMsQ0FBQ1MsT0FBTyxDQUFFUixLQUFLLElBQUk7VUFDaERPLFlBQVksQ0FBQ0ssTUFBTSxDQUFDYixHQUFHLEVBQUVDLEtBQUssQ0FBQztRQUNqQyxDQUFDLENBQUM7TUFDSDtJQUNILENBQUMsQ0FBQztFQUNIO0VBRUQsT0FBT08sWUFBWTtBQUNyQjtBQW1CQTtBQUNBLElBQUlNLDBCQUEwQixHQUFtQixJQUFJO0FBRXJELFNBQVNDLDRCQUE0QkEsQ0FBQTtFQUNuQyxJQUFJRCwwQkFBMEIsS0FBSyxJQUFJLEVBQUU7SUFDdkMsSUFBSTtNQUNGLElBQUlFLFFBQVEsQ0FDVkMsUUFBUSxDQUFDQyxhQUFhLENBQUMsTUFBTSxDQUFDO01BQzlCO01BQ0EsQ0FBQyxDQUNGO01BQ0RKLDBCQUEwQixHQUFHLEtBQUs7S0FDbkMsQ0FBQyxPQUFPSyxDQUFDLEVBQUU7TUFDVkwsMEJBQTBCLEdBQUcsSUFBSTtJQUNsQztFQUNGO0VBQ0QsT0FBT0EsMEJBQTBCO0FBQ25DO0FBK0NBLE1BQU1NLHFCQUFxQixHQUFxQixJQUFJQyxHQUFHLENBQUMsQ0FDdEQsbUNBQW1DLEVBQ25DLHFCQUFxQixFQUNyQixZQUFZLENBQ2IsQ0FBQztBQUVGLFNBQVNDLGNBQWNBLENBQUNDLE9BQXNCO0VBQzVDLElBQUlBLE9BQU8sSUFBSSxJQUFJLElBQUksQ0FBQ0gscUJBQXFCLENBQUNULEdBQUcsQ0FBQ1ksT0FBc0IsQ0FBQyxFQUFFO0lBQ3pFQyxNQUFBLEdBQUFHLENBSUM7SUFFRCxPQUFPLElBQUk7RUFDWjtFQUNELE9BQU9KLE9BQU87QUFDaEI7QUFFZ0IsU0FBQUsscUJBQXFCQSxDQUNuQ3ZDLE1BQW9CLEVBQ3BCd0MsUUFBZ0I7RUFRaEIsSUFBSUMsTUFBYztFQUNsQixJQUFJQyxNQUFxQjtFQUN6QixJQUFJUixPQUFlO0VBQ25CLElBQUlTLFFBQThCO0VBQ2xDLElBQUlDLElBQVM7RUFFYixJQUFJckQsYUFBYSxDQUFDUyxNQUFNLENBQUMsRUFBRTtJQUN6QjtJQUNBO0lBQ0E7SUFDQSxJQUFJNkMsSUFBSSxHQUFHN0MsTUFBTSxDQUFDOEMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUN4Q0osTUFBTSxHQUFHRyxJQUFJLEdBQUdFLGFBQWEsQ0FBQ0YsSUFBSSxFQUFFTCxRQUFRLENBQUMsR0FBRyxJQUFJO0lBQ3BEQyxNQUFNLEdBQUd6QyxNQUFNLENBQUM4QyxZQUFZLENBQUMsUUFBUSxDQUFDLElBQUk5RCxhQUFhO0lBQ3ZEa0QsT0FBTyxHQUFHRCxjQUFjLENBQUNqQyxNQUFNLENBQUM4QyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSTdELGNBQWM7SUFFMUUwRCxRQUFRLEdBQUcsSUFBSWhCLFFBQVEsQ0FBQzNCLE1BQU0sQ0FBQztHQUNoQyxNQUFNLElBQ0xYLGVBQWUsQ0FBQ1csTUFBTSxDQUFDLElBQ3RCUixjQUFjLENBQUNRLE1BQU0sQ0FBQyxLQUNwQkEsTUFBTSxDQUFDZ0QsSUFBSSxLQUFLLFFBQVEsSUFBSWhELE1BQU0sQ0FBQ2dELElBQUksS0FBSyxPQUFPLENBQUUsRUFDeEQ7SUFDQSxJQUFJQyxJQUFJLEdBQUdqRCxNQUFNLENBQUNpRCxJQUFJO0lBRXRCLElBQUlBLElBQUksSUFBSSxJQUFJLEVBQUU7TUFDaEIsTUFBTSxJQUFJQyxLQUFLLHVFQUN1RCxDQUNyRTtJQUNGO0lBRUQ7SUFFQTtJQUNBO0lBQ0E7SUFDQSxJQUFJTCxJQUFJLEdBQUc3QyxNQUFNLENBQUM4QyxZQUFZLENBQUMsWUFBWSxDQUFDLElBQUlHLElBQUksQ0FBQ0gsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUMzRUosTUFBTSxHQUFHRyxJQUFJLEdBQUdFLGFBQWEsQ0FBQ0YsSUFBSSxFQUFFTCxRQUFRLENBQUMsR0FBRyxJQUFJO0lBRXBEQyxNQUFNLEdBQ0p6QyxNQUFNLENBQUM4QyxZQUFZLENBQUMsWUFBWSxDQUFDLElBQ2pDRyxJQUFJLENBQUNILFlBQVksQ0FBQyxRQUFRLENBQUMsSUFDM0I5RCxhQUFhO0lBQ2ZrRCxPQUFPLEdBQ0xELGNBQWMsQ0FBQ2pDLE1BQU0sQ0FBQzhDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUNsRGIsY0FBYyxDQUFDZ0IsSUFBSSxDQUFDSCxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsSUFDNUM3RCxjQUFjO0lBRWhCO0lBQ0EwRCxRQUFRLEdBQUcsSUFBSWhCLFFBQVEsQ0FBQ3NCLElBQUksRUFBRWpELE1BQU0sQ0FBQztJQUVyQztJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksQ0FBQzBCLDRCQUE0QixFQUFFLEVBQUU7TUFDbkMsSUFBSTtRQUFFeUIsSUFBSTtRQUFFSCxJQUFJO1FBQUVwQztNQUFLLENBQUUsR0FBR1osTUFBTTtNQUNsQyxJQUFJZ0QsSUFBSSxLQUFLLE9BQU8sRUFBRTtRQUNwQixJQUFJSSxNQUFNLEdBQUdELElBQUksR0FBTUEsSUFBSSxTQUFNLEVBQUU7UUFDbkNSLFFBQVEsQ0FBQ25CLE1BQU0sQ0FBSTRCLE1BQU0sUUFBSyxHQUFHLENBQUM7UUFDbENULFFBQVEsQ0FBQ25CLE1BQU0sQ0FBSTRCLE1BQU0sUUFBSyxHQUFHLENBQUM7T0FDbkMsTUFBTSxJQUFJRCxJQUFJLEVBQUU7UUFDZlIsUUFBUSxDQUFDbkIsTUFBTSxDQUFDMkIsSUFBSSxFQUFFdkMsS0FBSyxDQUFDO01BQzdCO0lBQ0Y7RUFDRixPQUFNLElBQUkxQixhQUFhLENBQUNjLE1BQU0sQ0FBQyxFQUFFO0lBQ2hDLE1BQU0sSUFBSWtELEtBQUssQ0FDYiwyRkFDK0IsQ0FDaEM7RUFDRixPQUFNO0lBQ0xULE1BQU0sR0FBR3pELGFBQWE7SUFDdEIwRCxNQUFNLEdBQUcsSUFBSTtJQUNiUixPQUFPLEdBQUdqRCxjQUFjO0lBQ3hCMkQsSUFBSSxHQUFHNUMsTUFBTTtFQUNkO0VBRUQ7RUFDQSxJQUFJMkMsUUFBUSxJQUFJVCxPQUFPLEtBQUssWUFBWSxFQUFFO0lBQ3hDVSxJQUFJLEdBQUdELFFBQVE7SUFDZkEsUUFBUSxHQUFHVSxTQUFTO0VBQ3JCO0VBRUQsT0FBTztJQUFFWCxNQUFNO0lBQUVELE1BQU0sRUFBRUEsTUFBTSxDQUFDbkQsV0FBVyxFQUFFO0lBQUU0QyxPQUFPO0lBQUVTLFFBQVE7SUFBRUM7R0FBTTtBQUMxRTs7OztBQ3RGZ0IsU0FBQVUsbUJBQW1CQSxDQUNqQ0MsTUFBcUIsRUFDckJDLElBQW9CO0VBRXBCLE9BQU9DLHlFQUFZLENBQUM7SUFDbEJqQixRQUFRLEVBQUVnQixJQUFJLElBQUosZ0JBQUFBLElBQUksQ0FBRWhCLFFBQVE7SUFDeEJrQixNQUFNLEVBQUFDLFFBQUEsS0FDREgsSUFBSSxJQUFKLGdCQUFBQSxJQUFJLENBQUVFLE1BQU07TUFDZkUsa0JBQWtCLEVBQUU7S0FDckI7SUFDREMsT0FBTyxFQUFFQyxpRkFBb0IsQ0FBQztNQUFFQyxNQUFNLEVBQUVQLElBQUksSUFBSixnQkFBQUEsSUFBSSxDQUFFTztJQUFNLENBQUUsQ0FBQztJQUN2REMsYUFBYSxFQUFFLENBQUFSLElBQUksSUFBSixnQkFBQUEsSUFBSSxDQUFFUSxhQUFhLEtBQUlDLGtCQUFrQixFQUFFO0lBQzFEVixNQUFNO0lBQ05XLGtCQUFBLEVBQUFDLDZFQUFBQTtHQUNELENBQUMsQ0FBQ0MsVUFBVSxFQUFFO0FBQ2pCO0FBRWdCLFNBQUFDLGdCQUFnQkEsQ0FDOUJkLE1BQXFCLEVBQ3JCQyxJQUFvQjtFQUVwQixPQUFPQyxZQUFZLENBQUM7SUFDbEJqQixRQUFRLEVBQUVnQixJQUFJLElBQUosZ0JBQUFBLElBQUksQ0FBRWhCLFFBQVE7SUFDeEJrQixNQUFNLEVBQUFDLFFBQUEsS0FDREgsSUFBSSxJQUFKLGdCQUFBQSxJQUFJLENBQUVFLE1BQU07TUFDZkUsa0JBQWtCLEVBQUU7S0FDckI7SUFDREMsT0FBTyxFQUFFUyxpQkFBaUIsQ0FBQztNQUFFUCxNQUFNLEVBQUVQLElBQUksSUFBSixnQkFBQUEsSUFBSSxDQUFFTztJQUFNLENBQUUsQ0FBQztJQUNwREMsYUFBYSxFQUFFLENBQUFSLElBQUksSUFBSixnQkFBQUEsSUFBSSxDQUFFUSxhQUFhLEtBQUlDLGtCQUFrQixFQUFFO0lBQzFEVixNQUFNO0lBQ05XLGtCQUFBLEVBQUFDO0dBQ0QsQ0FBQyxDQUFDQyxVQUFVLEVBQUU7QUFDakI7QUFFQSxTQUFTSCxrQkFBa0JBLENBQUE7RUFBQSxJQUFBTSxPQUFBO0VBQ3pCLElBQUlDLEtBQUssSUFBQUQsT0FBQSxHQUFHUixNQUFNLEtBQU4sZ0JBQUFRLE9BQUEsQ0FBUUUsMkJBQTJCO0VBQy9DLElBQUlELEtBQUssSUFBSUEsS0FBSyxDQUFDRSxNQUFNLEVBQUU7SUFDekJGLEtBQUssR0FBQWIsUUFBQSxLQUNBYSxLQUFLO01BQ1JFLE1BQU0sRUFBRUMsaUJBQWlCLENBQUNILEtBQUssQ0FBQ0UsTUFBTTtLQUN2QztFQUNGO0VBQ0QsT0FBT0YsS0FBSztBQUNkO0FBRUEsU0FBU0csaUJBQWlCQSxDQUN4QkQsTUFBc0M7RUFFdEMsSUFBSSxDQUFDQSxNQUFNLEVBQUUsT0FBTyxJQUFJO0VBQ3hCLElBQUlFLE9BQU8sR0FBR3JFLE1BQU0sQ0FBQ3FFLE9BQU8sQ0FBQ0YsTUFBTSxDQUFDO0VBQ3BDLElBQUlHLFVBQVUsR0FBbUMsRUFBRTtFQUNuRCxLQUFLLElBQUksQ0FBQ2xFLEdBQUcsRUFBRW1FLEdBQUcsQ0FBQyxJQUFJRixPQUFPLEVBQUU7SUFDOUI7SUFDQTtJQUNBLElBQUlFLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxNQUFNLEtBQUssb0JBQW9CLEVBQUU7TUFDOUNGLFVBQVUsQ0FBQ2xFLEdBQUcsQ0FBQyxHQUFHLElBQUlxRSxpRkFBaUIsQ0FDckNGLEdBQUcsQ0FBQ0csTUFBTSxFQUNWSCxHQUFHLENBQUNJLFVBQVUsRUFDZEosR0FBRyxDQUFDSyxJQUFJLEVBQ1JMLEdBQUcsQ0FBQ00sUUFBUSxLQUFLLElBQUksQ0FDdEI7S0FDRixNQUFNLElBQUlOLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxNQUFNLEtBQUssT0FBTyxFQUFFO01BQ3hDO01BQ0EsSUFBSUQsR0FBRyxDQUFDTyxTQUFTLEVBQUU7UUFDakIsSUFBSUMsZ0JBQWdCLEdBQUd2QixNQUFNLENBQUNlLEdBQUcsQ0FBQ08sU0FBUyxDQUFDO1FBQzVDLElBQUksT0FBT0MsZ0JBQWdCLEtBQUssVUFBVSxFQUFFO1VBQzFDLElBQUk7WUFDRjtZQUNBLElBQUlDLEtBQUssR0FBRyxJQUFJRCxnQkFBZ0IsQ0FBQ1IsR0FBRyxDQUFDVSxPQUFPLENBQUM7WUFDN0M7WUFDQTtZQUNBRCxLQUFLLENBQUNFLEtBQUssR0FBRyxFQUFFO1lBQ2hCWixVQUFVLENBQUNsRSxHQUFHLENBQUMsR0FBRzRFLEtBQUs7V0FDeEIsQ0FBQyxPQUFPekQsQ0FBQyxFQUFFO1lBQ1Y7VUFBQTtRQUVIO01BQ0Y7TUFFRCxJQUFJK0MsVUFBVSxDQUFDbEUsR0FBRyxDQUFDLElBQUksSUFBSSxFQUFFO1FBQzNCLElBQUk0RSxLQUFLLEdBQUcsSUFBSXJDLEtBQUssQ0FBQzRCLEdBQUcsQ0FBQ1UsT0FBTyxDQUFDO1FBQ2xDO1FBQ0E7UUFDQUQsS0FBSyxDQUFDRSxLQUFLLEdBQUcsRUFBRTtRQUNoQlosVUFBVSxDQUFDbEUsR0FBRyxDQUFDLEdBQUc0RSxLQUFLO01BQ3hCO0lBQ0YsT0FBTTtNQUNMVixVQUFVLENBQUNsRSxHQUFHLENBQUMsR0FBR21FLEdBQUc7SUFDdEI7RUFDRjtFQUNELE9BQU9ELFVBQVU7QUFDbkI7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CRTtBQUNGLE1BQU1hLGdCQUFnQixHQUFHLGlCQUFpQjtBQUMxQyxNQUFNQyxtQkFBbUIsR0FBR0MseUxBQUssQ0FBQ0YsZ0JBQWdCLENBQUM7QUFTbkQ7O0FBRUc7QUFDRyxTQUFVRyxhQUFhQSxDQUFBQyxJQUFBLEVBS1I7RUFBQSxJQUxTO0lBQzVCdEQsUUFBUTtJQUNSdUQsUUFBUTtJQUNSckMsTUFBTTtJQUNOSztFQUNtQixJQUFBK0IsSUFBQTtFQUNuQixJQUFJRSxVQUFVLEdBQUdKLEtBQUssQ0FBQ0ssTUFBTSxFQUFrQjtFQUMvQyxJQUFJRCxVQUFVLENBQUNFLE9BQU8sSUFBSSxJQUFJLEVBQUU7SUFDOUJGLFVBQVUsQ0FBQ0UsT0FBTyxHQUFHcEMsb0JBQW9CLENBQUM7TUFBRUMsTUFBTTtNQUFFb0MsUUFBUSxFQUFFO0lBQUksQ0FBRSxDQUFDO0VBQ3RFO0VBRUQsSUFBSXRDLE9BQU8sR0FBR21DLFVBQVUsQ0FBQ0UsT0FBTztFQUNoQyxJQUFJLENBQUMxQixLQUFLLEVBQUU0QixZQUFZLENBQUMsR0FBR1IsS0FBSyxDQUFDUyxRQUFRLENBQUM7SUFDekMzRCxNQUFNLEVBQUVtQixPQUFPLENBQUNuQixNQUFNO0lBQ3RCNEQsUUFBUSxFQUFFekMsT0FBTyxDQUFDeUM7RUFDbkIsRUFBQztFQUNGLElBQUk7SUFBRUM7RUFBa0IsQ0FBRSxHQUFHN0MsTUFBTSxJQUFJLEVBQUU7RUFDekMsSUFBSThDLFFBQVEsR0FBR1osS0FBSyxDQUFDYSxXQUFXLENBQzdCQyxRQUF3RCxJQUFJO0lBQzNESCxrQkFBa0IsSUFBSVosbUJBQW1CLEdBQ3JDQSxtQkFBbUIsQ0FBQyxNQUFNUyxZQUFZLENBQUNNLFFBQVEsQ0FBQyxDQUFDLEdBQ2pETixZQUFZLENBQUNNLFFBQVEsQ0FBQztFQUM1QixDQUFDLEVBQ0QsQ0FBQ04sWUFBWSxFQUFFRyxrQkFBa0IsQ0FBQyxDQUNuQztFQUVEWCxLQUFLLENBQUNlLGVBQWUsQ0FBQyxNQUFNOUMsT0FBTyxDQUFDK0MsTUFBTSxDQUFDSixRQUFRLENBQUMsRUFBRSxDQUFDM0MsT0FBTyxFQUFFMkMsUUFBUSxDQUFDLENBQUM7RUFFMUUsb0JBQ0VaLEtBQUEsQ0FBQS9ELGFBQUEsQ0FBQ2dGLE1BQU07SUFDTHJFLFFBQVEsRUFBRUEsUUFBUTtJQUNsQnVELFFBQVEsRUFBRUEsUUFBUTtJQUNsQk8sUUFBUSxFQUFFOUIsS0FBSyxDQUFDOEIsUUFBUTtJQUN4QlEsY0FBYyxFQUFFdEMsS0FBSyxDQUFDOUIsTUFBTTtJQUM1QnFFLFNBQVMsRUFBRWxEO0VBQU8sRUFDbEI7QUFFTjtBQVNBOzs7QUFHRztBQUNHLFNBQVVtRCxVQUFVQSxDQUFBQyxLQUFBLEVBS1I7RUFBQSxJQUxTO0lBQ3pCekUsUUFBUTtJQUNSdUQsUUFBUTtJQUNSckMsTUFBTTtJQUNOSztFQUNnQixJQUFBa0QsS0FBQTtFQUNoQixJQUFJakIsVUFBVSxHQUFHSixLQUFLLENBQUNLLE1BQU0sRUFBZTtFQUM1QyxJQUFJRCxVQUFVLENBQUNFLE9BQU8sSUFBSSxJQUFJLEVBQUU7SUFDOUJGLFVBQVUsQ0FBQ0UsT0FBTyxHQUFHNUIsaUJBQWlCLENBQUM7TUFBRVAsTUFBTTtNQUFFb0MsUUFBUSxFQUFFO0lBQUksQ0FBRSxDQUFDO0VBQ25FO0VBRUQsSUFBSXRDLE9BQU8sR0FBR21DLFVBQVUsQ0FBQ0UsT0FBTztFQUNoQyxJQUFJLENBQUMxQixLQUFLLEVBQUU0QixZQUFZLENBQUMsR0FBR1IsS0FBSyxDQUFDUyxRQUFRLENBQUM7SUFDekMzRCxNQUFNLEVBQUVtQixPQUFPLENBQUNuQixNQUFNO0lBQ3RCNEQsUUFBUSxFQUFFekMsT0FBTyxDQUFDeUM7RUFDbkIsRUFBQztFQUNGLElBQUk7SUFBRUM7RUFBa0IsQ0FBRSxHQUFHN0MsTUFBTSxJQUFJLEVBQUU7RUFDekMsSUFBSThDLFFBQVEsR0FBR1osS0FBSyxDQUFDYSxXQUFXLENBQzdCQyxRQUF3RCxJQUFJO0lBQzNESCxrQkFBa0IsSUFBSVosbUJBQW1CLEdBQ3JDQSxtQkFBbUIsQ0FBQyxNQUFNUyxZQUFZLENBQUNNLFFBQVEsQ0FBQyxDQUFDLEdBQ2pETixZQUFZLENBQUNNLFFBQVEsQ0FBQztFQUM1QixDQUFDLEVBQ0QsQ0FBQ04sWUFBWSxFQUFFRyxrQkFBa0IsQ0FBQyxDQUNuQztFQUVEWCxLQUFLLENBQUNlLGVBQWUsQ0FBQyxNQUFNOUMsT0FBTyxDQUFDK0MsTUFBTSxDQUFDSixRQUFRLENBQUMsRUFBRSxDQUFDM0MsT0FBTyxFQUFFMkMsUUFBUSxDQUFDLENBQUM7RUFFMUUsb0JBQ0VaLEtBQUEsQ0FBQS9ELGFBQUEsQ0FBQ2dGLE1BQU07SUFDTHJFLFFBQVEsRUFBRUEsUUFBUTtJQUNsQnVELFFBQVEsRUFBRUEsUUFBUTtJQUNsQk8sUUFBUSxFQUFFOUIsS0FBSyxDQUFDOEIsUUFBUTtJQUN4QlEsY0FBYyxFQUFFdEMsS0FBSyxDQUFDOUIsTUFBTTtJQUM1QnFFLFNBQVMsRUFBRWxEO0VBQU8sRUFDbEI7QUFFTjtBQVNBOzs7OztBQUtHO0FBQ0gsU0FBU3FELGFBQWFBLENBQUFDLEtBQUEsRUFLRDtFQUFBLElBTEU7SUFDckIzRSxRQUFRO0lBQ1J1RCxRQUFRO0lBQ1JyQyxNQUFNO0lBQ05HO0VBQ21CLElBQUFzRCxLQUFBO0VBQ25CLElBQUksQ0FBQzNDLEtBQUssRUFBRTRCLFlBQVksQ0FBQyxHQUFHUixLQUFLLENBQUNTLFFBQVEsQ0FBQztJQUN6QzNELE1BQU0sRUFBRW1CLE9BQU8sQ0FBQ25CLE1BQU07SUFDdEI0RCxRQUFRLEVBQUV6QyxPQUFPLENBQUN5QztFQUNuQixFQUFDO0VBQ0YsSUFBSTtJQUFFQztFQUFrQixDQUFFLEdBQUc3QyxNQUFNLElBQUksRUFBRTtFQUN6QyxJQUFJOEMsUUFBUSxHQUFHWixLQUFLLENBQUNhLFdBQVcsQ0FDN0JDLFFBQXdELElBQUk7SUFDM0RILGtCQUFrQixJQUFJWixtQkFBbUIsR0FDckNBLG1CQUFtQixDQUFDLE1BQU1TLFlBQVksQ0FBQ00sUUFBUSxDQUFDLENBQUMsR0FDakROLFlBQVksQ0FBQ00sUUFBUSxDQUFDO0VBQzVCLENBQUMsRUFDRCxDQUFDTixZQUFZLEVBQUVHLGtCQUFrQixDQUFDLENBQ25DO0VBRURYLEtBQUssQ0FBQ2UsZUFBZSxDQUFDLE1BQU05QyxPQUFPLENBQUMrQyxNQUFNLENBQUNKLFFBQVEsQ0FBQyxFQUFFLENBQUMzQyxPQUFPLEVBQUUyQyxRQUFRLENBQUMsQ0FBQztFQUUxRSxvQkFDRVosS0FBQSxDQUFBL0QsYUFBQSxDQUFDZ0YsTUFBTTtJQUNMckUsUUFBUSxFQUFFQSxRQUFRO0lBQ2xCdUQsUUFBUSxFQUFFQSxRQUFRO0lBQ2xCTyxRQUFRLEVBQUU5QixLQUFLLENBQUM4QixRQUFRO0lBQ3hCUSxjQUFjLEVBQUV0QyxLQUFLLENBQUM5QixNQUFNO0lBQzVCcUUsU0FBUyxFQUFFbEQ7RUFBTyxFQUNsQjtBQUVOO0FBRUEsSUFBQTFCLEtBQWEsSUFFWjtBQWNELE1BQU1rRixTQUFTLEdBQ2IsT0FBT3RELE1BQU0sS0FBSyxXQUFXLElBQzdCLE9BQU9BLE1BQU0sQ0FBQ25DLFFBQVEsS0FBSyxXQUFXLElBQ3RDLE9BQU9tQyxNQUFNLENBQUNuQyxRQUFRLENBQUNDLGFBQWEsS0FBSyxXQUFXO0FBRXRELE1BQU15RixrQkFBa0IsR0FBRywrQkFBK0I7QUFFMUQ7O0FBRUc7QUFDVSxNQUFBQyxJQUFJLGdCQUFHM0IsNkNBQWdCLENBQ2xDLFNBQVM2QixXQUFXQSxDQUFBQyxLQUFBLEVBWWxCQyxHQUFHO0VBQUEsSUFYSDtNQUNFQyxPQUFPO01BQ1BDLFFBQVE7TUFDUkMsY0FBYztNQUNkQyxPQUFPO01BQ1B2RCxLQUFLO01BQ0x4RSxNQUFNO01BQ05nSSxFQUFFO01BQ0ZDO0lBQ08sQ0FDUixHQUFBUCxLQUFBO0lBRElRLElBQUksR0FBQUMsNkJBQUEsQ0FBQVQsS0FBQSxFQUFBVSxTQUFBO0VBSVQsSUFBSTtJQUFFNUY7RUFBUSxDQUFFLEdBQUdvRCw2Q0FBZ0IsQ0FBQzBDLDRFQUFpQixDQUFDO0VBRXREO0VBQ0EsSUFBSUMsWUFBWTtFQUNoQixJQUFJQyxVQUFVLEdBQUcsS0FBSztFQUV0QixJQUFJLE9BQU9SLEVBQUUsS0FBSyxRQUFRLElBQUlWLGtCQUFrQixDQUFDbUIsSUFBSSxDQUFDVCxFQUFFLENBQUMsRUFBRTtJQUN6RDtJQUNBTyxZQUFZLEdBQUdQLEVBQUU7SUFFakI7SUFDQSxJQUFJWCxTQUFTLEVBQUU7TUFDYixJQUFJO1FBQ0YsSUFBSXFCLFVBQVUsR0FBRyxJQUFJQyxHQUFHLENBQUM1RSxNQUFNLENBQUN1QyxRQUFRLENBQUNzQyxJQUFJLENBQUM7UUFDOUMsSUFBSUMsU0FBUyxHQUFHYixFQUFFLENBQUNjLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FDL0IsSUFBSUgsR0FBRyxDQUFDRCxVQUFVLENBQUNLLFFBQVEsR0FBR2YsRUFBRSxDQUFDLEdBQ2pDLElBQUlXLEdBQUcsQ0FBQ1gsRUFBRSxDQUFDO1FBQ2YsSUFBSWdCLElBQUksR0FBR2pHLDBFQUFhLENBQUM4RixTQUFTLENBQUNJLFFBQVEsRUFBRXpHLFFBQVEsQ0FBQztRQUV0RCxJQUFJcUcsU0FBUyxDQUFDSyxNQUFNLEtBQUtSLFVBQVUsQ0FBQ1EsTUFBTSxJQUFJRixJQUFJLElBQUksSUFBSSxFQUFFO1VBQzFEO1VBQ0FoQixFQUFFLEdBQUdnQixJQUFJLEdBQUdILFNBQVMsQ0FBQ00sTUFBTSxHQUFHTixTQUFTLENBQUNPLElBQUk7UUFDOUMsT0FBTTtVQUNMWixVQUFVLEdBQUcsSUFBSTtRQUNsQjtPQUNGLENBQUMsT0FBTzFHLENBQUMsRUFBRTtRQUNWO1FBQ0FLLE1BQUEsR0FBQUcsQ0FJQztNQUNGO0lBQ0Y7RUFDRjtFQUVEO0VBQ0EsSUFBSXNHLElBQUksR0FBR1MsK0RBQU8sQ0FBQ3JCLEVBQUUsRUFBRTtJQUFFSDtFQUFVLEVBQUM7RUFFcEMsSUFBSXlCLGVBQWUsR0FBR0MsbUJBQW1CLENBQUN2QixFQUFFLEVBQUU7SUFDNUNELE9BQU87SUFDUHZELEtBQUs7SUFDTHhFLE1BQU07SUFDTmlJLGtCQUFrQjtJQUNsQko7RUFDRCxFQUFDO0VBQ0YsU0FBUzJCLFdBQVdBLENBQ2xCOUosS0FBc0Q7SUFFdEQsSUFBSWtJLE9BQU8sRUFBRUEsT0FBTyxDQUFDbEksS0FBSyxDQUFDO0lBQzNCLElBQUksQ0FBQ0EsS0FBSyxDQUFDK0osZ0JBQWdCLEVBQUU7TUFDM0JILGVBQWUsQ0FBQzVKLEtBQUssQ0FBQztJQUN2QjtFQUNIO0VBRUE7SUFDRTtJQUNBa0csZ0RBQUEsTUFBQWpDLFFBQUEsS0FDTXVFLElBQUk7TUFDUlUsSUFBSSxFQUFFTCxZQUFZLElBQUlLLElBQUk7TUFDMUJoQixPQUFPLEVBQUVZLFVBQVUsSUFBSVYsY0FBYyxHQUFHRixPQUFPLEdBQUc0QixXQUFXO01BQzdEN0IsR0FBRyxFQUFFQSxHQUFHO01BQ1IzSCxNQUFNLEVBQUVBO0tBQU07RUFBQTtBQUdwQixDQUFDO0FBR0gsSUFBQW1DLEtBQWEsSUFFWjtBQXVCRDs7QUFFRztBQUNVLE1BQUF1SCxPQUFPLGdCQUFHOUQsZ0RBQUFBLEtBQUssQ0FBQzRCLFVBQVUsQ0FDckMsU0FBU21DLGNBQWNBLENBQUFDLEtBQUEsRUFXckJqQyxHQUFHO0VBQUEsSUFWSDtNQUNFLGNBQWMsRUFBRWtDLGVBQWUsR0FBRyxNQUFNO01BQ3hDQyxhQUFhLEdBQUcsS0FBSztNQUNyQkMsU0FBUyxFQUFFQyxhQUFhLEdBQUcsRUFBRTtNQUM3QkMsR0FBRyxHQUFHLEtBQUs7TUFDWEMsS0FBSyxFQUFFQyxTQUFTO01BQ2hCbkMsRUFBRTtNQUNGakM7SUFDTyxDQUNSLEdBQUE2RCxLQUFBO0lBREkxQixJQUFJLEdBQUFDLDZCQUFBLENBQUF5QixLQUFBLEVBQUFRLFVBQUE7RUFJVCxJQUFJcEIsSUFBSSxHQUFHcUIsZUFBZSxDQUFDckMsRUFBRSxFQUFFO0lBQUVILFFBQVEsRUFBRUssSUFBSSxDQUFDTDtFQUFRLENBQUUsQ0FBQztFQUMzRCxJQUFJdkIsUUFBUSxHQUFHZ0UsV0FBVyxFQUFFO0VBQzVCLElBQUlDLFdBQVcsR0FBRzNFLEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQ21DLDZCQUFzQixDQUFDO0VBQzFELElBQUk7SUFBRXpEO0VBQVMsQ0FBRSxHQUFHbkIsS0FBSyxDQUFDeUMsVUFBVSxDQUFDQyx3QkFBaUIsQ0FBQztFQUV2RCxJQUFJbUMsVUFBVSxHQUFHMUQsU0FBUyxDQUFDMkQsY0FBYyxHQUNyQzNELFNBQVMsQ0FBQzJELGNBQWMsQ0FBQzFCLElBQUksQ0FBQyxDQUFDQyxRQUFRLEdBQ3ZDRCxJQUFJLENBQUNDLFFBQVE7RUFDakIsSUFBSTBCLGdCQUFnQixHQUFHckUsUUFBUSxDQUFDMkMsUUFBUTtFQUN4QyxJQUFJMkIsb0JBQW9CLEdBQ3RCTCxXQUFXLElBQUlBLFdBQVcsQ0FBQ00sVUFBVSxJQUFJTixXQUFXLENBQUNNLFVBQVUsQ0FBQ3ZFLFFBQVEsR0FDcEVpRSxXQUFXLENBQUNNLFVBQVUsQ0FBQ3ZFLFFBQVEsQ0FBQzJDLFFBQVEsR0FDeEMsSUFBSTtFQUVWLElBQUksQ0FBQ2EsYUFBYSxFQUFFO0lBQ2xCYSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLENBQUNyTCxXQUFXLEVBQUU7SUFDakRzTCxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQ3ZDQSxvQkFBb0IsQ0FBQ3RMLFdBQVcsRUFBRSxHQUNsQyxJQUFJO0lBQ1JtTCxVQUFVLEdBQUdBLFVBQVUsQ0FBQ25MLFdBQVcsRUFBRTtFQUN0QztFQUVELElBQUl3TCxRQUFRLEdBQ1ZILGdCQUFnQixLQUFLRixVQUFVLElBQzlCLENBQUNSLEdBQUcsSUFDSFUsZ0JBQWdCLENBQUM3QixVQUFVLENBQUMyQixVQUFVLENBQUMsSUFDdkNFLGdCQUFnQixDQUFDSSxNQUFNLENBQUNOLFVBQVUsQ0FBQ08sTUFBTSxDQUFDLEtBQUssR0FBSTtFQUV2RCxJQUFJQyxTQUFTLEdBQ1hMLG9CQUFvQixJQUFJLElBQUksS0FDM0JBLG9CQUFvQixLQUFLSCxVQUFVLElBQ2pDLENBQUNSLEdBQUcsSUFDSFcsb0JBQW9CLENBQUM5QixVQUFVLENBQUMyQixVQUFVLENBQUMsSUFDM0NHLG9CQUFvQixDQUFDRyxNQUFNLENBQUNOLFVBQVUsQ0FBQ08sTUFBTSxDQUFDLEtBQUssR0FBSSxDQUFDO0VBRTlELElBQUlFLFdBQVcsR0FBR0osUUFBUSxHQUFHakIsZUFBZSxHQUFHeEcsU0FBUztFQUV4RCxJQUFJMEcsU0FBNkI7RUFDakMsSUFBSSxPQUFPQyxhQUFhLEtBQUssVUFBVSxFQUFFO0lBQ3ZDRCxTQUFTLEdBQUdDLGFBQWEsQ0FBQztNQUFFYyxRQUFRO01BQUVHO0lBQVcsRUFBQztFQUNuRCxPQUFNO0lBQ0w7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBbEIsU0FBUyxHQUFHLENBQ1ZDLGFBQWEsRUFDYmMsUUFBUSxHQUFHLFFBQVEsR0FBRyxJQUFJLEVBQzFCRyxTQUFTLEdBQUcsU0FBUyxHQUFHLElBQUksQ0FDN0IsQ0FDRUUsTUFBTSxDQUFDQyxPQUFPLENBQUMsQ0FDZkMsSUFBSSxDQUFDLEdBQUcsQ0FBQztFQUNiO0VBRUQsSUFBSW5CLEtBQUssR0FDUCxPQUFPQyxTQUFTLEtBQUssVUFBVSxHQUMzQkEsU0FBUyxDQUFDO0lBQUVXLFFBQVE7SUFBRUc7R0FBVyxDQUFDLEdBQ2xDZCxTQUFTO0VBRWYsb0JBQ0V2RSxLQUFDLENBQUEvRCxhQUFBLENBQUEwRixJQUFJLEVBQUE1RCxRQUFBLEtBQ0N1RSxJQUFJO0lBQ00sZ0JBQUFnRCxXQUFXO0lBQ3pCbkIsU0FBUyxFQUFFQSxTQUFTO0lBQ3BCcEMsR0FBRyxFQUFFQSxHQUFHO0lBQ1J1QyxLQUFLLEVBQUVBLEtBQUs7SUFDWmxDLEVBQUUsRUFBRUE7RUFBRSxJQUVMLE9BQU9qQyxRQUFRLEtBQUssVUFBVSxHQUMzQkEsUUFBUSxDQUFDO0lBQUUrRSxRQUFRO0lBQUVHO0dBQVcsQ0FBQyxHQUNqQ2xGLFFBQVEsQ0FDUDtBQUVYLENBQUM7QUFHSCxJQUFBNUQsS0FBYSxJQUVaO0FBK0REOzs7OztBQUtHO0FBQ0ksTUFBTW1KLElBQUksZ0JBQUcxRixnREFBQUEsS0FBSyxDQUFDNEIsVUFBVSxDQUNsQyxDQUFDK0QsS0FBSyxFQUFFNUQsR0FBRyxLQUFJO0VBQ2IsSUFBSTZELE1BQU0sR0FBR0MsU0FBUyxFQUFFO0VBQ3hCLG9CQUFPN0YsS0FBQyxDQUFBL0QsYUFBQSxDQUFBNkosUUFBUSxFQUFBL0gsUUFBQSxLQUFLNEgsS0FBSztJQUFFQyxNQUFNLEVBQUVBLE1BQU07SUFBRTdELEdBQUcsRUFBRUE7RUFBRyxHQUFJO0FBQzFELENBQUM7QUFHSCxJQUFBeEYsS0FBYSxJQUVaO0FBY0QsTUFBTXVKLFFBQVEsZ0JBQUc5RixnREFBQUEsS0FBSyxDQUFDNEIsVUFBVSxDQUMvQixDQUFBbUUsS0FBQSxFQWFFQyxZQUFZLEtBQ1Y7RUFBQSxJQWJGO01BQ0U5RCxjQUFjO01BQ2RDLE9BQU87TUFDUHZELEtBQUs7TUFDTC9CLE1BQU0sR0FBR3pELGFBQWE7TUFDdEIwRCxNQUFNO01BQ05tSixRQUFRO01BQ1JMLE1BQU07TUFDTjNELFFBQVE7TUFDUkk7SUFDUSxDQUNULEdBQUEwRCxLQUFBO0lBRElKLEtBQUssR0FBQXBELDZCQUFBLENBQUF3RCxLQUFBLEVBQUFHLFVBQUE7RUFJVixJQUFJQyxVQUFVLEdBQ1p0SixNQUFNLENBQUNuRCxXQUFXLEVBQUUsS0FBSyxLQUFLLEdBQUcsS0FBSyxHQUFHLE1BQU07RUFDakQsSUFBSTBNLFVBQVUsR0FBR0MsYUFBYSxDQUFDdkosTUFBTSxFQUFFO0lBQUVtRjtFQUFVLEVBQUM7RUFDcEQsSUFBSXFFLGFBQWEsR0FBNkN4TSxLQUFLLElBQUk7SUFDckVtTSxRQUFRLElBQUlBLFFBQVEsQ0FBQ25NLEtBQUssQ0FBQztJQUMzQixJQUFJQSxLQUFLLENBQUMrSixnQkFBZ0IsRUFBRTtJQUM1Qi9KLEtBQUssQ0FBQ3lNLGNBQWMsRUFBRTtJQUV0QixJQUFJQyxTQUFTLEdBQUkxTSxLQUFvQyxDQUFDMk0sV0FBVyxDQUM5REQsU0FBcUM7SUFFeEMsSUFBSUUsWUFBWSxHQUNiLENBQUFGLFNBQVMsSUFBVCxnQkFBQUEsU0FBUyxDQUFFdEosWUFBWSxDQUFDLFlBQVksQ0FBZ0MsS0FDckVMLE1BQU07SUFFUitJLE1BQU0sQ0FBQ1ksU0FBUyxJQUFJMU0sS0FBSyxDQUFDNk0sYUFBYSxFQUFFO01BQ3ZDOUosTUFBTSxFQUFFNkosWUFBWTtNQUNwQnZFLE9BQU87TUFDUHZELEtBQUs7TUFDTHFELFFBQVE7TUFDUkk7SUFDRCxFQUFDO0dBQ0g7RUFFRCxvQkFDRXJDLEtBQUEsQ0FBQS9ELGFBQUEsU0FBQThCLFFBQUE7SUFDRWdFLEdBQUcsRUFBRWlFLFlBQVk7SUFDakJuSixNQUFNLEVBQUVzSixVQUFVO0lBQ2xCckosTUFBTSxFQUFFc0osVUFBVTtJQUNsQkgsUUFBUSxFQUFFL0QsY0FBYyxHQUFHK0QsUUFBUSxHQUFHSztHQUNsQyxFQUFBWCxLQUFLLEVBQ1Q7QUFFTixDQUFDLENBQ0Y7QUFFRCxJQUFBcEosS0FBYSxJQUVaO0FBT0Q7OztBQUdHO1NBQ2FxSyxpQkFBaUJBLENBQUFDLEtBQUEsRUFHUjtFQUFBLElBSFM7SUFDaENDLE1BQU07SUFDTkM7RUFDdUIsSUFBQUYsS0FBQTtFQUN2Qkcsb0JBQW9CLENBQUM7SUFBRUYsTUFBTTtJQUFFQztFQUFVLENBQUUsQ0FBQztFQUM1QyxPQUFPLElBQUk7QUFDYjtBQUVBLElBQUF4SyxLQUFhLElBRVo7QUFDRDtBQUVBO0FBQ0E7QUFDQTtBQUVBLElBQUswSyxjQUtKO0FBTEQsV0FBS0EsY0FBYztFQUNqQkEsY0FBQSxpREFBNkM7RUFDN0NBLGNBQUEsMkJBQXVCO0VBQ3ZCQSxjQUFBLHlDQUFxQztFQUNyQ0EsY0FBQSw2QkFBeUI7QUFDM0IsQ0FBQyxFQUxJQSxjQUFjLEtBQWRBLGNBQWMsR0FLbEI7QUFFRCxJQUFLQyxtQkFHSjtBQUhELFdBQUtBLG1CQUFtQjtFQUN0QkEsbUJBQUEsK0JBQTJCO0VBQzNCQSxtQkFBQSxpREFBNkM7QUFDL0MsQ0FBQyxFQUhJQSxtQkFBbUIsS0FBbkJBLG1CQUFtQixHQUd2QjtBQUVELFNBQVNDLHlCQUF5QkEsQ0FDaENDLFFBQThDO0VBRTlDLE9BQVVBLFFBQVE7QUFDcEI7QUFFQSxTQUFTQyxvQkFBb0JBLENBQUNELFFBQXdCO0VBQ3BELElBQUlFLEdBQUcsR0FBR3RILEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQzhFLHdCQUFpQixDQUFDO0VBQzdDLENBQVVELEdBQUcsR0FBQS9LLE1BQWIsR0FBQWlMLENBQW1ELEdBQW5EQSxnQkFBUztFQUNULE9BQU9GLEdBQUc7QUFDWjtBQUVBLFNBQVNHLGtCQUFrQkEsQ0FBQ0wsUUFBNkI7RUFDdkQsSUFBSXhJLEtBQUssR0FBR29CLEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQ21DLDZCQUFzQixDQUFDO0VBQ3BELENBQVVoRyxLQUFLLEdBQUFyQyxNQUFmLEdBQUFpTCxDQUFxRCxHQUFyREEsZ0JBQVM7RUFDVCxPQUFPNUksS0FBSztBQUNkO0FBRUE7Ozs7QUFJRztTQUNhK0UsbUJBQW1CQSxDQUNqQ3ZCLEVBQU0sRUFBQXNGLEtBQUEsRUFhQTtFQUFBLElBWk47SUFDRXROLE1BQU07SUFDTitILE9BQU8sRUFBRXdGLFdBQVc7SUFDcEIvSSxLQUFLO0lBQ0x5RCxrQkFBa0I7SUFDbEJKO3lCQU9FLEVBQUUsR0FBQXlGLEtBQUE7RUFFTixJQUFJRSxRQUFRLEdBQUdDLG1FQUFXLEVBQUU7RUFDNUIsSUFBSW5ILFFBQVEsR0FBR2dFLG1FQUFXLEVBQUU7RUFDNUIsSUFBSXRCLElBQUksR0FBR3FCLHVFQUFlLENBQUNyQyxFQUFFLEVBQUU7SUFBRUg7RUFBVSxFQUFDO0VBRTVDLE9BQU9qQyw4Q0FBaUIsQ0FDckJsRyxLQUFzQyxJQUFJO0lBQ3pDLElBQUlLLHNCQUFzQixDQUFDTCxLQUFLLEVBQUVNLE1BQU0sQ0FBQyxFQUFFO01BQ3pDTixLQUFLLENBQUN5TSxjQUFjLEVBQUU7TUFFdEI7TUFDQTtNQUNBLElBQUlwRSxPQUFPLEdBQ1R3RixXQUFXLEtBQUtsSyxTQUFTLEdBQ3JCa0ssV0FBVyxHQUNYRyx1RUFBVSxDQUFDcEgsUUFBUSxDQUFDLEtBQUtvSCx1RUFBVSxDQUFDMUUsSUFBSSxDQUFDO01BRS9Dd0UsUUFBUSxDQUFDeEYsRUFBRSxFQUFFO1FBQUVELE9BQU87UUFBRXZELEtBQUs7UUFBRXlELGtCQUFrQjtRQUFFSjtNQUFRLENBQUUsQ0FBQztJQUMvRDtHQUNGLEVBQ0QsQ0FDRXZCLFFBQVEsRUFDUmtILFFBQVEsRUFDUnhFLElBQUksRUFDSnVFLFdBQVcsRUFDWC9JLEtBQUssRUFDTHhFLE1BQU0sRUFDTmdJLEVBQUUsRUFDRkMsa0JBQWtCLEVBQ2xCSixRQUFRLENBQ1QsQ0FDRjtBQUNIO0FBRUE7OztBQUdHO0FBQ0csU0FBVThGLGVBQWVBLENBQzdCQyxXQUFpQztFQUVqQ3pMLE1BQUEsR0FBQUcsQ0FVQztFQUVELElBQUl1TCxzQkFBc0IsR0FBR2pJLEtBQUssQ0FBQ0ssTUFBTSxDQUFDL0Ysa0JBQWtCLENBQUMwTixXQUFXLENBQUMsQ0FBQztFQUMxRSxJQUFJRSxxQkFBcUIsR0FBR2xJLEtBQUssQ0FBQ0ssTUFBTSxDQUFDLEtBQUssQ0FBQztFQUUvQyxJQUFJSyxRQUFRLEdBQUdnRSxXQUFXLEVBQUU7RUFDNUIsSUFBSW5KLFlBQVksR0FBR3lFLEtBQUssQ0FBQ21JLE9BQU8sQ0FDOUI7RUFDRTtFQUNBO0VBQ0E7RUFDQS9NLDBCQUEwQixDQUN4QnNGLFFBQVEsQ0FBQzZDLE1BQU0sRUFDZjJFLHFCQUFxQixDQUFDNUgsT0FBTyxHQUFHLElBQUksR0FBRzJILHNCQUFzQixDQUFDM0gsT0FBTyxDQUN0RSxFQUNILENBQUNJLFFBQVEsQ0FBQzZDLE1BQU0sQ0FBQyxDQUNsQjtFQUVELElBQUlxRSxRQUFRLEdBQUdDLFdBQVcsRUFBRTtFQUM1QixJQUFJTyxlQUFlLEdBQUdwSSxLQUFLLENBQUNhLFdBQVcsQ0FDckMsQ0FBQ3dILFFBQVEsRUFBRUMsZUFBZSxLQUFJO0lBQzVCLE1BQU1DLGVBQWUsR0FBR2pPLGtCQUFrQixDQUN4QyxPQUFPK04sUUFBUSxLQUFLLFVBQVUsR0FBR0EsUUFBUSxDQUFDOU0sWUFBWSxDQUFDLEdBQUc4TSxRQUFRLENBQ25FO0lBQ0RILHFCQUFxQixDQUFDNUgsT0FBTyxHQUFHLElBQUk7SUFDcENzSCxRQUFRLENBQUMsR0FBRyxHQUFHVyxlQUFlLEVBQUVELGVBQWUsQ0FBQztFQUNsRCxDQUFDLEVBQ0QsQ0FBQ1YsUUFBUSxFQUFFck0sWUFBWSxDQUFDLENBQ3pCO0VBRUQsT0FBTyxDQUFDQSxZQUFZLEVBQUU2TSxlQUFlLENBQUM7QUFDeEM7QUEyQ0EsU0FBU0ksNEJBQTRCQSxDQUFBO0VBQ25DLElBQUksT0FBT3hNLFFBQVEsS0FBSyxXQUFXLEVBQUU7SUFDbkMsTUFBTSxJQUFJc0IsS0FBSyxDQUNiLG1EQUFtRCxHQUNqRCw4REFBOEQsQ0FDakU7RUFDRjtBQUNIO0FBRUE7OztBQUdHO1NBQ2F1SSxTQUFTQSxDQUFBO0VBQ3ZCLElBQUk7SUFBRTRDO0VBQU0sQ0FBRSxHQUFHcEIsb0JBQW9CLENBQUNKLGNBQWMsQ0FBQ3lCLFNBQVMsQ0FBQztFQUMvRCxJQUFJO0lBQUU5TDtFQUFRLENBQUUsR0FBR29ELEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQ0Msd0JBQWlCLENBQUM7RUFDdEQsSUFBSWlHLGNBQWMsR0FBR0MsaUJBQVUsRUFBRTtFQUVqQyxPQUFPNUksS0FBSyxDQUFDYSxXQUFXLENBQ3RCLFVBQUN6RyxNQUFNLEVBQUV5TyxPQUFPLEVBQVM7SUFBQSxJQUFoQkEsT0FBTztNQUFQQSxPQUFPLEdBQUcsRUFBRTtJQUFBO0lBQ25CTCw0QkFBNEIsRUFBRTtJQUU5QixJQUFJO01BQUUxTCxNQUFNO01BQUVELE1BQU07TUFBRVAsT0FBTztNQUFFUyxRQUFRO01BQUVDO0lBQUksQ0FBRSxHQUFHTCxxQkFBcUIsQ0FDckV2QyxNQUFNLEVBQ053QyxRQUFRLENBQ1Q7SUFFRDZMLE1BQU0sQ0FBQ2IsUUFBUSxDQUFDaUIsT0FBTyxDQUFDL0wsTUFBTSxJQUFJQSxNQUFNLEVBQUU7TUFDeEN1RixrQkFBa0IsRUFBRXdHLE9BQU8sQ0FBQ3hHLGtCQUFrQjtNQUM5Q3RGLFFBQVE7TUFDUkMsSUFBSTtNQUNKbUosVUFBVSxFQUFFMEMsT0FBTyxDQUFDaE0sTUFBTSxJQUFLQSxNQUF5QjtNQUN4RGlNLFdBQVcsRUFBRUQsT0FBTyxDQUFDdk0sT0FBTyxJQUFLQSxPQUF1QjtNQUN4RDZGLE9BQU8sRUFBRTBHLE9BQU8sQ0FBQzFHLE9BQU87TUFDeEJ2RCxLQUFLLEVBQUVpSyxPQUFPLENBQUNqSyxLQUFLO01BQ3BCbUssV0FBVyxFQUFFSjtJQUNkLEVBQUM7R0FDSCxFQUNELENBQUNGLE1BQU0sRUFBRTdMLFFBQVEsRUFBRStMLGNBQWMsQ0FBQyxDQUNuQztBQUNIO0FBRUE7O0FBRUc7QUFDSCxTQUFTSyxnQkFBZ0JBLENBQ3ZCQyxVQUFrQixFQUNsQkMsY0FBc0I7RUFFdEIsSUFBSTtJQUFFVDtFQUFNLENBQUUsR0FBR3BCLG9CQUFvQixDQUFDSixjQUFjLENBQUNrQyxnQkFBZ0IsQ0FBQztFQUN0RSxJQUFJO0lBQUV2TTtFQUFRLENBQUUsR0FBR29ELEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQ0Msd0JBQWlCLENBQUM7RUFFdEQsT0FBTzFDLEtBQUssQ0FBQ2EsV0FBVyxDQUN0QixVQUFDekcsTUFBTSxFQUFFeU8sT0FBTyxFQUFTO0lBQUEsSUFBaEJBLE9BQU87TUFBUEEsT0FBTyxHQUFHLEVBQUU7SUFBQTtJQUNuQkwsNEJBQTRCLEVBQUU7SUFFOUIsSUFBSTtNQUFFMUwsTUFBTTtNQUFFRCxNQUFNO01BQUVQLE9BQU87TUFBRVMsUUFBUTtNQUFFQztJQUFJLENBQUUsR0FBR0wscUJBQXFCLENBQ3JFdkMsTUFBTSxFQUNOd0MsUUFBUSxDQUNUO0lBRUQsRUFDRXNNLGNBQWMsSUFBSSxJQUFJLElBQUEzTSxNQUR4QixHQUFBaUwsQ0FFeUMsR0FGekNBLGdCQUFTO0lBSVRpQixNQUFNLENBQUNXLEtBQUssQ0FBQ0gsVUFBVSxFQUFFQyxjQUFjLEVBQUVMLE9BQU8sQ0FBQy9MLE1BQU0sSUFBSUEsTUFBTSxFQUFFO01BQ2pFdUYsa0JBQWtCLEVBQUV3RyxPQUFPLENBQUN4RyxrQkFBa0I7TUFDOUN0RixRQUFRO01BQ1JDLElBQUk7TUFDSm1KLFVBQVUsRUFBRTBDLE9BQU8sQ0FBQ2hNLE1BQU0sSUFBS0EsTUFBeUI7TUFDeERpTSxXQUFXLEVBQUVELE9BQU8sQ0FBQ3ZNLE9BQU8sSUFBS0E7SUFDbEMsRUFBQztHQUNILEVBQ0QsQ0FBQ21NLE1BQU0sRUFBRTdMLFFBQVEsRUFBRXFNLFVBQVUsRUFBRUMsY0FBYyxDQUFDLENBQy9DO0FBQ0g7QUFFQTtBQUNBO0FBQ00sU0FBVTdDLGFBQWFBLENBQzNCdkosTUFBZSxFQUFBdU0sTUFBQSxFQUNzQztFQUFBLElBQXJEO0lBQUVwSDswQkFBaUQsRUFBRSxHQUFBb0gsTUFBQTtFQUVyRCxJQUFJO0lBQUV6TTtFQUFRLENBQUUsR0FBR29ELEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQ0Msd0JBQWlCLENBQUM7RUFDdEQsSUFBSTRHLFlBQVksR0FBR3RKLEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQzhHLG1CQUFZLENBQUM7RUFDakQsQ0FBVUQsWUFBWSxHQUFBL00sTUFBQSxHQUF0QmlMLENBQTJFLEdBQTNFQSxnQkFBUztFQUVULElBQUksQ0FBQ2dDLEtBQUssQ0FBQyxHQUFHRixZQUFZLENBQUNHLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzVDO0VBQ0E7RUFDQSxJQUFJdEcsSUFBSSxHQUFBckYsUUFBQSxDQUFRLElBQUEwRyxlQUFlLENBQUMzSCxNQUFNLEdBQUdBLE1BQU0sR0FBRyxHQUFHLEVBQUU7SUFBRW1GO0VBQVEsQ0FBRSxDQUFDLENBQUU7RUFFdEU7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUl2QixRQUFRLEdBQUdnRSxXQUFXLEVBQUU7RUFDNUIsSUFBSTVILE1BQU0sSUFBSSxJQUFJLEVBQUU7SUFDbEI7SUFDQTtJQUNBc0csSUFBSSxDQUFDRyxNQUFNLEdBQUc3QyxRQUFRLENBQUM2QyxNQUFNO0lBRTdCO0lBQ0E7SUFDQTtJQUNBLElBQUlpRyxLQUFLLENBQUNHLEtBQUssQ0FBQ0MsS0FBSyxFQUFFO01BQ3JCLElBQUlDLE1BQU0sR0FBRyxJQUFJclAsZUFBZSxDQUFDNEksSUFBSSxDQUFDRyxNQUFNLENBQUM7TUFDN0NzRyxNQUFNLENBQUNDLE1BQU0sQ0FBQyxPQUFPLENBQUM7TUFDdEIxRyxJQUFJLENBQUNHLE1BQU0sR0FBR3NHLE1BQU0sQ0FBQ0UsUUFBUSxFQUFFLFNBQU9GLE1BQU0sQ0FBQ0UsUUFBUSxFQUFFLEdBQUssRUFBRTtJQUMvRDtFQUNGO0VBRUQsSUFBSSxDQUFDLENBQUNqTixNQUFNLElBQUlBLE1BQU0sS0FBSyxHQUFHLEtBQUswTSxLQUFLLENBQUNHLEtBQUssQ0FBQ0MsS0FBSyxFQUFFO0lBQ3BEeEcsSUFBSSxDQUFDRyxNQUFNLEdBQUdILElBQUksQ0FBQ0csTUFBTSxHQUNyQkgsSUFBSSxDQUFDRyxNQUFNLENBQUNwQixPQUFPLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxHQUNyQyxRQUFRO0VBQ2I7RUFFRDtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUl2RixRQUFRLEtBQUssR0FBRyxFQUFFO0lBQ3BCd0csSUFBSSxDQUFDQyxRQUFRLEdBQ1hELElBQUksQ0FBQ0MsUUFBUSxLQUFLLEdBQUcsR0FBR3pHLFFBQVEsR0FBR29OLFNBQVMsQ0FBQyxDQUFDcE4sUUFBUSxFQUFFd0csSUFBSSxDQUFDQyxRQUFRLENBQUMsQ0FBQztFQUMxRTtFQUVELE9BQU95RSxVQUFVLENBQUMxRSxJQUFJLENBQUM7QUFDekI7QUFFQSxTQUFTNkcsaUJBQWlCQSxDQUFDaEIsVUFBa0IsRUFBRWlCLE9BQWU7RUFDNUQsSUFBSUMsV0FBVyxnQkFBR25LLEtBQUssQ0FBQzRCLFVBQVUsQ0FDaEMsQ0FBQytELEtBQUssRUFBRTVELEdBQUcsS0FBSTtJQUNiLElBQUk2RCxNQUFNLEdBQUdvRCxnQkFBZ0IsQ0FBQ0MsVUFBVSxFQUFFaUIsT0FBTyxDQUFDO0lBQ2xELG9CQUFPbEssS0FBQyxDQUFBL0QsYUFBQSxDQUFBNkosUUFBUSxFQUFBL0gsUUFBQSxLQUFLNEgsS0FBSztNQUFFNUQsR0FBRyxFQUFFQSxHQUFHO01BQUU2RCxNQUFNLEVBQUVBO0lBQU0sR0FBSTtFQUMxRCxDQUFDLENBQ0Y7RUFDRCxJQUFBckosS0FBYSxJQUVaO0VBQ0QsT0FBTzROLFdBQVc7QUFDcEI7QUFFQSxJQUFJQyxTQUFTLEdBQUcsQ0FBQztBQVFqQjtBQUVBOzs7QUFHRztTQUNhQyxVQUFVQSxDQUFBO0VBQUEsSUFBQUMsY0FBQTtFQUN4QixJQUFJO0lBQUU3QjtFQUFNLENBQUUsR0FBR3BCLG9CQUFvQixDQUFDSixjQUFjLENBQUNzRCxVQUFVLENBQUM7RUFFaEUsSUFBSVosS0FBSyxHQUFHM0osS0FBSyxDQUFDeUMsVUFBVSxDQUFDOEcsbUJBQVksQ0FBQztFQUMxQyxDQUFVSSxLQUFLLEdBQUFwTixNQUFBLEdBQWZpTCxDQUFTLEdBQVRBLGdCQUFTO0VBRVQsSUFBSTBDLE9BQU8sSUFBQUksY0FBQSxHQUFHWCxLQUFLLENBQUNGLE9BQU8sQ0FBQ0UsS0FBSyxDQUFDRixPQUFPLENBQUNyRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLHFCQUF2Q2tGLGNBQUEsQ0FBeUNYLEtBQUssQ0FBQ2EsRUFBRTtFQUMvRCxFQUNFTixPQUFPLElBQUksSUFBSSxJQUFBM04sTUFBQSxHQURqQmlMLENBQVMsR0FBVEEsZ0JBQVM7RUFLVCxJQUFJLENBQUN5QixVQUFVLENBQUMsR0FBR2pKLEtBQUssQ0FBQ1MsUUFBUSxDQUFDLE1BQU1nSyxNQUFNLENBQUMsRUFBRUwsU0FBUyxDQUFDLENBQUM7RUFDNUQsSUFBSSxDQUFDMUUsSUFBSSxDQUFDLEdBQUcxRixLQUFLLENBQUNTLFFBQVEsQ0FBQyxNQUFLO0lBQy9CLENBQVV5SixPQUFPLEdBQUEzTixNQUFBLEdBQWpCaUwsQ0FBUyxHQUFUQSxnQkFBUztJQUNULE9BQU95QyxpQkFBaUIsQ0FBQ2hCLFVBQVUsRUFBRWlCLE9BQU8sQ0FBQztFQUMvQyxDQUFDLENBQUM7RUFDRixJQUFJLENBQUNRLElBQUksQ0FBQyxHQUFHMUssS0FBSyxDQUFDUyxRQUFRLENBQUMsTUFBT3VDLElBQVksSUFBSTtJQUNqRCxDQUFVeUYsTUFBTSxHQUFBbE0sTUFBQSxHQUFoQmlMLENBQTJELEdBQTNEQSxnQkFBUztJQUNULENBQVUwQyxPQUFPLEdBQUEzTixNQUFBLEdBQWpCaUwsQ0FBNkQsR0FBN0RBLGdCQUFTO0lBQ1RpQixNQUFNLENBQUNXLEtBQUssQ0FBQ0gsVUFBVSxFQUFFaUIsT0FBTyxFQUFFbEgsSUFBSSxDQUFDO0VBQ3pDLENBQUMsQ0FBQztFQUNGLElBQUk0QyxNQUFNLEdBQUdvRCxnQkFBZ0IsQ0FBQ0MsVUFBVSxFQUFFaUIsT0FBTyxDQUFDO0VBRWxELElBQUlTLE9BQU8sR0FBR2xDLE1BQU0sQ0FBQ21DLFVBQVUsQ0FBUTNCLFVBQVUsQ0FBQztFQUVsRCxJQUFJNEIscUJBQXFCLEdBQUc3SyxLQUFLLENBQUNtSSxPQUFPLENBQ3ZDLE1BQUFwSyxRQUFBO0lBQ0UySCxJQUFJO0lBQ0pFLE1BQU07SUFDTjhFO0VBQUksR0FDREMsT0FBTyxDQUNWLEVBQ0YsQ0FBQ0EsT0FBTyxFQUFFakYsSUFBSSxFQUFFRSxNQUFNLEVBQUU4RSxJQUFJLENBQUMsQ0FDOUI7RUFFRDFLLEtBQUssQ0FBQzhLLFNBQVMsQ0FBQyxNQUFLO0lBQ25CO0lBQ0E7SUFDQTtJQUNBLE9BQU8sTUFBSztNQUNWLElBQUksQ0FBQ3JDLE1BQU0sRUFBRTtRQUNYc0MsT0FBTyxDQUFDQyxJQUFJLG9EQUFvRCxDQUFDO1FBQ2pFO01BQ0Q7TUFDRHZDLE1BQU0sQ0FBQ3dDLGFBQWEsQ0FBQ2hDLFVBQVUsQ0FBQztLQUNqQztFQUNILENBQUMsRUFBRSxDQUFDUixNQUFNLEVBQUVRLFVBQVUsQ0FBQyxDQUFDO0VBRXhCLE9BQU80QixxQkFBcUI7QUFDOUI7QUFFQTs7O0FBR0c7U0FDYUssV0FBV0EsQ0FBQTtFQUN6QixJQUFJdE0sS0FBSyxHQUFHNkksa0JBQWtCLENBQUNQLG1CQUFtQixDQUFDaUUsV0FBVyxDQUFDO0VBQy9ELE9BQU8sQ0FBQyxHQUFHdk0sS0FBSyxDQUFDd00sUUFBUSxDQUFDQyxNQUFNLEVBQUUsQ0FBQztBQUNyQztBQUVBLE1BQU1DLDhCQUE4QixHQUFHLCtCQUErQjtBQUN0RSxJQUFJQyxvQkFBb0IsR0FBMkIsRUFBRTtBQUVyRDs7QUFFRztBQUNILFNBQVN2RSxvQkFBb0JBLENBQUF3RSxNQUFBLEVBTXZCO0VBQUEsSUFOd0I7SUFDNUIxRSxNQUFNO0lBQ05DOzBCQUlFLEVBQUUsR0FBQXlFLE1BQUE7RUFDSixJQUFJO0lBQUUvQztFQUFNLENBQUUsR0FBR3BCLG9CQUFvQixDQUFDSixjQUFjLENBQUN3RSxvQkFBb0IsQ0FBQztFQUMxRSxJQUFJO0lBQUVDLHFCQUFxQjtJQUFFcko7RUFBb0IsSUFBR29GLGtCQUFrQixDQUNwRVAsbUJBQW1CLENBQUN1RSxvQkFBb0IsQ0FDekM7RUFDRCxJQUFJO0lBQUU3TztFQUFRLENBQUUsR0FBR29ELEtBQUssQ0FBQ3lDLFVBQVUsQ0FBQ0Msd0JBQWlCLENBQUM7RUFDdEQsSUFBSWhDLFFBQVEsR0FBR2dFLFdBQVcsRUFBRTtFQUM1QixJQUFJK0UsT0FBTyxHQUFHa0MsVUFBVSxFQUFFO0VBQzFCLElBQUkxRyxVQUFVLEdBQUcyRyxhQUFhLEVBQUU7RUFFaEM7RUFDQTVMLEtBQUssQ0FBQzhLLFNBQVMsQ0FBQyxNQUFLO0lBQ25CM00sTUFBTSxDQUFDRixPQUFPLENBQUM0TixpQkFBaUIsR0FBRyxRQUFRO0lBQzNDLE9BQU8sTUFBSztNQUNWMU4sTUFBTSxDQUFDRixPQUFPLENBQUM0TixpQkFBaUIsR0FBRyxNQUFNO0tBQzFDO0dBQ0YsRUFBRSxFQUFFLENBQUM7RUFFTjtFQUNBQyxXQUFXLENBQ1Q5TCxLQUFLLENBQUNhLFdBQVcsQ0FBQyxNQUFLO0lBQ3JCLElBQUlvRSxVQUFVLENBQUNyRyxLQUFLLEtBQUssTUFBTSxFQUFFO01BQy9CLElBQUk3RCxHQUFHLEdBQUcsQ0FBQytMLE1BQU0sR0FBR0EsTUFBTSxDQUFDcEcsUUFBUSxFQUFFK0ksT0FBTyxDQUFDLEdBQUcsSUFBSSxLQUFLL0ksUUFBUSxDQUFDM0YsR0FBRztNQUNyRXdRLG9CQUFvQixDQUFDeFEsR0FBRyxDQUFDLEdBQUdvRCxNQUFNLENBQUM0TixPQUFPO0lBQzNDO0lBQ0RDLGNBQWMsQ0FBQ0MsT0FBTyxDQUNwQmxGLFVBQVUsSUFBSXVFLDhCQUE4QixFQUM1Q1ksSUFBSSxDQUFDQyxTQUFTLENBQUNaLG9CQUFvQixDQUFDLENBQ3JDO0lBQ0RwTixNQUFNLENBQUNGLE9BQU8sQ0FBQzROLGlCQUFpQixHQUFHLE1BQU07RUFDM0MsQ0FBQyxFQUFFLENBQUM5RSxVQUFVLEVBQUVELE1BQU0sRUFBRTdCLFVBQVUsQ0FBQ3JHLEtBQUssRUFBRThCLFFBQVEsRUFBRStJLE9BQU8sQ0FBQyxDQUFDLENBQzlEO0VBRUQ7RUFDQSxJQUFJLE9BQU96TixRQUFRLEtBQUssV0FBVyxFQUFFO0lBQ25DO0lBQ0FnRSxLQUFLLENBQUNlLGVBQWUsQ0FBQyxNQUFLO01BQ3pCLElBQUk7UUFDRixJQUFJcUwsZ0JBQWdCLEdBQUdKLGNBQWMsQ0FBQ0ssT0FBTyxDQUMzQ3RGLFVBQVUsSUFBSXVFLDhCQUE4QixDQUM3QztRQUNELElBQUljLGdCQUFnQixFQUFFO1VBQ3BCYixvQkFBb0IsR0FBR1csSUFBSSxDQUFDSSxLQUFLLENBQUNGLGdCQUFnQixDQUFDO1FBQ3BEO09BQ0YsQ0FBQyxPQUFPbFEsQ0FBQyxFQUFFO1FBQ1Y7TUFBQTtJQUVKLENBQUMsRUFBRSxDQUFDNkssVUFBVSxDQUFDLENBQUM7SUFFaEI7SUFDQTtJQUNBL0csS0FBSyxDQUFDZSxlQUFlLENBQUMsTUFBSztNQUN6QixJQUFJd0wscUJBQXFCLEdBQ3ZCekYsTUFBTSxJQUFJbEssUUFBUSxLQUFLLEdBQUcsR0FDdEIsQ0FBQzhELFFBQVEsRUFBRStJLE9BQU8sS0FDaEIzQyxNQUFNO01BQUE7TUFDSi9JLFFBQUEsS0FFSzJDLFFBQVE7UUFDWDJDLFFBQVEsRUFDTmxHLGFBQWEsQ0FBQ3VELFFBQVEsQ0FBQzJDLFFBQVEsRUFBRXpHLFFBQVEsQ0FBQyxJQUMxQzhELFFBQVEsQ0FBQzJDO09BRWIsR0FBQW9HLE9BQU8sQ0FDUixHQUNIM0MsTUFBTTtNQUNaLElBQUkwRix3QkFBd0IsR0FBRy9ELE1BQU0sSUFBTixnQkFBQUEsTUFBTSxDQUFFZ0UsdUJBQXVCLENBQzVEbEIsb0JBQW9CLEVBQ3BCLE1BQU1wTixNQUFNLENBQUM0TixPQUFPLEVBQ3BCUSxxQkFBcUIsQ0FDdEI7TUFDRCxPQUFPLE1BQU1DLHdCQUF3QixJQUFJQSx3QkFBd0IsRUFBRTtLQUNwRSxFQUFFLENBQUMvRCxNQUFNLEVBQUU3TCxRQUFRLEVBQUVrSyxNQUFNLENBQUMsQ0FBQztJQUU5QjtJQUNBO0lBQ0E5RyxLQUFLLENBQUNlLGVBQWUsQ0FBQyxNQUFLO01BQ3pCO01BQ0EsSUFBSTJLLHFCQUFxQixLQUFLLEtBQUssRUFBRTtRQUNuQztNQUNEO01BRUQ7TUFDQSxJQUFJLE9BQU9BLHFCQUFxQixLQUFLLFFBQVEsRUFBRTtRQUM3Q3ZOLE1BQU0sQ0FBQ3VPLFFBQVEsQ0FBQyxDQUFDLEVBQUVoQixxQkFBcUIsQ0FBQztRQUN6QztNQUNEO01BRUQ7TUFDQSxJQUFJaEwsUUFBUSxDQUFDOEMsSUFBSSxFQUFFO1FBQ2pCLElBQUltSixFQUFFLEdBQUczUSxRQUFRLENBQUM0USxjQUFjLENBQzlCQyxrQkFBa0IsQ0FBQ25NLFFBQVEsQ0FBQzhDLElBQUksQ0FBQ2tHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUMzQztRQUNELElBQUlpRCxFQUFFLEVBQUU7VUFDTkEsRUFBRSxDQUFDRyxjQUFjLEVBQUU7VUFDbkI7UUFDRDtNQUNGO01BRUQ7TUFDQSxJQUFJekssa0JBQWtCLEtBQUssSUFBSSxFQUFFO1FBQy9CO01BQ0Q7TUFFRDtNQUNBbEUsTUFBTSxDQUFDdU8sUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDdEIsRUFBRSxDQUFDaE0sUUFBUSxFQUFFZ0wscUJBQXFCLEVBQUVySixrQkFBa0IsQ0FBQyxDQUFDO0VBQzFEO0FBQ0g7QUFJQTs7Ozs7OztBQU9HO0FBQ2EsU0FBQTBLLGVBQWVBLENBQzdCQyxRQUEyQyxFQUMzQ25FLE9BQStCO0VBRS9CLElBQUk7SUFBRW9FO0VBQU8sQ0FBRSxHQUFHcEUsT0FBTyxJQUFJLEVBQUU7RUFDL0I3SSxLQUFLLENBQUM4SyxTQUFTLENBQUMsTUFBSztJQUNuQixJQUFJbE4sSUFBSSxHQUFHcVAsT0FBTyxJQUFJLElBQUksR0FBRztNQUFFQTtJQUFTLElBQUd4UCxTQUFTO0lBQ3BEVSxNQUFNLENBQUMrTyxnQkFBZ0IsQ0FBQyxjQUFjLEVBQUVGLFFBQVEsRUFBRXBQLElBQUksQ0FBQztJQUN2RCxPQUFPLE1BQUs7TUFDVk8sTUFBTSxDQUFDZ1AsbUJBQW1CLENBQUMsY0FBYyxFQUFFSCxRQUFRLEVBQUVwUCxJQUFJLENBQUM7S0FDM0Q7RUFDSCxDQUFDLEVBQUUsQ0FBQ29QLFFBQVEsRUFBRUMsT0FBTyxDQUFDLENBQUM7QUFDekI7QUFFQTs7Ozs7OztBQU9HO0FBQ0gsU0FBU25CLFdBQVdBLENBQ2xCa0IsUUFBNkMsRUFDN0NuRSxPQUErQjtFQUUvQixJQUFJO0lBQUVvRTtFQUFPLENBQUUsR0FBR3BFLE9BQU8sSUFBSSxFQUFFO0VBQy9CN0ksS0FBSyxDQUFDOEssU0FBUyxDQUFDLE1BQUs7SUFDbkIsSUFBSWxOLElBQUksR0FBR3FQLE9BQU8sSUFBSSxJQUFJLEdBQUc7TUFBRUE7SUFBUyxJQUFHeFAsU0FBUztJQUNwRFUsTUFBTSxDQUFDK08sZ0JBQWdCLENBQUMsVUFBVSxFQUFFRixRQUFRLEVBQUVwUCxJQUFJLENBQUM7SUFDbkQsT0FBTyxNQUFLO01BQ1ZPLE1BQU0sQ0FBQ2dQLG1CQUFtQixDQUFDLFVBQVUsRUFBRUgsUUFBUSxFQUFFcFAsSUFBSSxDQUFDO0tBQ3ZEO0VBQ0gsQ0FBQyxFQUFFLENBQUNvUCxRQUFRLEVBQUVDLE9BQU8sQ0FBQyxDQUFDO0FBQ3pCO0FBRUE7Ozs7Ozs7QUFPRztBQUNILFNBQVNHLFNBQVNBLENBQUFDLEtBQUEsRUFBc0Q7RUFBQSxJQUFyRDtJQUFFQyxJQUFJO0lBQUUxTjtFQUE2QyxJQUFBeU4sS0FBQTtFQUN0RSxJQUFJRSxPQUFPLEdBQUdDLG1CQUFVLENBQUNGLElBQUksQ0FBQztFQUU5QnROLEtBQUssQ0FBQzhLLFNBQVMsQ0FBQyxNQUFLO0lBQ25CLElBQUl5QyxPQUFPLENBQUMzTyxLQUFLLEtBQUssU0FBUyxFQUFFO01BQy9CLElBQUk2TyxPQUFPLEdBQUd0UCxNQUFNLENBQUN1UCxPQUFPLENBQUM5TixPQUFPLENBQUM7TUFDckMsSUFBSTZOLE9BQU8sRUFBRTtRQUNYO1FBQ0E7UUFDQTtRQUNBRSxVQUFVLENBQUNKLE9BQU8sQ0FBQ0UsT0FBTyxFQUFFLENBQUMsQ0FBQztNQUMvQixPQUFNO1FBQ0xGLE9BQU8sQ0FBQ0ssS0FBSyxFQUFFO01BQ2hCO0lBQ0Y7RUFDSCxDQUFDLEVBQUUsQ0FBQ0wsT0FBTyxFQUFFM04sT0FBTyxDQUFDLENBQUM7RUFFdEJJLEtBQUssQ0FBQzhLLFNBQVMsQ0FBQyxNQUFLO0lBQ25CLElBQUl5QyxPQUFPLENBQUMzTyxLQUFLLEtBQUssU0FBUyxJQUFJLENBQUMwTyxJQUFJLEVBQUU7TUFDeENDLE9BQU8sQ0FBQ0ssS0FBSyxFQUFFO0lBQ2hCO0VBQ0gsQ0FBQyxFQUFFLENBQUNMLE9BQU8sRUFBRUQsSUFBSSxDQUFDLENBQUM7QUFDckI7QUFJQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4uL2RvbS50cz82NzFhIiwid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4uL2luZGV4LnRzeD80NWViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgRm9ybUVuY1R5cGUsXG4gIEhUTUxGb3JtTWV0aG9kLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7IHN0cmlwQmFzZW5hbWUsIFVOU0FGRV93YXJuaW5nIGFzIHdhcm5pbmcgfSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRNZXRob2Q6IEhUTUxGb3JtTWV0aG9kID0gXCJnZXRcIjtcbmNvbnN0IGRlZmF1bHRFbmNUeXBlOiBGb3JtRW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxFbGVtZW50IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBIVE1MQnV0dG9uRWxlbWVudCB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTEZvcm1FbGVtZW50IHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxJbnB1dEVsZW1lbnQge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cblxudHlwZSBMaW1pdGVkTW91c2VFdmVudCA9IFBpY2s8XG4gIE1vdXNlRXZlbnQsXG4gIFwiYnV0dG9uXCIgfCBcIm1ldGFLZXlcIiB8IFwiYWx0S2V5XCIgfCBcImN0cmxLZXlcIiB8IFwic2hpZnRLZXlcIlxuPjtcblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBMaW1pdGVkTW91c2VFdmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKFxuICBldmVudDogTGltaXRlZE1vdXNlRXZlbnQsXG4gIHRhcmdldD86IHN0cmluZ1xuKSB7XG4gIHJldHVybiAoXG4gICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICk7XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtS2V5VmFsdWVQYWlyID0gW3N0cmluZywgc3RyaW5nXTtcblxuZXhwb3J0IHR5cGUgVVJMU2VhcmNoUGFyYW1zSW5pdCA9XG4gIHwgc3RyaW5nXG4gIHwgUGFyYW1LZXlWYWx1ZVBhaXJbXVxuICB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPlxuICB8IFVSTFNlYXJjaFBhcmFtcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICBpbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0ID0gXCJcIlxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgdHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBBcnJheS5pc0FycmF5KGluaXQpIHx8XG4gICAgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgPyBpbml0XG4gICAgICA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgICAgIHJldHVybiBtZW1vLmNvbmNhdChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCh2KSA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgICAgICk7XG4gICAgICAgIH0sIFtdIGFzIFBhcmFtS2V5VmFsdWVQYWlyW10pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgbG9jYXRpb25TZWFyY2g6IHN0cmluZyxcbiAgZGVmYXVsdFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zIHwgbnVsbFxuKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuXG4gIGlmIChkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gVXNlIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goLi4uKWAgaGVyZSBpbnN0ZWFkIG9mIGl0ZXJhdGluZyBvZlxuICAgIC8vIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmtleXMoKWAgdG8gd29yay1hcm91bmQgYSBidWcgaW4gRmlyZWZveCByZWxhdGVkIHRvXG4gICAgLy8gd2ViIGV4dGVuc2lvbnMuIFJlbGV2YW50IEJ1Z3ppbGxhIHRpY2tldHM6XG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQxNDYwMlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjM5ODRcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cblxuLy8gVGhhbmtzIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdHlwZS1mZXN0IVxudHlwZSBKc29uT2JqZWN0ID0geyBbS2V5IGluIHN0cmluZ106IEpzb25WYWx1ZSB9ICYge1xuICBbS2V5IGluIHN0cmluZ10/OiBKc29uVmFsdWUgfCB1bmRlZmluZWQ7XG59O1xudHlwZSBKc29uQXJyYXkgPSBKc29uVmFsdWVbXSB8IHJlYWRvbmx5IEpzb25WYWx1ZVtdO1xudHlwZSBKc29uUHJpbWl0aXZlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGw7XG50eXBlIEpzb25WYWx1ZSA9IEpzb25QcmltaXRpdmUgfCBKc29uT2JqZWN0IHwgSnNvbkFycmF5O1xuXG5leHBvcnQgdHlwZSBTdWJtaXRUYXJnZXQgPVxuICB8IEhUTUxGb3JtRWxlbWVudFxuICB8IEhUTUxCdXR0b25FbGVtZW50XG4gIHwgSFRNTElucHV0RWxlbWVudFxuICB8IEZvcm1EYXRhXG4gIHwgVVJMU2VhcmNoUGFyYW1zXG4gIHwgSnNvblZhbHVlXG4gIHwgbnVsbDtcblxuLy8gT25lLXRpbWUgY2hlY2sgZm9yIHN1Ym1pdHRlciBzdXBwb3J0XG5sZXQgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXI6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcblxuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcbiAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGb3JtRGF0YShcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgICAwXG4gICAgICApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBIVFRQIG1ldGhvZCB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybS4gT3ZlcnJpZGVzIGA8Zm9ybSBtZXRob2Q+YC5cbiAgICogRGVmYXVsdHMgdG8gXCJHRVRcIi5cbiAgICovXG4gIG1ldGhvZD86IEhUTUxGb3JtTWV0aG9kO1xuXG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIFVSTCBwYXRoIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIGFjdGlvbj5gLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCByb3V0ZS5cbiAgICovXG4gIGFjdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIGVuY1R5cGU+YC5cbiAgICogRGVmYXVsdHMgdG8gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIi5cbiAgICovXG4gIGVuY1R5cGU/OiBGb3JtRW5jVHlwZTtcblxuICAvKipcbiAgICogU2V0IGB0cnVlYCB0byByZXBsYWNlIHRoZSBjdXJyZW50IGVudHJ5IGluIHRoZSBicm93c2VyJ3MgaGlzdG9yeSBzdGFja1xuICAgKiBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZSAoaS5lLiBzdGF5IG9uIFwidGhlIHNhbWUgcGFnZVwiKS4gRGVmYXVsdHNcbiAgICogdG8gYGZhbHNlYC5cbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTdGF0ZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBoaXN0b3J5IHN0YWNrIGVudHJ5IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICovXG4gIHN0YXRlPzogYW55O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZvcm0gYWN0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSByb3V0ZSBoaWVyYXJjaHkgb3JcbiAgICogdGhlIHBhdGhuYW1lLiAgVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gb3B0IG91dCBvZiBuYXZpZ2F0aW5nIHRoZSByb3V0ZVxuICAgKiBoaWVyYXJjaHkgYW5kIHdhbnQgdG8gaW5zdGVhZCByb3V0ZSBiYXNlZCBvbiAvLWRlbGltaXRlZCBVUkwgc2VnbWVudHNcbiAgICovXG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcblxuICAvKipcbiAgICogSW4gYnJvd3Nlci1iYXNlZCBlbnZpcm9ubWVudHMsIHByZXZlbnQgcmVzZXR0aW5nIHNjcm9sbCBhZnRlciB0aGlzXG4gICAqIG5hdmlnYXRpb24gd2hlbiB1c2luZyB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgICovXG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG59XG5cbmNvbnN0IHN1cHBvcnRlZEZvcm1FbmNUeXBlczogU2V0PEZvcm1FbmNUeXBlPiA9IG5ldyBTZXQoW1xuICBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcbiAgXCJ0ZXh0L3BsYWluXCIsXG5dKTtcblxuZnVuY3Rpb24gZ2V0Rm9ybUVuY1R5cGUoZW5jVHlwZTogc3RyaW5nIHwgbnVsbCkge1xuICBpZiAoZW5jVHlwZSAhPSBudWxsICYmICFzdXBwb3J0ZWRGb3JtRW5jVHlwZXMuaGFzKGVuY1R5cGUgYXMgRm9ybUVuY1R5cGUpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFwiJHtlbmNUeXBlfVwiIGlzIG5vdCBhIHZhbGlkIFxcYGVuY1R5cGVcXGAgZm9yIFxcYDxGb3JtPlxcYC9cXGA8ZmV0Y2hlci5Gb3JtPlxcYCBgICtcbiAgICAgICAgYGFuZCB3aWxsIGRlZmF1bHQgdG8gXCIke2RlZmF1bHRFbmNUeXBlfVwiYFxuICAgICk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5jVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyhcbiAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG4gIGJhc2VuYW1lOiBzdHJpbmdcbik6IHtcbiAgYWN0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBtZXRob2Q6IHN0cmluZztcbiAgZW5jVHlwZTogc3RyaW5nO1xuICBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gIGJvZHk6IGFueTtcbn0ge1xuICBsZXQgbWV0aG9kOiBzdHJpbmc7XG4gIGxldCBhY3Rpb246IHN0cmluZyB8IG51bGw7XG4gIGxldCBlbmNUeXBlOiBzdHJpbmc7XG4gIGxldCBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gIGxldCBib2R5OiBhbnk7XG5cbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgLy8gcmUtcHJlZml4IGluIHRoZSByb3V0ZXJcbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoXG4gICAgaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHxcbiAgICAoaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJlxuICAgICAgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKVxuICApIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuXG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVwic3VibWl0XCI+IHdpdGhvdXQgYSA8Zm9ybT5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcblxuICAgIG1ldGhvZCA9XG4gICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHxcbiAgICAgIGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9XG4gICAgICBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikpIHx8XG4gICAgICBnZXRGb3JtRW5jVHlwZShmb3JtLmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8XG4gICAgICBkZWZhdWx0RW5jVHlwZTtcblxuICAgIC8vIEJ1aWxkIGEgRm9ybURhdGEgb2JqZWN0IHBvcHVsYXRlZCBmcm9tIGEgZm9ybSBhbmQgc3VibWl0dGVyXG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSwgdGFyZ2V0KTtcblxuICAgIC8vIElmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGBGb3JtRGF0YShlbCwgc3VibWl0dGVyKWAgZm9ybWF0LFxuICAgIC8vIHRoZW4gdGFjayBvbiB0aGUgc3VibWl0dGVyIHZhbHVlIGF0IHRoZSBlbmQuICBUaGlzIGlzIGEgbGlnaHR3ZWlnaHRcbiAgICAvLyBzb2x1dGlvbiB0aGF0IGlzIG5vdCAxMDAlIHNwZWMgY29tcGxpYW50LiAgRm9yIGNvbXBsZXRlIHN1cHBvcnQgaW4gb2xkZXJcbiAgICAvLyBicm93c2VycywgY29uc2lkZXIgdXNpbmcgdGhlIGBmb3JtZGF0YS1zdWJtaXR0ZXItcG9seWZpbGxgIHBhY2thZ2VcbiAgICBpZiAoIWlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgbGV0IHsgbmFtZSwgdHlwZSwgdmFsdWUgfSA9IHRhcmdldDtcbiAgICAgIGlmICh0eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IG5hbWUgPyBgJHtuYW1lfS5gIDogXCJcIjtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke3ByZWZpeH14YCwgXCIwXCIpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXlgLCBcIjBcIik7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBgICtcbiAgICAgICAgYDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBudWxsO1xuICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICBib2R5ID0gdGFyZ2V0O1xuICB9XG5cbiAgLy8gU2VuZCBib2R5IGZvciA8Rm9ybSBlbmNUeXBlPVwidGV4dC9wbGFpblwiIHNvIHdlIGVuY29kZSBpdCBpbnRvIHRleHRcbiAgaWYgKGZvcm1EYXRhICYmIGVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgYm9keSA9IGZvcm1EYXRhO1xuICAgIGZvcm1EYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHsgYWN0aW9uLCBtZXRob2Q6IG1ldGhvZC50b0xvd2VyQ2FzZSgpLCBlbmNUeXBlLCBmb3JtRGF0YSwgYm9keSB9O1xufVxuIiwiLyoqXG4gKiBOT1RFOiBJZiB5b3UgcmVmYWN0b3IgdGhpcyB0byBzcGxpdCB1cCB0aGUgbW9kdWxlcyBpbnRvIHNlcGFyYXRlIGZpbGVzLFxuICogeW91J2xsIG5lZWQgdG8gdXBkYXRlIHRoZSByb2xsdXAgY29uZmlnIGZvciByZWFjdC1yb3V0ZXItZG9tLXY1LWNvbXBhdC5cbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEZ1dHVyZUNvbmZpZyxcbiAgTG9jYXRpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGlvblR5cGUsXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlT2JqZWN0LFxuICBUbyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IHtcbiAgUm91dGVyLFxuICBjcmVhdGVQYXRoLFxuICB1c2VIcmVmLFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdW5zdGFibGVfdXNlQmxvY2tlciBhcyB1c2VCbG9ja2VyLFxuICBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQgYXMgRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IGFzIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCBhcyBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX1JvdXRlQ29udGV4dCBhcyBSb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMgYXMgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfdXNlUm91dGVJZCBhcyB1c2VSb3V0ZUlkLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEJyb3dzZXJIaXN0b3J5LFxuICBGZXRjaGVyLFxuICBGb3JtRW5jVHlwZSxcbiAgRm9ybU1ldGhvZCxcbiAgRnV0dXJlQ29uZmlnIGFzIFJvdXRlckZ1dHVyZUNvbmZpZyxcbiAgR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbixcbiAgSGFzaEhpc3RvcnksXG4gIEhpc3RvcnksXG4gIEhUTUxGb3JtTWV0aG9kLFxuICBIeWRyYXRpb25TdGF0ZSxcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxuICBWN19Gb3JtTWV0aG9kLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZVJvdXRlcixcbiAgY3JlYXRlQnJvd3Nlckhpc3RvcnksXG4gIGNyZWF0ZUhhc2hIaXN0b3J5LFxuICBqb2luUGF0aHMsXG4gIHN0cmlwQmFzZW5hbWUsXG4gIFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCBhcyBFcnJvclJlc3BvbnNlSW1wbCxcbiAgVU5TQUZFX2ludmFyaWFudCBhcyBpbnZhcmlhbnQsXG4gIFVOU0FGRV93YXJuaW5nIGFzIHdhcm5pbmcsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIFN1Ym1pdE9wdGlvbnMsXG4gIFBhcmFtS2V5VmFsdWVQYWlyLFxuICBVUkxTZWFyY2hQYXJhbXNJbml0LFxuICBTdWJtaXRUYXJnZXQsXG59IGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBkZWZhdWx0TWV0aG9kLFxuICBnZXRGb3JtU3VibWlzc2lvbkluZm8sXG4gIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uLFxuICBzaG91bGRQcm9jZXNzTGlua0NsaWNrLFxufSBmcm9tIFwiLi9kb21cIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSZS1leHBvcnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSB7XG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uLFxuICBQYXJhbUtleVZhbHVlUGFpcixcbiAgU3VibWl0T3B0aW9ucyxcbiAgVVJMU2VhcmNoUGFyYW1zSW5pdCxcbiAgVjdfRm9ybU1ldGhvZCxcbn07XG5leHBvcnQgeyBjcmVhdGVTZWFyY2hQYXJhbXMgfTtcblxuLy8gTm90ZTogS2VlcCBpbiBzeW5jIHdpdGggcmVhY3Qtcm91dGVyIGV4cG9ydHMhXG5leHBvcnQgdHlwZSB7XG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBBY3Rpb25GdW5jdGlvbkFyZ3MsXG4gIEF3YWl0UHJvcHMsXG4gIHVuc3RhYmxlX0Jsb2NrZXIsXG4gIHVuc3RhYmxlX0Jsb2NrZXJGdW5jdGlvbixcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgRXJyb3JSZXNwb25zZSxcbiAgRmV0Y2hlcixcbiAgSGFzaCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBKc29uRnVuY3Rpb24sXG4gIExhenlSb3V0ZUZ1bmN0aW9uLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdGlvbixcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhuYW1lLFxuICBQYXRoUGF0dGVybixcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG4gIFNlYXJjaCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzLFxuICBUbyxcbiAgVUlNYXRjaCxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuZXhwb3J0IHtcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVNZW1vcnlSb3V0ZXIsXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLFxuICBkZWZlcixcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGdlbmVyYXRlUGF0aCxcbiAganNvbixcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgcmVzb2x2ZVBhdGgsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVuc3RhYmxlX3VzZUJsb2NrZXIsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlcyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUm91dGVDb250ZXh0LFxuICBVTlNBRkVfdXNlUm91dGVJZCxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuLy8jZW5kcmVnaW9uXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgdmFyIF9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTogSHlkcmF0aW9uU3RhdGUgfCB1bmRlZmluZWQ7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gUm91dGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuaW50ZXJmYWNlIERPTVJvdXRlck9wdHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgZnV0dXJlPzogUGFydGlhbDxPbWl0PFJvdXRlckZ1dHVyZUNvbmZpZywgXCJ2N19wcmVwZW5kQmFzZW5hbWVcIj4+O1xuICBoeWRyYXRpb25EYXRhPzogSHlkcmF0aW9uU3RhdGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IERPTVJvdXRlck9wdHNcbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZToge1xuICAgICAgLi4ub3B0cz8uZnV0dXJlLFxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlLFxuICAgIH0sXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IERPTVJvdXRlck9wdHNcbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZToge1xuICAgICAgLi4ub3B0cz8uZnV0dXJlLFxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlLFxuICAgIH0sXG4gICAgaGlzdG9yeTogY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIeWRyYXRpb25EYXRhKCk6IEh5ZHJhdGlvblN0YXRlIHwgdW5kZWZpbmVkIHtcbiAgbGV0IHN0YXRlID0gd2luZG93Py5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhcbiAgZXJyb3JzOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdXG4pOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIC8vIEhleSB5b3UhICBJZiB5b3UgY2hhbmdlIHRoaXMsIHBsZWFzZSBjaGFuZ2UgdGhlIGNvcnJlc3BvbmRpbmcgbG9naWMgaW5cbiAgICAvLyBzZXJpYWxpemVFcnJvcnMgaW4gcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIudHN4IDopXG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbnN0cnVjdCB0aGUgcmlnaHQgdHlwZSBvZiBFcnJvciAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpXG4gICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBuby1vcCAtIGZhbGwgdGhyb3VnaCBhbmQgY3JlYXRlIGEgbm9ybWFsIEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBDb21wb25lbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAgV2VicGFjayArIFJlYWN0IDE3IGZhaWxzIHRvIGNvbXBpbGUgb24gYW55IG9mIHRoZSBmb2xsb3dpbmcgYmVjYXVzZSB3ZWJwYWNrXG4gIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcbiAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdFtcInN0YXJ0VHJhbnNpdGlvblwiXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG4gICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIGluIFJlYWN0IDE4IHdoZXJlIG1pbmlmaWNhdGlvbi9vYmZ1c2NhdGlvbiBlbmRzIHVwIHJlbW92aW5nIHRoZSBjYWxsIG9mXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiBlbnRpcmVseSBmcm9tIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSB0ZXJuYXJ5LiAgR3JhYmJpbmdcbiAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxuXG4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlYWN0LXJvdXRlci9pc3N1ZXMvMTA1NzlcbiovXG5jb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbmNvbnN0IHN0YXJ0VHJhbnNpdGlvbkltcGwgPSBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXTtcblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGZ1dHVyZT86IEZ1dHVyZUNvbmZpZztcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCcm93c2VyUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBmdXR1cmUsXG4gIHdpbmRvdyxcbn06IEJyb3dzZXJSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxCcm93c2VySGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3csIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IHsgYWN0aW9uOiBOYXZpZ2F0aW9uVHlwZTsgbG9jYXRpb246IExvY2F0aW9uIH0pID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsXG4gICAgICAgID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKVxuICAgICAgICA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaFJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBmdXR1cmU/OiBGdXR1cmVDb25maWc7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gSGFzaFJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgZnV0dXJlLFxuICB3aW5kb3csXG59OiBIYXNoUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8SGFzaEhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHsgd2luZG93LCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuICBsZXQgeyB2N19zdGFydFRyYW5zaXRpb24gfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlOiB7IGFjdGlvbjogTmF2aWdhdGlvblR5cGU7IGxvY2F0aW9uOiBMb2NhdGlvbiB9KSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbFxuICAgICAgICA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSlcbiAgICAgICAgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXVxuICApO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZnV0dXJlPzogRnV0dXJlQ29uZmlnO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBmdXR1cmUsXG4gIGhpc3RvcnksXG59OiBIaXN0b3J5Um91dGVyUHJvcHMpIHtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcbiAgbGV0IHsgdjdfc3RhcnRUcmFuc2l0aW9uIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZTogeyBhY3Rpb246IE5hdmlnYXRpb25UeXBlOyBsb2NhdGlvbjogTG9jYXRpb24gfSkgPT4ge1xuICAgICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGxcbiAgICAgICAgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpXG4gICAgICAgIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl1cbiAgKTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xufVxuXG5leHBvcnQgeyBIaXN0b3J5Um91dGVyIGFzIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIgfTtcblxuZXhwb3J0IGludGVyZmFjZSBMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PFJlYWN0LkFuY2hvckhUTUxBdHRyaWJ1dGVzPEhUTUxBbmNob3JFbGVtZW50PiwgXCJocmVmXCI+IHtcbiAgcmVsb2FkRG9jdW1lbnQ/OiBib29sZWFuO1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbiAgdG86IFRvO1xufVxuXG5jb25zdCBpc0Jyb3dzZXIgPVxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5leHBvcnQgY29uc3QgTGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIExpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIExpbmtXaXRoUmVmKFxuICAgIHtcbiAgICAgIG9uQ2xpY2ssXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuXG4gICAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgYWJzb2x1dGUgVVJMc1xuICAgIGxldCBhYnNvbHV0ZUhyZWY7XG4gICAgbGV0IGlzRXh0ZXJuYWwgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodG8pKSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGFic29sdXRlIGhyZWYgc2VydmVyLSBhbmQgY2xpZW50LXNpZGVcbiAgICAgIGFic29sdXRlSHJlZiA9IHRvO1xuXG4gICAgICAvLyBPbmx5IGNoZWNrIGZvciBleHRlcm5hbCBvcmlnaW5zIGNsaWVudC1zaWRlXG4gICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpXG4gICAgICAgICAgICA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIHRvKVxuICAgICAgICAgICAgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgICBsZXQgcGF0aCA9IHN0cmlwQmFzZW5hbWUodGFyZ2V0VXJsLnBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0VXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgcGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTdHJpcCB0aGUgcHJvdG9jb2wvb3JpZ2luL2Jhc2VuYW1lIGZvciBzYW1lLW9yaWdpbiBhYnNvbHV0ZSBVUkxzXG4gICAgICAgICAgICB0byA9IHBhdGggKyB0YXJnZXRVcmwuc2VhcmNoICsgdGFyZ2V0VXJsLmhhc2g7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFdlIGNhbid0IGRvIGV4dGVybmFsIFVSTCBkZXRlY3Rpb24gd2l0aG91dCBhIHZhbGlkIFVSTFxuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGA8TGluayB0bz1cIiR7dG99XCI+IGNvbnRhaW5zIGFuIGludmFsaWQgVVJMIHdoaWNoIHdpbGwgcHJvYmFibHkgYnJlYWsgYCArXG4gICAgICAgICAgICAgIGB3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW5kZXJlZCBpbnRvIDxhIGhyZWY+IGZvciByZWxhdGl2ZSBVUkxzXG4gICAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0pO1xuXG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKFxuICAgICAgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEFuY2hvckVsZW1lbnQsIE1vdXNlRXZlbnQ+XG4gICAgKSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgICAgPGFcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIGhyZWY9e2Fic29sdXRlSHJlZiB8fCBocmVmfVxuICAgICAgICBvbkNsaWNrPXtpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgdGFyZ2V0PXt0YXJnZXR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIExpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZMaW5rUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PExpbmtQcm9wcywgXCJjbGFzc05hbWVcIiB8IFwic3R5bGVcIiB8IFwiY2hpbGRyZW5cIj4ge1xuICBjaGlsZHJlbj86XG4gICAgfCBSZWFjdC5SZWFjdE5vZGVcbiAgICB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW47IGlzUGVuZGluZzogYm9vbGVhbiB9KSA9PiBSZWFjdC5SZWFjdE5vZGUpO1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2xhc3NOYW1lPzpcbiAgICB8IHN0cmluZ1xuICAgIHwgKChwcm9wczoge1xuICAgICAgICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgICAgICAgaXNQZW5kaW5nOiBib29sZWFuO1xuICAgICAgfSkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkKTtcbiAgZW5kPzogYm9vbGVhbjtcbiAgc3R5bGU/OlxuICAgIHwgUmVhY3QuQ1NTUHJvcGVydGllc1xuICAgIHwgKChwcm9wczoge1xuICAgICAgICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgICAgICAgaXNQZW5kaW5nOiBib29sZWFuO1xuICAgICAgfSkgPT4gUmVhY3QuQ1NTUHJvcGVydGllcyB8IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBOYXZMaW5rID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQW5jaG9yRWxlbWVudCwgTmF2TGlua1Byb3BzPihcbiAgZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoXG4gICAge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgICAgZW5kID0gZmFsc2UsXG4gICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgdG8sXG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZSB9KTtcbiAgICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgbGV0IHsgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcblxuICAgIGxldCB0b1BhdGhuYW1lID0gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uXG4gICAgICA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZVxuICAgICAgOiBwYXRoLnBhdGhuYW1lO1xuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID1cbiAgICAgIHJvdXRlclN0YXRlICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24gJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvblxuICAgICAgICA/IHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgOiBudWxsO1xuXG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZVxuICAgICAgICA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgOiBudWxsO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNBY3RpdmUgPVxuICAgICAgbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fFxuICAgICAgKCFlbmQgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuXG4gICAgbGV0IGlzUGVuZGluZyA9XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSAhPSBudWxsICYmXG4gICAgICAobmV4dExvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHxcbiAgICAgICAgKCFlbmQgJiZcbiAgICAgICAgICBuZXh0TG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmXG4gICAgICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpKTtcblxuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGNsYXNzTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHsgaXNBY3RpdmUsIGlzUGVuZGluZyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgICBjbGFzc05hbWUgPSBbXG4gICAgICAgIGNsYXNzTmFtZVByb3AsXG4gICAgICAgIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsXG4gICAgICAgIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbCxcbiAgICAgIF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZVByb3AgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHN0eWxlUHJvcCh7IGlzQWN0aXZlLCBpc1BlbmRpbmcgfSlcbiAgICAgICAgOiBzdHlsZVByb3A7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPExpbmtcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIGFyaWEtY3VycmVudD17YXJpYUN1cnJlbnR9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICB0bz17dG99XG4gICAgICA+XG4gICAgICAgIHt0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gY2hpbGRyZW4oeyBpc0FjdGl2ZSwgaXNQZW5kaW5nIH0pXG4gICAgICAgICAgOiBjaGlsZHJlbn1cbiAgICAgIDwvTGluaz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hlckZvcm1Qcm9wc1xuICBleHRlbmRzIFJlYWN0LkZvcm1IVE1MQXR0cmlidXRlczxIVE1MRm9ybUVsZW1lbnQ+IHtcbiAgLyoqXG4gICAqIFRoZSBIVFRQIHZlcmIgdG8gdXNlIHdoZW4gdGhlIGZvcm0gaXMgc3VibWl0LiBTdXBwb3J0cyBcImdldFwiLCBcInBvc3RcIixcbiAgICogXCJwdXRcIiwgXCJkZWxldGVcIiwgXCJwYXRjaFwiLlxuICAgKi9cbiAgbWV0aG9kPzogSFRNTEZvcm1NZXRob2Q7XG5cbiAgLyoqXG4gICAqIGA8Zm9ybSBlbmNUeXBlPmAgLSBlbmhhbmNpbmcgYmV5b25kIHRoZSBub3JtYWwgc3RyaW5nIHR5cGUgYW5kIGxpbWl0aW5nXG4gICAqIHRvIHRoZSBidWlsdC1pbiBicm93c2VyIHN1cHBvcnRlZCB2YWx1ZXNcbiAgICovXG4gIGVuY1R5cGU/OlxuICAgIHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgIHwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCJcbiAgICB8IFwidGV4dC9wbGFpblwiO1xuXG4gIC8qKlxuICAgKiBOb3JtYWwgYDxmb3JtIGFjdGlvbj5gIGJ1dCBzdXBwb3J0cyBSZWFjdCBSb3V0ZXIncyByZWxhdGl2ZSBwYXRocy5cbiAgICovXG4gIGFjdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmb3JtIGFjdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgcm91dGUgaGllcmFyY2h5IG9yXG4gICAqIHRoZSBwYXRobmFtZS4gIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIG9wdCBvdXQgb2YgbmF2aWdhdGluZyB0aGUgcm91dGVcbiAgICogaGllcmFyY2h5IGFuZCB3YW50IHRvIGluc3RlYWQgcm91dGUgYmFzZWQgb24gLy1kZWxpbWl0ZWQgVVJMIHNlZ21lbnRzXG4gICAqL1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgdGhlIHNjcm9sbCBwb3NpdGlvbiBmcm9tIHJlc2V0dGluZyB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydCBvblxuICAgKiBjb21wbGV0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIHdoZW4gdXNpbmcgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gICAqL1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQuIElmIHlvdSBjYWxsXG4gICAqIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCB0aGVuIHRoaXMgZm9ybSB3aWxsIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIG9uU3VibWl0PzogUmVhY3QuRm9ybUV2ZW50SGFuZGxlcjxIVE1MRm9ybUVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1Qcm9wcyBleHRlbmRzIEZldGNoZXJGb3JtUHJvcHMge1xuICAvKipcbiAgICogRm9yY2VzIGEgZnVsbCBkb2N1bWVudCBuYXZpZ2F0aW9uIGluc3RlYWQgb2YgYSBmZXRjaC5cbiAgICovXG4gIHJlbG9hZERvY3VtZW50PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgZW50cnkgaW4gdGhlIGJyb3dzZXIgaGlzdG9yeSBzdGFjayB3aGVuIHRoZSBmb3JtXG4gICAqIG5hdmlnYXRlcy4gVXNlIHRoaXMgaWYgeW91IGRvbid0IHdhbnQgdGhlIHVzZXIgdG8gYmUgYWJsZSB0byBjbGljayBcImJhY2tcIlxuICAgKiB0byB0aGUgcGFnZSB3aXRoIHRoZSBmb3JtIG9uIGl0LlxuICAgKi9cbiAgcmVwbGFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFN0YXRlIG9iamVjdCB0byBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RhY2sgZW50cnkgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgKi9cbiAgc3RhdGU/OiBhbnk7XG59XG5cbi8qKlxuICogQSBgQHJlbWl4LXJ1bi9yb3V0ZXJgLWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHRcbiAqIHRoYXQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqL1xuZXhwb3J0IGNvbnN0IEZvcm0gPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxGb3JtRWxlbWVudCwgRm9ybVByb3BzPihcbiAgKHByb3BzLCByZWYpID0+IHtcbiAgICBsZXQgc3VibWl0ID0gdXNlU3VibWl0KCk7XG4gICAgcmV0dXJuIDxGb3JtSW1wbCB7Li4ucHJvcHN9IHN1Ym1pdD17c3VibWl0fSByZWY9e3JlZn0gLz47XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIEZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbn1cblxudHlwZSBIVE1MU3VibWl0RXZlbnQgPSBSZWFjdC5CYXNlU3ludGhldGljRXZlbnQ8XG4gIFN1Ym1pdEV2ZW50LFxuICBFdmVudCxcbiAgSFRNTEZvcm1FbGVtZW50XG4+O1xuXG50eXBlIEhUTUxGb3JtU3VibWl0dGVyID0gSFRNTEJ1dHRvbkVsZW1lbnQgfCBIVE1MSW5wdXRFbGVtZW50O1xuXG5pbnRlcmZhY2UgRm9ybUltcGxQcm9wcyBleHRlbmRzIEZvcm1Qcm9wcyB7XG4gIHN1Ym1pdDogU3VibWl0RnVuY3Rpb24gfCBGZXRjaGVyU3VibWl0RnVuY3Rpb247XG59XG5cbmNvbnN0IEZvcm1JbXBsID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MRm9ybUVsZW1lbnQsIEZvcm1JbXBsUHJvcHM+KFxuICAoXG4gICAge1xuICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgICAgYWN0aW9uLFxuICAgICAgb25TdWJtaXQsXG4gICAgICBzdWJtaXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIC4uLnByb3BzXG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgbGV0IGZvcm1NZXRob2Q6IEhUTUxGb3JtTWV0aG9kID1cbiAgICAgIG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IHN1Ym1pdEhhbmRsZXI6IFJlYWN0LkZvcm1FdmVudEhhbmRsZXI8SFRNTEZvcm1FbGVtZW50PiA9IChldmVudCkgPT4ge1xuICAgICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGxldCBzdWJtaXR0ZXIgPSAoZXZlbnQgYXMgdW5rbm93biBhcyBIVE1MU3VibWl0RXZlbnQpLm5hdGl2ZUV2ZW50XG4gICAgICAgIC5zdWJtaXR0ZXIgYXMgSFRNTEZvcm1TdWJtaXR0ZXIgfCBudWxsO1xuXG4gICAgICBsZXQgc3VibWl0TWV0aG9kID1cbiAgICAgICAgKHN1Ym1pdHRlcj8uZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSBhcyBIVE1MRm9ybU1ldGhvZCB8IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgbWV0aG9kO1xuXG4gICAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Zm9ybVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgICAgbWV0aG9kPXtmb3JtTWV0aG9kfVxuICAgICAgICBhY3Rpb249e2Zvcm1BY3Rpb259XG4gICAgICAgIG9uU3VibWl0PXtyZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlcn1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBGb3JtSW1wbC5kaXNwbGF5TmFtZSA9IFwiRm9ybUltcGxcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxSZXN0b3JhdGlvblByb3BzIHtcbiAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbjtcbiAgc3RvcmFnZUtleT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGVtdWxhdGUgdGhlIGJyb3dzZXIncyBzY3JvbGwgcmVzdG9yYXRpb24gb24gbG9jYXRpb25cbiAqIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleSxcbn06IFNjcm9sbFJlc3RvcmF0aW9uUHJvcHMpIHtcbiAgdXNlU2Nyb2xsUmVzdG9yYXRpb24oeyBnZXRLZXksIHN0b3JhZ2VLZXkgfSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5pZiAoX19ERVZfXykge1xuICBTY3JvbGxSZXN0b3JhdGlvbi5kaXNwbGF5TmFtZSA9IFwiU2Nyb2xsUmVzdG9yYXRpb25cIjtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhvb2tzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5lbnVtIERhdGFSb3V0ZXJIb29rIHtcbiAgVXNlU2Nyb2xsUmVzdG9yYXRpb24gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCIsXG4gIFVzZVN1Ym1pdCA9IFwidXNlU3VibWl0XCIsXG4gIFVzZVN1Ym1pdEZldGNoZXIgPSBcInVzZVN1Ym1pdEZldGNoZXJcIixcbiAgVXNlRmV0Y2hlciA9IFwidXNlRmV0Y2hlclwiLFxufVxuXG5lbnVtIERhdGFSb3V0ZXJTdGF0ZUhvb2sge1xuICBVc2VGZXRjaGVycyA9IFwidXNlRmV0Y2hlcnNcIixcbiAgVXNlU2Nyb2xsUmVzdG9yYXRpb24gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCIsXG59XG5cbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoXG4gIGhvb2tOYW1lOiBEYXRhUm91dGVySG9vayB8IERhdGFSb3V0ZXJTdGF0ZUhvb2tcbikge1xuICByZXR1cm4gYCR7aG9va05hbWV9IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWU6IERhdGFSb3V0ZXJIb29rKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWU6IERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHN0YXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXG4gKiB5b3UgbmVlZCB0byBjcmVhdGUgY3VzdG9tIGA8TGluaz5gIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBjbGljayBiZWhhdmlvciB3ZVxuICogdXNlIGluIG91ciBleHBvcnRlZCBgPExpbms+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXI8RSBleHRlbmRzIEVsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudD4oXG4gIHRvOiBUbyxcbiAge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmUsXG4gIH06IHtcbiAgICB0YXJnZXQ/OiBSZWFjdC5IVE1MQXR0cmlidXRlQW5jaG9yVGFyZ2V0O1xuICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIHN0YXRlPzogYW55O1xuICAgIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gICAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xuICB9ID0ge31cbik6IChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4gdm9pZCB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHtcbiAgICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZSB1bmxlc3MgdGhlIHJlcGxhY2UgcHJvcCBpcyBleHBsaWNpdGx5IHNldFxuICAgICAgICBsZXQgcmVwbGFjZSA9XG4gICAgICAgICAgcmVwbGFjZVByb3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyByZXBsYWNlUHJvcFxuICAgICAgICAgICAgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcblxuICAgICAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSwgcHJldmVudFNjcm9sbFJlc2V0LCByZWxhdGl2ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGUsXG4gICAgICBwYXRoLFxuICAgICAgcmVwbGFjZVByb3AsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgXVxuICApO1xufVxuXG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoXG4gIGRlZmF1bHRJbml0PzogVVJMU2VhcmNoUGFyYW1zSW5pdFxuKTogW1VSTFNlYXJjaFBhcmFtcywgU2V0VVJMU2VhcmNoUGFyYW1zXSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IGAgK1xuICAgICAgYHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgYCArXG4gICAgICBgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgYCArXG4gICAgICBgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuYCArXG4gICAgICBgSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IGAgK1xuICAgICAgYGh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBgICtcbiAgICAgIGB0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgYCArXG4gICAgICBgdXNlci5gXG4gICk7XG5cbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG4gIGxldCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxuICAgICAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgICAgIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50XG4gICAgICApLFxuICAgIFtsb2NhdGlvbi5zZWFyY2hdXG4gICk7XG5cbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZUNhbGxiYWNrPFNldFVSTFNlYXJjaFBhcmFtcz4oXG4gICAgKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgICAgICAgdHlwZW9mIG5leHRJbml0ID09PSBcImZ1bmN0aW9uXCIgPyBuZXh0SW5pdChzZWFyY2hQYXJhbXMpIDogbmV4dEluaXRcbiAgICAgICk7XG4gICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBuYXZpZ2F0ZShcIj9cIiArIG5ld1NlYXJjaFBhcmFtcywgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9LFxuICAgIFtuYXZpZ2F0ZSwgc2VhcmNoUGFyYW1zXVxuICApO1xuXG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxuXG5leHBvcnQgdHlwZSBTZXRVUkxTZWFyY2hQYXJhbXMgPSAoXG4gIG5leHRJbml0PzpcbiAgICB8IFVSTFNlYXJjaFBhcmFtc0luaXRcbiAgICB8ICgocHJldjogVVJMU2VhcmNoUGFyYW1zKSA9PiBVUkxTZWFyY2hQYXJhbXNJbml0KSxcbiAgbmF2aWdhdGVPcHRzPzogTmF2aWdhdGVPcHRpb25zXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogU3VibWl0cyBhIEhUTUwgYDxmb3JtPmAgdG8gdGhlIHNlcnZlciB3aXRob3V0IHJlbG9hZGluZyB0aGUgcGFnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRGdW5jdGlvbiB7XG4gIChcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGA8Zm9ybT5gIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgc2VydmVyLCBhIHNwZWNpZmljXG4gICAgICogYDxidXR0b24+YCBvciBgPGlucHV0IHR5cGU9XCJzdWJtaXRcIj5gIHRvIHVzZSB0byBzdWJtaXQgdGhlIGZvcm0sIG9yIHNvbWVcbiAgICAgKiBhcmJpdHJhcnkgZGF0YSB0byBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBXaGVuIHVzaW5nIGEgYDxidXR0b24+YCBpdHMgYG5hbWVgIGFuZCBgdmFsdWVgIHdpbGwgYWxzbyBiZVxuICAgICAqIGluY2x1ZGVkIGluIHRoZSBmb3JtIGRhdGEgdGhhdCBpcyBzdWJtaXR0ZWQuXG4gICAgICovXG4gICAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHRoYXQgb3ZlcnJpZGUgdGhlIGA8Zm9ybT5gJ3Mgb3duIGF0dHJpYnV0ZXMuIFJlcXVpcmVkIHdoZW5cbiAgICAgKiBzdWJtaXR0aW5nIGFyYml0cmFyeSBkYXRhIHdpdGhvdXQgYSBiYWNraW5nIGA8Zm9ybT5gLlxuICAgICAqL1xuICAgIG9wdGlvbnM/OiBTdWJtaXRPcHRpb25zXG4gICk6IHZvaWQ7XG59XG5cbi8qKlxuICogU3VibWl0cyBhIGZldGNoZXIgYDxmb3JtPmAgdG8gdGhlIHNlcnZlciB3aXRob3V0IHJlbG9hZGluZyB0aGUgcGFnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGZXRjaGVyU3VibWl0RnVuY3Rpb24ge1xuICAoXG4gICAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG4gICAgLy8gRmV0Y2hlcnMgY2Fubm90IHJlcGxhY2Ugb3Igc2V0IHN0YXRlIGJlY2F1c2UgdGhleSBhcmUgbm90IG5hdmlnYXRpb24gZXZlbnRzXG4gICAgb3B0aW9ucz86IE9taXQ8U3VibWl0T3B0aW9ucywgXCJyZXBsYWNlXCIgfCBcInN0YXRlXCI+XG4gICk6IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArXG4gICAgICAgIFwiVHJ5IGNhbGxpbmcgc3VibWl0IHdpdGhpbiBhIGB1c2VFZmZlY3RgIG9yIGNhbGxiYWNrIGluc3RlYWQuXCJcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1Ym1pdCgpOiBTdWJtaXRGdW5jdGlvbiB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU3VibWl0KTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSB1c2VSb3V0ZUlkKCk7XG5cbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrPFN1Ym1pdEZ1bmN0aW9uPihcbiAgICAodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKTtcblxuICAgICAgbGV0IHsgYWN0aW9uLCBtZXRob2QsIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH0gPSBnZXRGb3JtU3VibWlzc2lvbkluZm8oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgYmFzZW5hbWVcbiAgICAgICk7XG5cbiAgICAgIHJvdXRlci5uYXZpZ2F0ZShvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IChtZXRob2QgYXMgSFRNTEZvcm1NZXRob2QpLFxuICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IChlbmNUeXBlIGFzIEZvcm1FbmNUeXBlKSxcbiAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgZnJvbVJvdXRlSWQ6IGN1cnJlbnRSb3V0ZUlkLFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbcm91dGVyLCBiYXNlbmFtZSwgY3VycmVudFJvdXRlSWRdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW1wbGVtZW50YXRpb24gZm9yIGZldGNoZXIuc3VibWl0XG4gKi9cbmZ1bmN0aW9uIHVzZVN1Ym1pdEZldGNoZXIoXG4gIGZldGNoZXJLZXk6IHN0cmluZyxcbiAgZmV0Y2hlclJvdXRlSWQ6IHN0cmluZ1xuKTogRmV0Y2hlclN1Ym1pdEZ1bmN0aW9uIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXRGZXRjaGVyKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjazxGZXRjaGVyU3VibWl0RnVuY3Rpb24+KFxuICAgICh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpO1xuXG4gICAgICBsZXQgeyBhY3Rpb24sIG1ldGhvZCwgZW5jVHlwZSwgZm9ybURhdGEsIGJvZHkgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyhcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBiYXNlbmFtZVxuICAgICAgKTtcblxuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmZXRjaGVyUm91dGVJZCAhPSBudWxsLFxuICAgICAgICBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciB1c2VGZXRjaGVyKClcIlxuICAgICAgKTtcbiAgICAgIHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCBmZXRjaGVyUm91dGVJZCwgb3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBib2R5LFxuICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCAobWV0aG9kIGFzIEhUTUxGb3JtTWV0aG9kKSxcbiAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCAoZW5jVHlwZSBhcyBGb3JtRW5jVHlwZSksXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtyb3V0ZXIsIGJhc2VuYW1lLCBmZXRjaGVyS2V5LCBmZXRjaGVyUm91dGVJZF1cbiAgKTtcbn1cblxuLy8gdjc6IEV2ZW50dWFsbHkgd2Ugc2hvdWxkIGRlcHJlY2F0ZSB0aGlzIGVudGlyZWx5IGluIGZhdm9yIG9mIHVzaW5nIHRoZVxuLy8gcm91dGVyIG1ldGhvZCBkaXJlY3RseT9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb3JtQWN0aW9uKFxuICBhY3Rpb24/OiBzdHJpbmcsXG4gIHsgcmVsYXRpdmUgfTogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pOiBzdHJpbmcge1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCByb3V0ZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZUNvbnRleHQsIFwidXNlRm9ybUFjdGlvbiBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpO1xuXG4gIGxldCBbbWF0Y2hdID0gcm91dGVDb250ZXh0Lm1hdGNoZXMuc2xpY2UoLTEpO1xuICAvLyBTaGFsbG93IGNsb25lIHBhdGggc28gd2UgY2FuIG1vZGlmeSBpdCBiZWxvdywgb3RoZXJ3aXNlIHdlIG1vZGlmeSB0aGVcbiAgLy8gb2JqZWN0IHJlZmVyZW5jZWQgYnkgdXNlTWVtbyBpbnNpZGUgdXNlUmVzb2x2ZWRQYXRoXG4gIGxldCBwYXRoID0geyAuLi51c2VSZXNvbHZlZFBhdGgoYWN0aW9uID8gYWN0aW9uIDogXCIuXCIsIHsgcmVsYXRpdmUgfSkgfTtcblxuICAvLyBQcmV2aW91c2x5IHdlIHNldCB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gXCIuXCIuIFRoZSBwcm9ibGVtIHdpdGggdGhpcyBpcyB0aGF0XG4gIC8vIGB1c2VSZXNvbHZlZFBhdGgoXCIuXCIpYCBleGNsdWRlcyBzZWFyY2ggcGFyYW1zIG9mIHRoZSByZXNvbHZlZCBVUkwuIFRoaXMgaXNcbiAgLy8gdGhlIGludGVuZGVkIGJlaGF2aW9yIG9mIHdoZW4gXCIuXCIgaXMgc3BlY2lmaWNhbGx5IHByb3ZpZGVkIGFzXG4gIC8vIHRoZSBmb3JtIGFjdGlvbiwgYnV0IGluY29uc2lzdGVudCB3LyBicm93c2VycyB3aGVuIHRoZSBhY3Rpb24gaXMgb21pdHRlZC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgIC8vIFNhZmUgdG8gd3JpdGUgdG8gdGhpcyBkaXJlY3RseSBoZXJlIHNpbmNlIGlmIGFjdGlvbiB3YXMgdW5kZWZpbmVkLCB3ZVxuICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG5cbiAgICAvLyBXaGVuIGdyYWJiaW5nIHNlYXJjaCBwYXJhbXMgZnJvbSB0aGUgVVJMLCByZW1vdmUgdGhlIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBpbnNlcnRlZCA/aW5kZXggcGFyYW0gc28gd2UgbWF0Y2ggdGhlIHVzZVJlc29sdmVkUGF0aCBzZWFyY2ggYmVoYXZpb3JcbiAgICAvLyB3aGljaCB3b3VsZCBub3QgaW5jbHVkZSA/aW5kZXhcbiAgICBpZiAobWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcGFyYW1zLnRvU3RyaW5nKCkgPyBgPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCA6IFwiXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKCghYWN0aW9uIHx8IGFjdGlvbiA9PT0gXCIuXCIpICYmIG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaFxuICAgICAgPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpXG4gICAgICA6IFwiP2luZGV4XCI7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBmb3JtIGFjdGlvbi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2VcbiAgLy8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlXG4gIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID1cbiAgICAgIHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hlckZvcm0oZmV0Y2hlcktleTogc3RyaW5nLCByb3V0ZUlkOiBzdHJpbmcpIHtcbiAgbGV0IEZldGNoZXJGb3JtID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MRm9ybUVsZW1lbnQsIEZldGNoZXJGb3JtUHJvcHM+KFxuICAgIChwcm9wcywgcmVmKSA9PiB7XG4gICAgICBsZXQgc3VibWl0ID0gdXNlU3VibWl0RmV0Y2hlcihmZXRjaGVyS2V5LCByb3V0ZUlkKTtcbiAgICAgIHJldHVybiA8Rm9ybUltcGwgey4uLnByb3BzfSByZWY9e3JlZn0gc3VibWl0PXtzdWJtaXR9IC8+O1xuICAgIH1cbiAgKTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gIH1cbiAgcmV0dXJuIEZldGNoZXJGb3JtO1xufVxuXG5sZXQgZmV0Y2hlcklkID0gMDtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlcldpdGhDb21wb25lbnRzPFREYXRhPiA9IEZldGNoZXI8VERhdGE+ICYge1xuICBGb3JtOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVGZXRjaGVyRm9ybT47XG4gIHN1Ym1pdDogRmV0Y2hlclN1Ym1pdEZ1bmN0aW9uO1xuICBsb2FkOiAoaHJlZjogc3RyaW5nKSA9PiB2b2lkO1xufTtcblxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIHVzZUZldGNoZXIgZ2VuZXJpYyBkZWZhdWx0IGZyb20gYGFueWAgdG8gYHVua25vd25gXG5cbi8qKlxuICogSW50ZXJhY3RzIHdpdGggcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyB3aXRob3V0IGNhdXNpbmcgYSBuYXZpZ2F0aW9uLiBHcmVhdFxuICogZm9yIGFueSBpbnRlcmFjdGlvbiB0aGF0IHN0YXlzIG9uIHRoZSBzYW1lIHBhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGZXRjaGVyPFREYXRhID0gYW55PigpOiBGZXRjaGVyV2l0aENvbXBvbmVudHM8VERhdGE+IHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VGZXRjaGVyKTtcblxuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZSwgYHVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dGApO1xuXG4gIGxldCByb3V0ZUlkID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdPy5yb3V0ZS5pZDtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlSWQgIT0gbnVsbCxcbiAgICBgdXNlRmV0Y2hlciBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiYFxuICApO1xuXG4gIGxldCBbZmV0Y2hlcktleV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBTdHJpbmcoKytmZXRjaGVySWQpKTtcbiAgbGV0IFtGb3JtXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICBpbnZhcmlhbnQocm91dGVJZCwgYE5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLkZvcm0oKWApO1xuICAgIHJldHVybiBjcmVhdGVGZXRjaGVyRm9ybShmZXRjaGVyS2V5LCByb3V0ZUlkKTtcbiAgfSk7XG4gIGxldCBbbG9hZF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoaHJlZjogc3RyaW5nKSA9PiB7XG4gICAgaW52YXJpYW50KHJvdXRlciwgXCJObyByb3V0ZXIgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKTtcbiAgICBpbnZhcmlhbnQocm91dGVJZCwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIik7XG4gICAgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYpO1xuICB9KTtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEZldGNoZXIoZmV0Y2hlcktleSwgcm91dGVJZCk7XG5cbiAgbGV0IGZldGNoZXIgPSByb3V0ZXIuZ2V0RmV0Y2hlcjxURGF0YT4oZmV0Y2hlcktleSk7XG5cbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIEZvcm0sXG4gICAgICBzdWJtaXQsXG4gICAgICBsb2FkLFxuICAgICAgLi4uZmV0Y2hlcixcbiAgICB9KSxcbiAgICBbZmV0Y2hlciwgRm9ybSwgc3VibWl0LCBsb2FkXVxuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBidXN0ZWQgd2hlbiB0aGUgUmVhY3QgdGVhbSBnZXRzIHJlYWwgd2VpcmQgYW5kIGNhbGxzIGVmZmVjdHNcbiAgICAvLyB0d2ljZSBvbiBtb3VudD8gIFdlIHJlYWxseSBqdXN0IG5lZWQgdG8gZ2FyYmFnZSBjb2xsZWN0IGhlcmUgd2hlbiB0aGlzXG4gICAgLy8gZmV0Y2hlciBpcyBubyBsb25nZXIgYXJvdW5kLlxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIHJvdXRlciBhdmFpbGFibGUgdG8gY2xlYW4gdXAgZnJvbSB1c2VGZXRjaGVyKClgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcm91dGVyLmRlbGV0ZUZldGNoZXIoZmV0Y2hlcktleSk7XG4gICAgfTtcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuXG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZldGNoZXJzKCk6IEZldGNoZXJbXSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXJzKTtcbiAgcmV0dXJuIFsuLi5zdGF0ZS5mZXRjaGVycy52YWx1ZXMoKV07XG59XG5cbmNvbnN0IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbmxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuXG4vKipcbiAqIFdoZW4gcmVuZGVyZWQgaW5zaWRlIGEgUm91dGVyUHJvdmlkZXIsIHdpbGwgcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25zIG9uIG5hdmlnYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxufToge1xuICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uO1xuICBzdG9yYWdlS2V5Pzogc3RyaW5nO1xufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICBsZXQgeyByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldCB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb25cbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWF0Y2hlcyA9IHVzZU1hdGNoZXMoKTtcbiAgbGV0IG5hdmlnYXRpb24gPSB1c2VOYXZpZ2F0aW9uKCk7XG5cbiAgLy8gVHJpZ2dlciBtYW51YWwgc2Nyb2xsIHJlc3RvcmF0aW9uIHdoaWxlIHdlJ3JlIGFjdGl2ZVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gU2F2ZSBwb3NpdGlvbnMgb24gcGFnZWhpZGVcbiAgdXNlUGFnZUhpZGUoXG4gICAgUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGxldCBrZXkgPSAoZ2V0S2V5ID8gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKSA6IG51bGwpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHNhdmVkU2Nyb2xsUG9zaXRpb25zKVxuICAgICAgKTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfSwgW3N0b3JhZ2VLZXksIGdldEtleSwgbmF2aWdhdGlvbi5zdGF0ZSwgbG9jYXRpb24sIG1hdGNoZXNdKVxuICApO1xuXG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7XG5cbiAgICAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGdldEtleVdpdGhvdXRCYXNlbmFtZTogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGdldEtleSAmJiBiYXNlbmFtZSAhPT0gXCIvXCJcbiAgICAgICAgICA/IChsb2NhdGlvbiwgbWF0Y2hlcykgPT5cbiAgICAgICAgICAgICAgZ2V0S2V5KFxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBiYXNlbmFtZSB0byBtYXRjaCB1c2VMb2NhdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLi4ubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICBwYXRobmFtZTpcbiAgICAgICAgICAgICAgICAgICAgc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgOiBnZXRLZXk7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyPy5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAgICgpID0+IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICBnZXRLZXlXaXRob3V0QmFzZW5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcblxuICAgIC8vIFJlc3RvcmUgc2Nyb2xsaW5nIHdoZW4gc3RhdGUucmVzdG9yZVNjcm9sbFBvc2l0aW9uIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gRXhwbGljaXQgZmFsc2UgbWVhbnMgZG9uJ3QgZG8gYW55dGhpbmcgKHVzZWQgZm9yIHN1Ym1pc3Npb25zKVxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCByZXNldCBpZiB0aGlzIG5hdmlnYXRpb24gb3B0ZWQgb3V0XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbiAgfVxufVxuXG5leHBvcnQgeyB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24gfTtcblxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKFxuICBjYWxsYmFjazogKGV2ZW50OiBCZWZvcmVVbmxvYWRFdmVudCkgPT4gYW55LFxuICBvcHRpb25zPzogeyBjYXB0dXJlPzogYm9vbGVhbiB9XG4pOiB2b2lkIHtcbiAgbGV0IHsgY2FwdHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdW5kZWZpbmVkO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBwYWdlaGlkZWAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKFxuICBjYWxsYmFjazogKGV2ZW50OiBQYWdlVHJhbnNpdGlvbkV2ZW50KSA9PiBhbnksXG4gIG9wdGlvbnM/OiB7IGNhcHR1cmU/OiBib29sZWFuIH1cbik6IHZvaWQge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIHVzZUJsb2NrZXIgdG8gc2hvdyBhIHdpbmRvdy5jb25maXJtIHByb21wdCB0byB1c2VycyBpbnN0ZWFkXG4gKiBvZiBidWlsZGluZyBhIGN1c3RvbSBVSSB3aXRoIHVzZUJsb2NrZXIuXG4gKlxuICogV2FybmluZzogVGhpcyBoYXMgKmEgbG90IG9mIHJvdWdoIGVkZ2VzKiBhbmQgYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IChhbmRcbiAqIHZlcnkgaW5jb3JyZWN0bHkgaW4gc29tZSBjYXNlcykgYWNyb3NzIGJyb3dzZXJzIGlmIHVzZXIgY2xpY2sgYWRkaXRpb25cbiAqIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aGlsZSB0aGUgY29uZmlybSBpcyBvcGVuLiAgVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gKi9cbmZ1bmN0aW9uIHVzZVByb21wdCh7IHdoZW4sIG1lc3NhZ2UgfTogeyB3aGVuOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfSkge1xuICBsZXQgYmxvY2tlciA9IHVzZUJsb2NrZXIod2hlbik7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICBpZiAocHJvY2VlZCkge1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgaXMgbmVlZGVkIHRvIGF2b2lkIGEgd2VpcmQgXCJyYWNlXCIgb24gUE9QIG5hdmlnYXRpb25zXG4gICAgICAgIC8vIGJldHdlZW4gdGhlIGB3aW5kb3cuaGlzdG9yeWAgcmV2ZXJ0IG5hdmlnYXRpb24gYW5kIHRoZSByZXN1bHQgb2ZcbiAgICAgICAgLy8gYHdpbmRvdy5jb25maXJtYFxuICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tlciwgbWVzc2FnZV0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmICF3aGVuKSB7XG4gICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgfVxuICB9LCBbYmxvY2tlciwgd2hlbl0pO1xufVxuXG5leHBvcnQgeyB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0IH07XG5cbi8vI2VuZHJlZ2lvblxuIl0sIm5hbWVzIjpbImRlZmF1bHRNZXRob2QiLCJkZWZhdWx0RW5jVHlwZSIsImlzSHRtbEVsZW1lbnQiLCJvYmplY3QiLCJ0YWdOYW1lIiwiaXNCdXR0b25FbGVtZW50IiwidG9Mb3dlckNhc2UiLCJpc0Zvcm1FbGVtZW50IiwiaXNJbnB1dEVsZW1lbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJzaG91bGRQcm9jZXNzTGlua0NsaWNrIiwidGFyZ2V0IiwiYnV0dG9uIiwiY3JlYXRlU2VhcmNoUGFyYW1zIiwiaW5pdCIsIlVSTFNlYXJjaFBhcmFtcyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJtZW1vIiwia2V5IiwidmFsdWUiLCJjb25jYXQiLCJtYXAiLCJ2IiwiZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24iLCJsb2NhdGlvblNlYXJjaCIsImRlZmF1bHRTZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJmb3JFYWNoIiwiXyIsImhhcyIsImdldEFsbCIsImFwcGVuZCIsIl9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyIiwiaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCIsIkZvcm1EYXRhIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZSIsInN1cHBvcnRlZEZvcm1FbmNUeXBlcyIsIlNldCIsImdldEZvcm1FbmNUeXBlIiwiZW5jVHlwZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlVOU0FGRV93YXJuaW5nIiwiZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvIiwiYmFzZW5hbWUiLCJtZXRob2QiLCJhY3Rpb24iLCJmb3JtRGF0YSIsImJvZHkiLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwic3RyaXBCYXNlbmFtZSIsInR5cGUiLCJmb3JtIiwiRXJyb3IiLCJuYW1lIiwicHJlZml4IiwidW5kZWZpbmVkIiwiY3JlYXRlQnJvd3NlclJvdXRlciIsInJvdXRlcyIsIm9wdHMiLCJjcmVhdGVSb3V0ZXIiLCJmdXR1cmUiLCJfZXh0ZW5kcyIsInY3X3ByZXBlbmRCYXNlbmFtZSIsImhpc3RvcnkiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsIndpbmRvdyIsImh5ZHJhdGlvbkRhdGEiLCJwYXJzZUh5ZHJhdGlvbkRhdGEiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIiwiaW5pdGlhbGl6ZSIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJjcmVhdGVIYXNoSGlzdG9yeSIsIl93aW5kb3ciLCJzdGF0ZSIsIl9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSIsImVycm9ycyIsImRlc2VyaWFsaXplRXJyb3JzIiwiZW50cmllcyIsInNlcmlhbGl6ZWQiLCJ2YWwiLCJfX3R5cGUiLCJVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImludGVybmFsIiwiX19zdWJUeXBlIiwiRXJyb3JDb25zdHJ1Y3RvciIsImVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwiU1RBUlRfVFJBTlNJVElPTiIsInN0YXJ0VHJhbnNpdGlvbkltcGwiLCJSZWFjdCIsIkJyb3dzZXJSb3V0ZXIiLCJfcmVmIiwiY2hpbGRyZW4iLCJoaXN0b3J5UmVmIiwidXNlUmVmIiwiY3VycmVudCIsInY1Q29tcGF0Iiwic2V0U3RhdGVJbXBsIiwidXNlU3RhdGUiLCJsb2NhdGlvbiIsInY3X3N0YXJ0VHJhbnNpdGlvbiIsInNldFN0YXRlIiwidXNlQ2FsbGJhY2siLCJuZXdTdGF0ZSIsInVzZUxheW91dEVmZmVjdCIsImxpc3RlbiIsIlJvdXRlciIsIm5hdmlnYXRpb25UeXBlIiwibmF2aWdhdG9yIiwiSGFzaFJvdXRlciIsIl9yZWYyIiwiSGlzdG9yeVJvdXRlciIsIl9yZWYzIiwiZGlzcGxheU5hbWUiLCJpc0Jyb3dzZXIiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtXaXRoUmVmIiwiX3JlZjQiLCJyZWYiLCJvbkNsaWNrIiwicmVsYXRpdmUiLCJyZWxvYWREb2N1bWVudCIsInJlcGxhY2UiLCJ0byIsInByZXZlbnRTY3JvbGxSZXNldCIsInJlc3QiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsIl9leGNsdWRlZCIsInVzZUNvbnRleHQiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJhYnNvbHV0ZUhyZWYiLCJpc0V4dGVybmFsIiwidGVzdCIsImN1cnJlbnRVcmwiLCJVUkwiLCJocmVmIiwidGFyZ2V0VXJsIiwic3RhcnRzV2l0aCIsInByb3RvY29sIiwicGF0aCIsInBhdGhuYW1lIiwib3JpZ2luIiwic2VhcmNoIiwiaGFzaCIsInVzZUhyZWYiLCJpbnRlcm5hbE9uQ2xpY2siLCJ1c2VMaW5rQ2xpY2tIYW5kbGVyIiwiaGFuZGxlQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwiTmF2TGluayIsIk5hdkxpbmtXaXRoUmVmIiwiX3JlZjUiLCJhcmlhQ3VycmVudFByb3AiLCJjYXNlU2Vuc2l0aXZlIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lUHJvcCIsImVuZCIsInN0eWxlIiwic3R5bGVQcm9wIiwiX2V4Y2x1ZGVkMiIsInVzZVJlc29sdmVkUGF0aCIsInVzZUxvY2F0aW9uIiwicm91dGVyU3RhdGUiLCJVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsInRvUGF0aG5hbWUiLCJlbmNvZGVMb2NhdGlvbiIsImxvY2F0aW9uUGF0aG5hbWUiLCJuZXh0TG9jYXRpb25QYXRobmFtZSIsIm5hdmlnYXRpb24iLCJpc0FjdGl2ZSIsImNoYXJBdCIsImxlbmd0aCIsImlzUGVuZGluZyIsImFyaWFDdXJyZW50IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJGb3JtIiwicHJvcHMiLCJzdWJtaXQiLCJ1c2VTdWJtaXQiLCJGb3JtSW1wbCIsIl9yZWY2IiwiZm9yd2FyZGVkUmVmIiwib25TdWJtaXQiLCJfZXhjbHVkZWQzIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJ1c2VGb3JtQWN0aW9uIiwic3VibWl0SGFuZGxlciIsInByZXZlbnREZWZhdWx0Iiwic3VibWl0dGVyIiwibmF0aXZlRXZlbnQiLCJzdWJtaXRNZXRob2QiLCJjdXJyZW50VGFyZ2V0IiwiU2Nyb2xsUmVzdG9yYXRpb24iLCJfcmVmNyIsImdldEtleSIsInN0b3JhZ2VLZXkiLCJ1c2VTY3JvbGxSZXN0b3JhdGlvbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwiVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IiwiVU5TQUZFX2ludmFyaWFudCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsIl90ZW1wIiwicmVwbGFjZVByb3AiLCJuYXZpZ2F0ZSIsInVzZU5hdmlnYXRlIiwiY3JlYXRlUGF0aCIsInVzZVNlYXJjaFBhcmFtcyIsImRlZmF1bHRJbml0IiwiZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiIsImhhc1NldFNlYXJjaFBhcmFtc1JlZiIsInVzZU1lbW8iLCJzZXRTZWFyY2hQYXJhbXMiLCJuZXh0SW5pdCIsIm5hdmlnYXRlT3B0aW9ucyIsIm5ld1NlYXJjaFBhcmFtcyIsInZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24iLCJyb3V0ZXIiLCJVc2VTdWJtaXQiLCJjdXJyZW50Um91dGVJZCIsIlVOU0FGRV91c2VSb3V0ZUlkIiwib3B0aW9ucyIsImZvcm1FbmNUeXBlIiwiZnJvbVJvdXRlSWQiLCJ1c2VTdWJtaXRGZXRjaGVyIiwiZmV0Y2hlcktleSIsImZldGNoZXJSb3V0ZUlkIiwiVXNlU3VibWl0RmV0Y2hlciIsImZldGNoIiwiX3RlbXAyIiwicm91dGVDb250ZXh0IiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsIm1hdGNoIiwibWF0Y2hlcyIsInNsaWNlIiwicm91dGUiLCJpbmRleCIsInBhcmFtcyIsImRlbGV0ZSIsInRvU3RyaW5nIiwiam9pblBhdGhzIiwiY3JlYXRlRmV0Y2hlckZvcm0iLCJyb3V0ZUlkIiwiRmV0Y2hlckZvcm0iLCJmZXRjaGVySWQiLCJ1c2VGZXRjaGVyIiwiX3JvdXRlJG1hdGNoZXMiLCJVc2VGZXRjaGVyIiwiaWQiLCJTdHJpbmciLCJsb2FkIiwiZmV0Y2hlciIsImdldEZldGNoZXIiLCJmZXRjaGVyV2l0aENvbXBvbmVudHMiLCJ1c2VFZmZlY3QiLCJjb25zb2xlIiwid2FybiIsImRlbGV0ZUZldGNoZXIiLCJ1c2VGZXRjaGVycyIsIlVzZUZldGNoZXJzIiwiZmV0Y2hlcnMiLCJ2YWx1ZXMiLCJTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsIl90ZW1wMyIsIlVzZVNjcm9sbFJlc3RvcmF0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwidXNlTWF0Y2hlcyIsInVzZU5hdmlnYXRpb24iLCJzY3JvbGxSZXN0b3JhdGlvbiIsInVzZVBhZ2VIaWRlIiwic2Nyb2xsWSIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXNzaW9uUG9zaXRpb25zIiwiZ2V0SXRlbSIsInBhcnNlIiwiZ2V0S2V5V2l0aG91dEJhc2VuYW1lIiwiZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJzY3JvbGxUbyIsImVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzY3JvbGxJbnRvVmlldyIsInVzZUJlZm9yZVVubG9hZCIsImNhbGxiYWNrIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXNlUHJvbXB0IiwiX3JlZjgiLCJ3aGVuIiwiYmxvY2tlciIsInVuc3RhYmxlX3VzZUJsb2NrZXIiLCJwcm9jZWVkIiwiY29uZmlybSIsInNldFRpbWVvdXQiLCJyZXNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///72\n')},1807:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fg: () => (/* binding */ Navigate),\n/* harmony export */   TH: () => (/* binding */ useLocation),\n/* harmony export */   UO: () => (/* binding */ useParams),\n/* harmony export */   Us: () => (/* binding */ NavigationContext),\n/* harmony export */   WU: () => (/* binding */ useResolvedPath),\n/* harmony export */   bS: () => (/* binding */ useMatch),\n/* harmony export */   j3: () => (/* binding */ Outlet),\n/* harmony export */   oQ: () => (/* binding */ useHref),\n/* harmony export */   pG: () => (/* binding */ RouterProvider),\n/* harmony export */   s0: () => (/* binding */ useNavigate),\n/* harmony export */   us: () => (/* binding */ mapRouteProperties)\n/* harmony export */ });\n/* unused harmony exports Await, MemoryRouter, Route, Router, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_RouteContext, UNSAFE_useRouteId, UNSAFE_useRoutesImpl, createMemoryRouter, createRoutesFromChildren, createRoutesFromElements, renderMatches, unstable_useBlocker, useActionData, useAsyncError, useAsyncValue, useInRouterContext, useLoaderData, useMatches, useNavigation, useNavigationType, useOutlet, useOutletContext, useRevalidator, useRouteError, useRouteLoaderData, useRoutes */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5466);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1300);\n/* provided dependency */ var console = __webpack_require__(1283);\n/**\n * React Router v6.16.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (false) {}\nconst DataRouterStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (false) {}\nconst AwaitContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (false) {}\n\n/**\n * A Navigator is a "location changer"; it\'s how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid "tearing" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\n\nconst NavigationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (false) {}\nconst LocationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (false) {}\nconst RouteContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (false) {}\nconst RouteErrorContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (false) {}\n\n/**\n * Returns the full href for the given "to" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n\n  // If we\'re operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== "/") {\n    joinedPathname = pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you\'re using this it may mean you\'re doing some of your own\n * "routing" in your app, and we\'d like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nfunction useLocation() {\n  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know "active" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nfunction useMatch(pattern) {\n  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .matchPath */ .LX)(pattern, pathname), [pathname, pattern]);\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\nconst navigateEffectWarning = (/* unused pure expression or super */ null && ("You should call navigate() in a React.useEffect(), not when " + "your component is first rendered."));\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  let {\n    basename,\n    navigator\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_getPathContributingMatches */ .Zq)(matches).map(match => match.pathnameBase));\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n     false ? 0 : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven\'t wired up our history listener yet\n    if (!activeRef.current) return;\n    if (typeof to === "number") {\n      navigator.go(to);\n      return;\n    }\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .resolveTo */ .pC)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");\n\n    // If we\'re operating within a basename, prepend it to the pathname prior\n    // to handing off to history (but only if we\'re not in a data router,\n    // otherwise it\'ll prepend the basename inside of the router).\n    // If this is a root navigation, then we navigate to the raw basename\n    // which allows the basename to have full control over the presence of a\n    // trailing slash on root links\n    if (dataRouterContext == null && basename !== "/") {\n      path.pathname = path.pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nfunction useOutlet(context) {\n  let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nfunction useParams() {\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_getPathContributingMatches */ .Zq)(matches).map(match => match.pathnameBase));\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .resolveTo */ .pC)(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route\'s\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState) {\n  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  let {\n    navigator\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : "/";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (false) {}\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === "string" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(locationArg) : locationArg;\n    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || "/";\n  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";\n  let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .matchRoutes */ .fp)(routes, {\n    pathname: remainingPathname\n  });\n  if (false) {}\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n  })), parentMatches, dataRouterState);\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: "/",\n          search: "",\n          hash: "",\n          state: null,\n          key: "default"\n        }, location),\n        navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .Action */ .aU.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .isRouteErrorResponse */ .WK)(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = "rgba(200,200,200, 0.5)";\n  let preStyles = {\n    padding: "0.5rem",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: "2px 4px",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (false) {}\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h2", null, "Unexpected Application Error!"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", {\n    style: {\n      fontStyle: "italic"\n    }\n  }, message), stack ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("pre", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click "back" to the\n    // previous page that didn\'t have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we\'re in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n\n    // If we\'re not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error("React Router caught the following error during render", error, errorInfo);\n  }\n  render() {\n    return this.state.error ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n}\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      // Don\'t bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;\n    // Only data routers handle errors\n    let errorElement = null;\n    if (dataRouterState) {\n      errorElement = match.route.errorElement || defaultErrorElement;\n    }\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won\'t re-use the\n        // ReactElement since it\'s identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n        match: match,\n        routeContext: {\n          outlet,\n          matches,\n          isDataRoute: dataRouterState != null\n        },\n        children: children\n      });\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error: error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n  DataRouterHook["UseBlocker"] = "useBlocker";\n  DataRouterHook["UseRevalidator"] = "useRevalidator";\n  DataRouterHook["UseNavigateStable"] = "useNavigate";\n  return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n  DataRouterStateHook["UseBlocker"] = "useBlocker";\n  DataRouterStateHook["UseLoaderData"] = "useLoaderData";\n  DataRouterStateHook["UseActionData"] = "useActionData";\n  DataRouterStateHook["UseRouteError"] = "useRouteError";\n  DataRouterStateHook["UseNavigation"] = "useNavigation";\n  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";\n  DataRouterStateHook["UseMatches"] = "useMatches";\n  DataRouterStateHook["UseRevalidator"] = "useRevalidator";\n  DataRouterStateHook["UseNavigateStable"] = "useNavigate";\n  DataRouterStateHook["UseRouteId"] = "useRouteId";\n  return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  !ctx ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n  !state ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  !route ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an "idle" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return React.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route "handle" property\n */\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map(m => UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let route = React.useContext(RouteContext);\n  !route ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n  return Object.values((state == null ? void 0 : state.actionData) || {})[0];\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n  var _state$errors;\n  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState("");\n  let blockerFunction = React.useCallback(arg => {\n    if (typeof shouldBlock !== "function") {\n      return !!shouldBlock;\n    }\n    if (basename === "/") {\n      return shouldBlock(arg);\n    }\n\n    // If they provided us a function and we\'ve got an active basename, strip\n    // it from the locations we expose to the user to match the behavior of\n    // useLocation\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don\'t get an orphaned blockerFunction in the router with a\n  // key of "".  Until then we just have the IDLE_BLOCKER.\n  React.useEffect(() => {\n    if (blockerKey !== "") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n     false ? 0 : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven\'t wired up our router subscriber yet\n    if (!activeRef.current) return;\n    if (typeof to === "number") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n     false ? 0 : void 0;\n  }\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn\'t exist in `React`:\n  * import { startTransition } from "react"\n  * import * as React from from "react";\n    "startTransition" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from "react";\n    "startTransition" in React ? React["startTransition"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from "react";\n    const START_TRANSITION = "startTransition";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = "startTransition";\nconst startTransitionImpl = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || "/";\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n\n  // The fragment and {null} here are important!  We need them to keep React 18\'s\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id\'s\n  // so we need to ensure it remains the same on the client even though\n  // we don\'t need the <script> tag\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator\n  }, state.initialized ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n    routes: router.routes,\n    state: state\n  }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n  let {\n    routes,\n    state\n  } = _ref2;\n  return useRoutesImpl(routes, undefined, state);\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n   false ? 0 : void 0;\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .resolveTo */ .pC)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_getPathContributingMatches */ .Zq)(matches).map(match => match.pathnameBase), locationPathname, relative === "path");\n  let jsonPath = JSON.stringify(path);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\n/**\n * Renders the child route\'s element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nfunction Route(_props) {\n   false ? 0 : UNSAFE_invariant(false);\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won\'t render a <Router> directly. Instead, you\'ll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = "/",\n    children = null,\n    location: locationProp,\n    navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .Action */ .aU.Pop,\n    navigator,\n    static: staticProp = false\n  } = _ref5;\n  !!useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, "/");\n  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp\n  }), [basename, navigator, staticProp]);\n  if (typeof locationProp === "string") {\n    locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(locationProp);\n  }\n  let {\n    pathname = "/",\n    search = "",\n    hash = "",\n    state = null,\n    key = "default"\n  } = locationProp;\n  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .stripBasename */ .Zn)(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n   false ? 0 : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n    children: children,\n    value: locationContext\n  }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";\n  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";\n  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";\n  return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(() => {});\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error("<Await> caught the following error during render", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      // Didn\'t get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, "_tracked", {\n        get: () => true\n      });\n      Object.defineProperty(promise, "_data", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, "_tracked", {\n        get: () => true\n      });\n      Object.defineProperty(promise, "_error", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, "_tracked", {\n        get: () => true\n      });\n      promise = resolve.then(data => Object.defineProperty(resolve, "_data", {\n        get: () => data\n      }), error => Object.defineProperty(resolve, "_error", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .AbortedDeferredError */ .X3) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: children\n      });\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === "function" ? children(data) : children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React "children" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (! /*#__PURE__*/React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ?  false ? 0 : UNSAFE_invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join("-"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (false) {}\n    Object.assign(updates, {\n      element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n      Component: undefined\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (false) {}\n    Object.assign(updates, {\n      errorElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties\n  }).initialize();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFKLGdCQUFBQSxJQUFJLENBQUV3RSxhQUFhO0lBQ2xDeE8sTUFBTTtJQUNObU87RUFDRixDQUFDLENBQUMsQ0FBQ00sVUFBVSxFQUFFO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi4vbGliL2NvbnRleHQudHM/YTJkYiIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uLi9saWIvaG9va3MudHN4PzdjM2MiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi4vbGliL2NvbXBvbmVudHMudHN4PzM1YTMiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi4vaW5kZXgudHM/NzhiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0LFxuICBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3QsXG4gIEFnbm9zdGljUm91dGVNYXRjaCxcbiAgSGlzdG9yeSxcbiAgTGF6eVJvdXRlRnVuY3Rpb24sXG4gIExvY2F0aW9uLFxuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlcixcbiAgU3RhdGljSGFuZGxlckNvbnRleHQsXG4gIFRvLFxuICBUcmFja2VkUHJvbWlzZSxcbn0gZnJvbSBcIkByZW1peC1ydW4vcm91dGVyXCI7XG5cbi8vIENyZWF0ZSByZWFjdC1zcGVjaWZpYyB0eXBlcyBmcm9tIHRoZSBhZ25vc3RpYyB0eXBlcyBpbiBAcmVtaXgtcnVuL3JvdXRlciB0b1xuLy8gZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4Um91dGVPYmplY3Qge1xuICBjYXNlU2Vuc2l0aXZlPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wiY2FzZVNlbnNpdGl2ZVwiXTtcbiAgcGF0aD86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcInBhdGhcIl07XG4gIGlkPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wiaWRcIl07XG4gIGxvYWRlcj86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImxvYWRlclwiXTtcbiAgYWN0aW9uPzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wiYWN0aW9uXCJdO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0W1wiaGFzRXJyb3JCb3VuZGFyeVwiXTtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcInNob3VsZFJldmFsaWRhdGVcIl07XG4gIGhhbmRsZT86IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFtcImhhbmRsZVwiXTtcbiAgaW5kZXg6IHRydWU7XG4gIGNoaWxkcmVuPzogdW5kZWZpbmVkO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgQ29tcG9uZW50PzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIEVycm9yQm91bmRhcnk/OiBSZWFjdC5Db21wb25lbnRUeXBlIHwgbnVsbDtcbiAgbGF6eT86IExhenlSb3V0ZUZ1bmN0aW9uPFJvdXRlT2JqZWN0Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb25JbmRleFJvdXRlT2JqZWN0IHtcbiAgY2FzZVNlbnNpdGl2ZT86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcImNhc2VTZW5zaXRpdmVcIl07XG4gIHBhdGg/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJwYXRoXCJdO1xuICBpZD86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcImlkXCJdO1xuICBsb2FkZXI/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJsb2FkZXJcIl07XG4gIGFjdGlvbj86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcImFjdGlvblwiXTtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdFtcImhhc0Vycm9yQm91bmRhcnlcIl07XG4gIHNob3VsZFJldmFsaWRhdGU/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJzaG91bGRSZXZhbGlkYXRlXCJdO1xuICBoYW5kbGU/OiBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3RbXCJoYW5kbGVcIl07XG4gIGluZGV4PzogZmFsc2U7XG4gIGNoaWxkcmVuPzogUm91dGVPYmplY3RbXTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIENvbXBvbmVudD86IFJlYWN0LkNvbXBvbmVudFR5cGUgfCBudWxsO1xuICBFcnJvckJvdW5kYXJ5PzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIGxhenk/OiBMYXp5Um91dGVGdW5jdGlvbjxSb3V0ZU9iamVjdD47XG59XG5cbmV4cG9ydCB0eXBlIFJvdXRlT2JqZWN0ID0gSW5kZXhSb3V0ZU9iamVjdCB8IE5vbkluZGV4Um91dGVPYmplY3Q7XG5cbmV4cG9ydCB0eXBlIERhdGFSb3V0ZU9iamVjdCA9IFJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IERhdGFSb3V0ZU9iamVjdFtdO1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgUm91dGVPYmplY3QgPSBSb3V0ZU9iamVjdFxuPiBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFSb3V0ZU1hdGNoIGV4dGVuZHMgUm91dGVNYXRjaDxzdHJpbmcsIERhdGFSb3V0ZU9iamVjdD4ge31cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhUm91dGVyQ29udGV4dE9iamVjdCBleHRlbmRzIE5hdmlnYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgcm91dGVyOiBSb3V0ZXI7XG4gIHN0YXRpY0NvbnRleHQ/OiBTdGF0aWNIYW5kbGVyQ29udGV4dDtcbn1cblxuZXhwb3J0IGNvbnN0IERhdGFSb3V0ZXJDb250ZXh0ID1cbiAgUmVhY3QuY3JlYXRlQ29udGV4dDxEYXRhUm91dGVyQ29udGV4dE9iamVjdCB8IG51bGw+KG51bGwpO1xuaWYgKF9fREVWX18pIHtcbiAgRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbn1cblxuZXhwb3J0IGNvbnN0IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFxuICBSb3V0ZXJbXCJzdGF0ZVwiXSB8IG51bGxcbj4obnVsbCk7XG5pZiAoX19ERVZfXykge1xuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyU3RhdGVcIjtcbn1cblxuZXhwb3J0IGNvbnN0IEF3YWl0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8VHJhY2tlZFByb21pc2UgfCBudWxsPihudWxsKTtcbmlmIChfX0RFVl9fKSB7XG4gIEF3YWl0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXdhaXRcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZU9wdGlvbnMge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbn1cblxuLyoqXG4gKiBBIE5hdmlnYXRvciBpcyBhIFwibG9jYXRpb24gY2hhbmdlclwiOyBpdCdzIGhvdyB5b3UgZ2V0IHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gKlxuICogRXZlcnkgaGlzdG9yeSBpbnN0YW5jZSBjb25mb3JtcyB0byB0aGUgTmF2aWdhdG9yIGludGVyZmFjZSwgYnV0IHRoZVxuICogZGlzdGluY3Rpb24gaXMgdXNlZnVsIHByaW1hcmlseSB3aGVuIGl0IGNvbWVzIHRvIHRoZSBsb3ctbGV2ZWwgPFJvdXRlcj4gQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0b3Ige1xuICBjcmVhdGVIcmVmOiBIaXN0b3J5W1wiY3JlYXRlSHJlZlwiXTtcbiAgLy8gT3B0aW9uYWwgZm9yIGJhY2t3YXJkcy1jb21wYXQgd2l0aCBSb3V0ZXIvSGlzdG9yeVJvdXRlciB1c2FnZSAoZWRnZSBjYXNlKVxuICBlbmNvZGVMb2NhdGlvbj86IEhpc3RvcnlbXCJlbmNvZGVMb2NhdGlvblwiXTtcbiAgZ286IEhpc3RvcnlbXCJnb1wiXTtcbiAgcHVzaCh0bzogVG8sIHN0YXRlPzogYW55LCBvcHRzPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbiAgcmVwbGFjZSh0bzogVG8sIHN0YXRlPzogYW55LCBvcHRzPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIE5hdmlnYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgYmFzZW5hbWU6IHN0cmluZztcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IE5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOYXZpZ2F0aW9uQ29udGV4dE9iamVjdD4oXG4gIG51bGwhXG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuXG5pbnRlcmZhY2UgTG9jYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xuICBuYXZpZ2F0aW9uVHlwZTogTmF2aWdhdGlvblR5cGU7XG59XG5cbmV4cG9ydCBjb25zdCBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PExvY2F0aW9uQ29udGV4dE9iamVjdD4oXG4gIG51bGwhXG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVDb250ZXh0T2JqZWN0IHtcbiAgb3V0bGV0OiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsO1xuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW107XG4gIGlzRGF0YVJvdXRlOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgUm91dGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxSb3V0ZUNvbnRleHRPYmplY3Q+KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbiAgaXNEYXRhUm91dGU6IGZhbHNlLFxufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cblxuZXhwb3J0IGNvbnN0IFJvdXRlRXJyb3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxhbnk+KG51bGwpO1xuXG5pZiAoX19ERVZfXykge1xuICBSb3V0ZUVycm9yQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVFcnJvclwiO1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEJsb2NrZXIsXG4gIEJsb2NrZXJGdW5jdGlvbixcbiAgTG9jYXRpb24sXG4gIFBhcmFtUGFyc2VLZXksXG4gIFBhcmFtcyxcbiAgUGF0aCxcbiAgUGF0aE1hdGNoLFxuICBQYXRoUGF0dGVybixcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxuICBSZXZhbGlkYXRpb25TdGF0ZSxcbiAgVG8sXG4gIFVJTWF0Y2gsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgSURMRV9CTE9DS0VSLFxuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCBhcyBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCxcbiAgVU5TQUZFX2dldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIGFzIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzLFxuICBVTlNBRkVfaW52YXJpYW50IGFzIGludmFyaWFudCxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGpvaW5QYXRocyxcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZXNvbHZlVG8sXG4gIHN0cmlwQmFzZW5hbWUsXG4gIFVOU0FGRV93YXJuaW5nIGFzIHdhcm5pbmcsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU1hdGNoLFxuICBOYXZpZ2F0ZU9wdGlvbnMsXG4gIFJvdXRlQ29udGV4dE9iamVjdCxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG59IGZyb20gXCIuL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIEF3YWl0Q29udGV4dCxcbiAgRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCxcbiAgTmF2aWdhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCxcbiAgUm91dGVFcnJvckNvbnRleHQsXG59IGZyb20gXCIuL2NvbnRleHRcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaHJlZlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSHJlZihcbiAgdG86IFRvLFxuICB7IHJlbGF0aXZlIH06IHsgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG5cbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xuICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPVxuICAgICAgcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHsgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhIDxSb3V0ZXI+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWluLXJvdXRlci1jb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBVUkwgaW4gd2ViXG4gKiBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBJZiB5b3UncmUgdXNpbmcgdGhpcyBpdCBtYXkgbWVhbiB5b3UncmUgZG9pbmcgc29tZSBvZiB5b3VyIG93blxuICogXCJyb3V0aW5nXCIgaW4geW91ciBhcHAsIGFuZCB3ZSdkIGxpa2UgdG8ga25vdyB3aGF0IHlvdXIgdXNlIGNhc2UgaXMuIFdlIG1heVxuICogYmUgYWJsZSB0byBwcm92aWRlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdG8gYmV0dGVyIHN1aXQgeW91ciBuZWVkcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1sb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYXRpb24oKTogTG9jYXRpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0aW9uLXR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCk6IE5hdmlnYXRpb25UeXBlIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUGF0aE1hdGNoIG9iamVjdCBpZiB0aGUgZ2l2ZW4gcGF0dGVybiBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIDxOYXZMaW5rPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1tYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgpOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aDxQYXJhbUtleSwgUGF0aD4ocGF0dGVybiwgcGF0aG5hbWUpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVGdW5jdGlvbiB7XG4gICh0bzogVG8sIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICAoZGVsdGE6IG51bWJlcik6IHZvaWQ7XG59XG5cbmNvbnN0IG5hdmlnYXRlRWZmZWN0V2FybmluZyA9XG4gIGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBgICtcbiAgYHlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLmA7XG5cbi8vIE11dGUgd2FybmluZ3MgZm9yIGNhbGxzIHRvIHVzZU5hdmlnYXRlIGluIFNTUiBlbnZpcm9ubWVudHNcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoXG4gIGNiOiBQYXJhbWV0ZXJzPHR5cGVvZiBSZWFjdC51c2VMYXlvdXRFZmZlY3Q+WzBdXG4pIHtcbiAgbGV0IGlzU3RhdGljID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgLy8gV2Ugc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG9uY2UgcmVhY3QgMTguMyBpcyByZWxlYXNlZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoY2IpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBpbXBlcmF0aXZlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGxvY2F0aW9uLiBVc2VkIGJ5IDxMaW5rPnMsIGJ1dFxuICogbWF5IGFsc28gYmUgdXNlZCBieSBvdGhlciBlbGVtZW50cyB0byBjaGFuZ2UgdGhlIGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpOiBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgbGV0IHsgaXNEYXRhUm91dGUgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcbn1cblxuZnVuY3Rpb24gdXNlTmF2aWdhdGVVbnN0YWJsZSgpOiBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFxuICAgIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpLm1hcCgobWF0Y2gpID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgbmF2aWdhdGU6IE5hdmlnYXRlRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodG86IFRvIHwgbnVtYmVyLCBvcHRpb25zOiBOYXZpZ2F0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgaGlzdG9yeSBsaXN0ZW5lciB5ZXRcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKTtcblxuICAgICAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAgICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeSAoYnV0IG9ubHkgaWYgd2UncmUgbm90IGluIGEgZGF0YSByb3V0ZXIsXG4gICAgICAvLyBvdGhlcndpc2UgaXQnbGwgcHJlcGVuZCB0aGUgYmFzZW5hbWUgaW5zaWRlIG9mIHRoZSByb3V0ZXIpLlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiB3ZSBuYXZpZ2F0ZSB0byB0aGUgcmF3IGJhc2VuYW1lXG4gICAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGFcbiAgICAgIC8vIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCA9PSBudWxsICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID1cbiAgICAgICAgICBwYXRoLnBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICAgICAgPyBiYXNlbmFtZVxuICAgICAgICAgICAgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKFxuICAgICAgICBwYXRoLFxuICAgICAgICBvcHRpb25zLnN0YXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH0sXG4gICAgW1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBuYXZpZ2F0b3IsXG4gICAgICByb3V0ZVBhdGhuYW1lc0pzb24sXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgZGF0YVJvdXRlckNvbnRleHQsXG4gICAgXVxuICApO1xuXG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cblxuY29uc3QgT3V0bGV0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5rbm93bj4obnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldC1jb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0PENvbnRleHQgPSB1bmtub3duPigpOiBDb250ZXh0IHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCkgYXMgQ29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IDxPdXRsZXQ+IHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dD86IHVua25vd24pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPE91dGxldENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHR9PntvdXRsZXR9PC9PdXRsZXRDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnRcbiAqIFVSTCB0aGF0IHdlcmUgbWF0Y2hlZCBieSB0aGUgcm91dGUgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1wYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhcmFtczxcbiAgUGFyYW1zT3JLZXkgZXh0ZW5kcyBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gc3RyaW5nXG4+KCk6IFJlYWRvbmx5PFxuICBbUGFyYW1zT3JLZXldIGV4dGVuZHMgW3N0cmluZ10gPyBQYXJhbXM8UGFyYW1zT3JLZXk+IDogUGFydGlhbDxQYXJhbXNPcktleT5cbj4ge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IChyb3V0ZU1hdGNoLnBhcmFtcyBhcyBhbnkpIDoge307XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGhuYW1lIG9mIHRoZSBnaXZlbiBgdG9gIHZhbHVlIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcmVzb2x2ZWQtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKFxuICB0bzogVG8sXG4gIHsgcmVsYXRpdmUgfTogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pOiBQYXRoIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlKVxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgbG9jYXRpb25Bcmc/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZ1xuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcpO1xufVxuXG4vLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiB3aXRoIGFjY2VwdCBvcHRpb25hbCBwYXJhbSBmb3IgUm91dGVyUHJvdmlkZXIgdXNhZ2VcbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXNJbXBsKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGxvY2F0aW9uQXJnPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmcsXG4gIGRhdGFSb3V0ZXJTdGF0ZT86IFJlbWl4Um91dGVyW1wic3RhdGVcIl1cbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgLy8gd2l0aG91dCBhIHRyYWlsaW5nICosIGJ1dCB0aGlzIGlzIGEgYmVzdC1lZmZvcnQgd2FybmluZyBhbnl3YXkgc2luY2Ugd2VcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAvL1xuICAgIC8vIEV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8Um91dGVzPlxuICAgIC8vICAgey8qIFRoaXMgcm91dGUgcGF0aCBNVVNUIGVuZCB3aXRoIC8qIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nL2ZlZWRcIiBlbGVtZW50PXs8QmxvZ0ZlZWQgLz59IC8+XG4gICAgLy8gPC9Sb3V0ZXM+XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBCbG9nKCkge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAvLyAgICAgICA8Um91dGUgcGF0aD1cInBvc3QvOmlkXCIgZWxlbWVudD17PFBvc3QgLz59IC8+XG4gICAgLy8gICAgIDwvUm91dGVzPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgbGV0IHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLFxuICAgICAgYFlvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgXFxgdXNlUm91dGVzKClcXGApIGF0IGAgK1xuICAgICAgICBgXCIke3BhcmVudFBhdGhuYW1lfVwiICh1bmRlciA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4pIGJ1dCB0aGUgYCArXG4gICAgICAgIGBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGAgK1xuICAgICAgICBgZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgYCArXG4gICAgICAgIGByb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuYCArXG4gICAgICAgIGBQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+IHRvIDxSb3V0ZSBgICtcbiAgICAgICAgYHBhdGg9XCIke3BhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBgJHtwYXJlbnRQYXRofS8qYH1cIj4uYFxuICAgICk7XG4gIH1cblxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPVxuICAgICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fFxuICAgICAgICBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZT8uc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpLFxuICAgICAgYFdoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgXFxgPFJvdXRlcyBsb2NhdGlvbj5cXGAgb3IgXFxgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pXFxgLCBgICtcbiAgICAgICAgYHRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBgICtcbiAgICAgICAgYG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBgICtcbiAgICAgICAgYGJ1dCBwYXRobmFtZSBcIiR7cGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWV9XCIgd2FzIGdpdmVuIGluIHRoZSBcXGBsb2NhdGlvblxcYCBwcm9wLmBcbiAgICApO1xuXG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cblxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICA/IHBhdGhuYW1lXG4gICAgICA6IHBhdGhuYW1lLnNsaWNlKHBhcmVudFBhdGhuYW1lQmFzZS5sZW5ndGgpIHx8IFwiL1wiO1xuXG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7IHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSB9KTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5pbmcoXG4gICAgICBwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsXG4gICAgICBgTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBgXG4gICAgKTtcblxuICAgIHdhcm5pbmcoXG4gICAgICBtYXRjaGVzID09IG51bGwgfHxcbiAgICAgICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuQ29tcG9uZW50ICE9PSB1bmRlZmluZWQsXG4gICAgICBgTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgYCArXG4gICAgICAgIGBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIGAgK1xuICAgICAgICBgbnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcImVtcHR5XCIgcGFnZS5gXG4gICAgKTtcbiAgfVxuXG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhcbiAgICBtYXRjaGVzICYmXG4gICAgICBtYXRjaGVzLm1hcCgobWF0Y2gpID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbXG4gICAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgICAgICAgICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uXG4gICAgICAgICAgICAgID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZVxuICAgICAgICAgICAgICA6IG1hdGNoLnBhdGhuYW1lLFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHBhdGhuYW1lQmFzZTpcbiAgICAgICAgICAgIG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCJcbiAgICAgICAgICAgICAgPyBwYXJlbnRQYXRobmFtZUJhc2VcbiAgICAgICAgICAgICAgOiBqb2luUGF0aHMoW1xuICAgICAgICAgICAgICAgICAgcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgICAgICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lXG4gICAgICAgICAgICAgICAgICAgIDogbWF0Y2gucGF0aG5hbWVCYXNlLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzLFxuICAgIGRhdGFSb3V0ZXJTdGF0ZVxuICApO1xuXG4gIC8vIFdoZW4gYSB1c2VyIHBhc3NlcyBpbiBhIGBsb2NhdGlvbkFyZ2AsIHRoZSBhc3NvY2lhdGVkIHJvdXRlcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQgaW4gYSBuZXcgYExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcmAgaW4gb3JkZXIgZm9yIGB1c2VMb2NhdGlvbmBcbiAgLy8gdG8gdXNlIHRoZSBzY29wZWQgbG9jYXRpb24gaW5zdGVhZCBvZiB0aGUgZ2xvYmFsIGxvY2F0aW9uLlxuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICBsb2NhdGlvbjoge1xuICAgICAgICAgICAgcGF0aG5hbWU6IFwiL1wiLFxuICAgICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgICAgaGFzaDogXCJcIixcbiAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgICAga2V5OiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIC4uLmxvY2F0aW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF2aWdhdGlvblR5cGU6IE5hdmlnYXRpb25UeXBlLlBvcCxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge3JlbmRlcmVkTWF0Y2hlc31cbiAgICAgIDwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcilcbiAgICA/IGAke2Vycm9yLnN0YXR1c30gJHtlcnJvci5zdGF0dXNUZXh0fWBcbiAgICA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICA/IGVycm9yLm1lc3NhZ2VcbiAgICA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcbiAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICBsZXQgcHJlU3R5bGVzID0geyBwYWRkaW5nOiBcIjAuNXJlbVwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgY29kZVN0eWxlcyA9IHsgcGFkZGluZzogXCIycHggNHB4XCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG5cbiAgbGV0IGRldkluZm8gPSBudWxsO1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIkVycm9yIGhhbmRsZWQgYnkgUmVhY3QgUm91dGVyIGRlZmF1bHQgRXJyb3JCb3VuZGFyeTpcIixcbiAgICAgIGVycm9yXG4gICAgKTtcblxuICAgIGRldkluZm8gPSAoXG4gICAgICA8PlxuICAgICAgICA8cD7wn5K/IEhleSBkZXZlbG9wZXIg8J+RizwvcD5cbiAgICAgICAgPHA+XG4gICAgICAgICAgWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzXG4gICAgICAgICAgYnkgcHJvdmlkaW5nIHlvdXIgb3duIDxjb2RlIHN0eWxlPXtjb2RlU3R5bGVzfT5FcnJvckJvdW5kYXJ5PC9jb2RlPiBvcntcIiBcIn1cbiAgICAgICAgICA8Y29kZSBzdHlsZT17Y29kZVN0eWxlc30+ZXJyb3JFbGVtZW50PC9jb2RlPiBwcm9wIG9uIHlvdXIgcm91dGUuXG4gICAgICAgIDwvcD5cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8aDI+VW5leHBlY3RlZCBBcHBsaWNhdGlvbiBFcnJvciE8L2gyPlxuICAgICAgPGgzIHN0eWxlPXt7IGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9fT57bWVzc2FnZX08L2gzPlxuICAgICAge3N0YWNrID8gPHByZSBzdHlsZT17cHJlU3R5bGVzfT57c3RhY2t9PC9wcmU+IDogbnVsbH1cbiAgICAgIHtkZXZJbmZvfVxuICAgIDwvPlxuICApO1xufVxuXG5jb25zdCBkZWZhdWx0RXJyb3JFbGVtZW50ID0gPERlZmF1bHRFcnJvckNvbXBvbmVudCAvPjtcblxudHlwZSBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMgPSBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgcmV2YWxpZGF0aW9uOiBSZXZhbGlkYXRpb25TdGF0ZTtcbiAgZXJyb3I6IGFueTtcbiAgY29tcG9uZW50OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJvdXRlQ29udGV4dDogUm91dGVDb250ZXh0T2JqZWN0O1xufT47XG5cbnR5cGUgUmVuZGVyRXJyb3JCb3VuZGFyeVN0YXRlID0ge1xuICBsb2NhdGlvbjogTG9jYXRpb247XG4gIHJldmFsaWRhdGlvbjogUmV2YWxpZGF0aW9uU3RhdGU7XG4gIGVycm9yOiBhbnk7XG59O1xuXG5leHBvcnQgY2xhc3MgUmVuZGVyRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgUmVuZGVyRXJyb3JCb3VuZGFyeVByb3BzLFxuICBSZW5kZXJFcnJvckJvdW5kYXJ5U3RhdGVcbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogUmVuZGVyRXJyb3JCb3VuZGFyeVByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgIHByb3BzOiBSZW5kZXJFcnJvckJvdW5kYXJ5UHJvcHMsXG4gICAgc3RhdGU6IFJlbmRlckVycm9yQm91bmRhcnlTdGF0ZVxuICApIHtcbiAgICAvLyBXaGVuIHdlIGdldCBpbnRvIGFuIGVycm9yIHN0YXRlLCB0aGUgdXNlciB3aWxsIGxpa2VseSBjbGljayBcImJhY2tcIiB0byB0aGVcbiAgICAvLyBwcmV2aW91cyBwYWdlIHRoYXQgZGlkbid0IGhhdmUgYW4gZXJyb3IuIEJlY2F1c2UgdGhpcyB3cmFwcyB0aGUgZW50aXJlXG4gICAgLy8gYXBwbGljYXRpb24sIHRoYXQgd2lsbCBoYXZlIG5vIGVmZmVjdC0tdGhlIGVycm9yIHBhZ2UgY29udGludWVzIHRvIGRpc3BsYXkuXG4gICAgLy8gVGhpcyBnaXZlcyB1cyBhIG1lY2hhbmlzbSB0byByZWNvdmVyIGZyb20gdGhlIGVycm9yIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgLy9cbiAgICAvLyBXaGV0aGVyIHdlJ3JlIGluIGFuIGVycm9yIHN0YXRlIG9yIG5vdCwgd2UgdXBkYXRlIHRoZSBsb2NhdGlvbiBpbiBzdGF0ZVxuICAgIC8vIHNvIHRoYXQgd2hlbiB3ZSBhcmUgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGdldHMgcmVzZXQgd2hlbiBhIG5ldyBsb2NhdGlvblxuICAgIC8vIGNvbWVzIGluIGFuZCB0aGUgdXNlciByZWNvdmVycyBmcm9tIHRoZSBlcnJvci5cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHxcbiAgICAgIChzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XG4gICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgc3RhdGUuZXJyb3IsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24sXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yOiBhbnksIGVycm9ySW5mbzogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciA/IChcbiAgICAgIDxSb3V0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoaXMucHJvcHMucm91dGVDb250ZXh0fT5cbiAgICAgICAgPFJvdXRlRXJyb3JDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuZXJyb3J9XG4gICAgICAgICAgY2hpbGRyZW49e3RoaXMucHJvcHMuY29tcG9uZW50fVxuICAgICAgICAvPlxuICAgICAgPC9Sb3V0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKSA6IChcbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9XG59XG5cbmludGVyZmFjZSBSZW5kZXJlZFJvdXRlUHJvcHMge1xuICByb3V0ZUNvbnRleHQ6IFJvdXRlQ29udGV4dE9iamVjdDtcbiAgbWF0Y2g6IFJvdXRlTWF0Y2g8c3RyaW5nLCBSb3V0ZU9iamVjdD47XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKHsgcm91dGVDb250ZXh0LCBtYXRjaCwgY2hpbGRyZW4gfTogUmVuZGVyZWRSb3V0ZVByb3BzKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuXG4gIC8vIFRyYWNrIGhvdyBkZWVwIHdlIGdvdCBpbiBvdXIgcmVuZGVyIHBhc3MgdG8gZW11bGF0ZSBTU1IgY29tcG9uZW50RGlkQ2F0Y2hcbiAgLy8gaW4gYSBEYXRhU3RhdGljUm91dGVyXG4gIGlmIChcbiAgICBkYXRhUm91dGVyQ29udGV4dCAmJlxuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpYyAmJlxuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiZcbiAgICAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpXG4gICkge1xuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cm91dGVDb250ZXh0fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1JvdXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsLFxuICBwYXJlbnRNYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXSxcbiAgZGF0YVJvdXRlclN0YXRlOiBSZW1peFJvdXRlcltcInN0YXRlXCJdIHwgbnVsbCA9IG51bGxcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZT8uZXJyb3JzKSB7XG4gICAgICAvLyBEb24ndCBiYWlsIGlmIHdlIGhhdmUgZGF0YSByb3V0ZXIgZXJyb3JzIHNvIHdlIGNhbiByZW5kZXIgdGhlbSBpbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5LiAgVXNlIHRoZSBwcmUtbWF0Y2hlZCAob3Igc2hpbW1lZCkgbWF0Y2hlc1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzIGFzIERhdGFSb3V0ZU1hdGNoW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBtYXRjaGVzO1xuXG4gIC8vIElmIHdlIGhhdmUgZGF0YSBlcnJvcnMsIHRyaW0gbWF0Y2hlcyB0byB0aGUgaGlnaGVzdCBlcnJvciBib3VuZGFyeVxuICBsZXQgZXJyb3JzID0gZGF0YVJvdXRlclN0YXRlPy5lcnJvcnM7XG4gIGlmIChlcnJvcnMgIT0gbnVsbCkge1xuICAgIGxldCBlcnJvckluZGV4ID0gcmVuZGVyZWRNYXRjaGVzLmZpbmRJbmRleChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkICYmIGVycm9ycz8uW20ucm91dGUuaWRdXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBlcnJvckluZGV4ID49IDAsXG4gICAgICBgQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3V0ZSBmb3IgZXJyb3JzIG9uIHJvdXRlIElEczogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgZXJyb3JzXG4gICAgICApLmpvaW4oXCIsXCIpfWBcbiAgICApO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZXJyb3IgPSBtYXRjaC5yb3V0ZS5pZCA/IGVycm9ycz8uW21hdGNoLnJvdXRlLmlkXSA6IG51bGw7XG4gICAgLy8gT25seSBkYXRhIHJvdXRlcnMgaGFuZGxlIGVycm9yc1xuICAgIGxldCBlcnJvckVsZW1lbnQ6IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGwgPSBudWxsO1xuICAgIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgIH1cbiAgICBsZXQgbWF0Y2hlcyA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcbiAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICBsZXQgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBkZS1vcHRpbWl6ZWQgcGF0aCBzaW5jZSBSZWFjdCB3b24ndCByZS11c2UgdGhlXG4gICAgICAgIC8vIFJlYWN0RWxlbWVudCBzaW5jZSBpdCdzIGlkZW50aXR5IGNoYW5nZXMgd2l0aCBlYWNoIG5ld1xuICAgICAgICAvLyBSZWFjdC5jcmVhdGVFbGVtZW50IGNhbGwuICBXZSBrZWVwIHRoaXMgc28gZm9sa3MgY2FuIHVzZVxuICAgICAgICAvLyBgPFJvdXRlIENvbXBvbmVudD17Li4ufT5gIGluIGA8Um91dGVzPmAgYnV0IGdlbmVyYWxseSBgQ29tcG9uZW50YFxuICAgICAgICAvLyB1c2FnZSBpcyBvbmx5IGFkdmlzZWQgaW4gYFJvdXRlclByb3ZpZGVyYCB3aGVuIHdlIGNhbiBjb252ZXJ0IGl0IHRvXG4gICAgICAgIC8vIGBlbGVtZW50YCBhaGVhZCBvZiB0aW1lLlxuICAgICAgICBjaGlsZHJlbiA9IDxtYXRjaC5yb3V0ZS5Db21wb25lbnQgLz47XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBtYXRjaC5yb3V0ZS5lbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UmVuZGVyZWRSb3V0ZVxuICAgICAgICAgIG1hdGNoPXttYXRjaH1cbiAgICAgICAgICByb3V0ZUNvbnRleHQ9e3tcbiAgICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBpc0RhdGFSb3V0ZTogZGF0YVJvdXRlclN0YXRlICE9IG51bGwsXG4gICAgICAgICAgfX1cbiAgICAgICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH07XG4gICAgLy8gT25seSB3cmFwIGluIGFuIGVycm9yIGJvdW5kYXJ5IHdpdGhpbiBkYXRhIHJvdXRlciB1c2FnZXMgd2hlbiB3ZSBoYXZlIGFuXG4gICAgLy8gRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgb24gdGhpcyByb3V0ZS4gIE90aGVyd2lzZSBsZXQgaXQgYnViYmxlIHVwIHRvXG4gICAgLy8gYW4gYW5jZXN0b3IgRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnRcbiAgICByZXR1cm4gZGF0YVJvdXRlclN0YXRlICYmXG4gICAgICAobWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSB8fCBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gKFxuICAgICAgPFJlbmRlckVycm9yQm91bmRhcnlcbiAgICAgICAgbG9jYXRpb249e2RhdGFSb3V0ZXJTdGF0ZS5sb2NhdGlvbn1cbiAgICAgICAgcmV2YWxpZGF0aW9uPXtkYXRhUm91dGVyU3RhdGUucmV2YWxpZGF0aW9ufVxuICAgICAgICBjb21wb25lbnQ9e2Vycm9yRWxlbWVudH1cbiAgICAgICAgZXJyb3I9e2Vycm9yfVxuICAgICAgICBjaGlsZHJlbj17Z2V0Q2hpbGRyZW4oKX1cbiAgICAgICAgcm91dGVDb250ZXh0PXt7IG91dGxldDogbnVsbCwgbWF0Y2hlcywgaXNEYXRhUm91dGU6IHRydWUgfX1cbiAgICAgIC8+XG4gICAgKSA6IChcbiAgICAgIGdldENoaWxkcmVuKClcbiAgICApO1xuICB9LCBudWxsIGFzIFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwpO1xufVxuXG5lbnVtIERhdGFSb3V0ZXJIb29rIHtcbiAgVXNlQmxvY2tlciA9IFwidXNlQmxvY2tlclwiLFxuICBVc2VSZXZhbGlkYXRvciA9IFwidXNlUmV2YWxpZGF0b3JcIixcbiAgVXNlTmF2aWdhdGVTdGFibGUgPSBcInVzZU5hdmlnYXRlXCIsXG59XG5cbmVudW0gRGF0YVJvdXRlclN0YXRlSG9vayB7XG4gIFVzZUJsb2NrZXIgPSBcInVzZUJsb2NrZXJcIixcbiAgVXNlTG9hZGVyRGF0YSA9IFwidXNlTG9hZGVyRGF0YVwiLFxuICBVc2VBY3Rpb25EYXRhID0gXCJ1c2VBY3Rpb25EYXRhXCIsXG4gIFVzZVJvdXRlRXJyb3IgPSBcInVzZVJvdXRlRXJyb3JcIixcbiAgVXNlTmF2aWdhdGlvbiA9IFwidXNlTmF2aWdhdGlvblwiLFxuICBVc2VSb3V0ZUxvYWRlckRhdGEgPSBcInVzZVJvdXRlTG9hZGVyRGF0YVwiLFxuICBVc2VNYXRjaGVzID0gXCJ1c2VNYXRjaGVzXCIsXG4gIFVzZVJldmFsaWRhdG9yID0gXCJ1c2VSZXZhbGlkYXRvclwiLFxuICBVc2VOYXZpZ2F0ZVN0YWJsZSA9IFwidXNlTmF2aWdhdGVcIixcbiAgVXNlUm91dGVJZCA9IFwidXNlUm91dGVJZFwiLFxufVxuXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKFxuICBob29rTmFtZTogRGF0YVJvdXRlckhvb2sgfCBEYXRhUm91dGVyU3RhdGVIb29rXG4pIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLmA7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lOiBEYXRhUm91dGVySG9vaykge1xuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGludmFyaWFudChjdHgsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lOiBEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gcm91dGU7XG59XG5cbi8vIEludGVybmFsIHZlcnNpb24gd2l0aCBob29rTmFtZS1hd2FyZSBkZWJ1Z2dpbmdcbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lOiBEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGludmFyaWFudChcbiAgICB0aGlzUm91dGUucm91dGUuaWQsXG4gICAgYCR7aG9va05hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgSUQgZm9yIHRoZSBuZWFyZXN0IGNvbnRleHR1YWwgcm91dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlSWQoKSB7XG4gIHJldHVybiB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlSWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiwgZGVmYXVsdGluZyB0byBhbiBcImlkbGVcIiBuYXZpZ2F0aW9uIHdoZW5cbiAqIG5vIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRpb24pO1xuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmV2YWxpZGF0ZSBmdW5jdGlvbiBmb3IgbWFudWFsbHkgdHJpZ2dlcmluZyByZXZhbGlkYXRpb24sIGFzIHdlbGxcbiAqIGFzIHRoZSBjdXJyZW50IHN0YXRlIG9mIGFueSBtYW51YWwgcmV2YWxpZGF0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmV2YWxpZGF0b3IoKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgcmV2YWxpZGF0ZTogZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsXG4gICAgICBzdGF0ZTogc3RhdGUucmV2YWxpZGF0aW9uLFxuICAgIH0pLFxuICAgIFtkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSwgc3RhdGUucmV2YWxpZGF0aW9uXVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLCB1c2VmdWwgZm9yIGFjY2Vzc2luZyBsb2FkZXJEYXRhIGZvclxuICogcGFyZW50L2NoaWxkIHJvdXRlcyBvciB0aGUgcm91dGUgXCJoYW5kbGVcIiBwcm9wZXJ0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2hlcygpOiBVSU1hdGNoW10ge1xuICBsZXQgeyBtYXRjaGVzLCBsb2FkZXJEYXRhIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoXG4gICAgRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VNYXRjaGVzXG4gICk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksXG4gICAgW21hdGNoZXMsIGxvYWRlckRhdGFdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGxvYWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpOiB1bmtub3duIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcblxuICBpZiAoc3RhdGUuZXJyb3JzICYmIHN0YXRlLmVycm9yc1tyb3V0ZUlkXSAhPSBudWxsKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBZb3UgY2Fubm90IFxcYHVzZUxvYWRlckRhdGFcXGAgaW4gYW4gZXJyb3JFbGVtZW50IChyb3V0ZUlkOiAke3JvdXRlSWR9KWBcbiAgICApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyRGF0YSBmb3IgdGhlIGdpdmVuIHJvdXRlSWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkOiBzdHJpbmcpOiB1bmtub3duIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVMb2FkZXJEYXRhKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWN0aW9uIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGFjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpOiB1bmtub3duIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQWN0aW9uRGF0YSk7XG5cbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGUsIGB1c2VBY3Rpb25EYXRhIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRgKTtcblxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdGF0ZT8uYWN0aW9uRGF0YSB8fCB7fSlbMF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBlcnJvciwgd2hpY2ggY291bGQgYmUgYSBsb2FkZXIvYWN0aW9uXG4gKiBlcnJvciBvciBhIHJlbmRlciBlcnJvci4gIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGZyb20geW91clxuICogRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgdG8gZGlzcGxheSBhIHByb3BlciBlcnJvciBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVFcnJvcigpOiB1bmtub3duIHtcbiAgbGV0IGVycm9yID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUVycm9yQ29udGV4dCk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlRXJyb3IpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG5cbiAgLy8gSWYgdGhpcyB3YXMgYSByZW5kZXIgZXJyb3IsIHdlIHB1dCBpdCBpbiBhIFJvdXRlRXJyb3IgY29udGV4dCBpbnNpZGVcbiAgLy8gb2YgUmVuZGVyRXJyb3JCb3VuZGFyeVxuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBPdGhlcndpc2UgbG9vayBmb3IgZXJyb3JzIGZyb20gb3VyIGRhdGEgcm91dGVyIHN0YXRlXG4gIHJldHVybiBzdGF0ZS5lcnJvcnM/Lltyb3V0ZUlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYXBweS1wYXRoIGRhdGEgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciA8QXdhaXQgLz4gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKTogdW5rbm93biB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIDxBd2FpdCAvPiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpOiB1bmtub3duIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9lcnJvcjtcbn1cblxubGV0IGJsb2NrZXJJZCA9IDA7XG5cbi8qKlxuICogQWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGJsb2NrIG5hdmlnYXRpb25zIHdpdGhpbiB0aGUgU1BBIGFuZCBwcmVzZW50IHRoZVxuICogdXNlciBhIGNvbmZpcm1hdGlvbiBkaWFsb2cgdG8gY29uZmlybSB0aGUgbmF2aWdhdGlvbi4gIE1vc3RseSB1c2VkIHRvIGF2b2lkXG4gKiB1c2luZyBoYWxmLWZpbGxlZCBmb3JtIGRhdGEuICBUaGlzIGRvZXMgbm90IGhhbmRsZSBoYXJkLXJlbG9hZHMgb3JcbiAqIGNyb3NzLW9yaWdpbiBuYXZpZ2F0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2s6IGJvb2xlYW4gfCBCbG9ja2VyRnVuY3Rpb24pOiBCbG9ja2VyIHtcbiAgbGV0IHsgcm91dGVyLCBiYXNlbmFtZSB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlQmxvY2tlcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUJsb2NrZXIpO1xuXG4gIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdC51c2VTdGF0ZShcIlwiKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrPEJsb2NrZXJGdW5jdGlvbj4oXG4gICAgKGFyZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBzaG91bGRCbG9jayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAhIXNob3VsZEJsb2NrO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gc2hvdWxkQmxvY2soYXJnKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhleSBwcm92aWRlZCB1cyBhIGZ1bmN0aW9uIGFuZCB3ZSd2ZSBnb3QgYW4gYWN0aXZlIGJhc2VuYW1lLCBzdHJpcFxuICAgICAgLy8gaXQgZnJvbSB0aGUgbG9jYXRpb25zIHdlIGV4cG9zZSB0byB0aGUgdXNlciB0byBtYXRjaCB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgIC8vIHVzZUxvY2F0aW9uXG4gICAgICBsZXQgeyBjdXJyZW50TG9jYXRpb24sIG5leHRMb2NhdGlvbiwgaGlzdG9yeUFjdGlvbiB9ID0gYXJnO1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB7XG4gICAgICAgICAgLi4uY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOlxuICAgICAgICAgICAgc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fFxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICB9LFxuICAgICAgICBuZXh0TG9jYXRpb246IHtcbiAgICAgICAgICAuLi5uZXh0TG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWU6XG4gICAgICAgICAgICBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8XG4gICAgICAgICAgICBuZXh0TG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIGhpc3RvcnlBY3Rpb24sXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtiYXNlbmFtZSwgc2hvdWxkQmxvY2tdXG4gICk7XG5cbiAgLy8gVGhpcyBlZmZlY3QgaXMgaW4gY2hhcmdlIG9mIGJsb2NrZXIga2V5IGFzc2lnbm1lbnQgYW5kIGRlbGV0aW9uICh3aGljaCBpc1xuICAvLyB0aWdodGx5IGNvdXBsZWQgdG8gdGhlIGtleSlcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQga2V5ID0gU3RyaW5nKCsrYmxvY2tlcklkKTtcbiAgICBzZXRCbG9ja2VyS2V5KGtleSk7XG4gICAgcmV0dXJuICgpID0+IHJvdXRlci5kZWxldGVCbG9ja2VyKGtleSk7XG4gIH0sIFtyb3V0ZXJdKTtcblxuICAvLyBUaGlzIGVmZmVjdCBoYW5kbGVzIGFzc2lnbmluZyB0aGUgYmxvY2tlckZ1bmN0aW9uLiAgVGhpcyBpcyB0byBoYW5kbGVcbiAgLy8gdW5zdGFibGUgYmxvY2tlciBmdW5jdGlvbiBpZGVudGl0aWVzLCBhbmQgaGFwcGVucyBvbmx5IGFmdGVyIHRoZSBwcmlvclxuICAvLyBlZmZlY3Qgc28gd2UgZG9uJ3QgZ2V0IGFuIG9ycGhhbmVkIGJsb2NrZXJGdW5jdGlvbiBpbiB0aGUgcm91dGVyIHdpdGggYVxuICAvLyBrZXkgb2YgXCJcIi4gIFVudGlsIHRoZW4gd2UganVzdCBoYXZlIHRoZSBJRExFX0JMT0NLRVIuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXJLZXkgIT09IFwiXCIpIHtcbiAgICAgIHJvdXRlci5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XG4gICAgfVxuICB9LCBbcm91dGVyLCBibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dKTtcblxuICAvLyBQcmVmZXIgdGhlIGJsb2NrZXIgZnJvbSBgc3RhdGVgIG5vdCBgcm91dGVyLnN0YXRlYCBzaW5jZSBEYXRhUm91dGVyQ29udGV4dFxuICAvLyBpcyBtZW1vaXplZCBzbyB0aGlzIGVuc3VyZXMgd2UgdXBkYXRlIG9uIGJsb2NrZXIgc3RhdGUgdXBkYXRlc1xuICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSlcbiAgICA/IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KSFcbiAgICA6IElETEVfQkxPQ0tFUjtcbn1cblxuLyoqXG4gKiBTdGFibGUgdmVyc2lvbiBvZiB1c2VOYXZpZ2F0ZSB0aGF0IGlzIHVzZWQgd2hlbiB3ZSBhcmUgaW4gdGhlIGNvbnRleHQgb2ZcbiAqIGEgUm91dGVyUHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCk6IE5hdmlnYXRlRnVuY3Rpb24ge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcbiAgbGV0IGlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0ZVN0YWJsZSk7XG5cbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgbGV0IG5hdmlnYXRlOiBOYXZpZ2F0ZUZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRvOiBUbyB8IG51bWJlciwgb3B0aW9uczogTmF2aWdhdGVPcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZyk7XG5cbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaGVyZSBzaW5jZSBpZiB0aGlzIGhhcHBlbnMgb24gZmlyc3QgcmVuZGVyIHRoZSBuYXZpZ2F0ZVxuICAgICAgLy8gaXMgdXNlbGVzcyBiZWNhdXNlIHdlIGhhdmVuJ3Qgd2lyZWQgdXAgb3VyIHJvdXRlciBzdWJzY3JpYmVyIHlldFxuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8sIHsgZnJvbVJvdXRlSWQ6IGlkLCAuLi5vcHRpb25zIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlciwgaWRdXG4gICk7XG5cbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuXG5jb25zdCBhbHJlYWR5V2FybmVkOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXk6IHN0cmluZywgY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCAmJiAhYWxyZWFkeVdhcm5lZFtrZXldKSB7XG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUge1xuICBJbml0aWFsRW50cnksXG4gIExhenlSb3V0ZUZ1bmN0aW9uLFxuICBMb2NhdGlvbixcbiAgTWVtb3J5SGlzdG9yeSxcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbiAgUm91dGVyIGFzIFJlbWl4Um91dGVyLFxuICBSb3V0ZXJTdGF0ZSxcbiAgVG8sXG4gIFRyYWNrZWRQcm9taXNlLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIEFib3J0ZWREZWZlcnJlZEVycm9yLFxuICBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsXG4gIGNyZWF0ZU1lbW9yeUhpc3RvcnksXG4gIFVOU0FGRV9nZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyBhcyBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyxcbiAgVU5TQUZFX2ludmFyaWFudCBhcyBpbnZhcmlhbnQsXG4gIHBhcnNlUGF0aCxcbiAgcmVzb2x2ZVRvLFxuICBzdHJpcEJhc2VuYW1lLFxuICBVTlNBRkVfd2FybmluZyBhcyB3YXJuaW5nLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbn0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgQXdhaXRDb250ZXh0LFxuICBEYXRhUm91dGVyQ29udGV4dCxcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0LFxuICBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0LFxufSBmcm9tIFwiLi9jb250ZXh0XCI7XG5pbXBvcnQge1xuICBfcmVuZGVyTWF0Y2hlcyxcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUm91dGVzLFxuICB1c2VSb3V0ZXNJbXBsLFxufSBmcm9tIFwiLi9ob29rc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1dHVyZUNvbmZpZyB7XG4gIHY3X3N0YXJ0VHJhbnNpdGlvbjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm92aWRlclByb3BzIHtcbiAgZmFsbGJhY2tFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICByb3V0ZXI6IFJlbWl4Um91dGVyO1xuICBmdXR1cmU/OiBGdXR1cmVDb25maWc7XG59XG5cbi8qKlxuICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgY29tcGxhaW5zIHRoYXQgYHN0YXJ0VHJhbnNpdGlvbmAgZG9lc24ndCBleGlzdCBpbiBgUmVhY3RgOlxuICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIE1vdmluZyBpdCB0byBhIGNvbnN0YW50IHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBzb2x2ZXMgdGhlIFdlYnBhY2svUmVhY3QgMTcgaXNzdWU6XG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICBTVEFSVF9UUkFOU0lUSU9OIGluIFJlYWN0ID8gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uIGVudGlyZWx5IGZyb20gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHRlcm5hcnkuICBHcmFiYmluZ1xuICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuKi9cbmNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dO1xuXG4vKipcbiAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXJQcm92aWRlcih7XG4gIGZhbGxiYWNrRWxlbWVudCxcbiAgcm91dGVyLFxuICBmdXR1cmUsXG59OiBSb3V0ZXJQcm92aWRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgLy8gTmVlZCB0byB1c2UgYSBsYXlvdXQgZWZmZWN0IGhlcmUgc28gd2UgYXJlIHN1YnNjcmliZWQgZWFybHkgZW5vdWdoIHRvXG4gIC8vIHBpY2sgdXAgb24gYW55IHJlbmRlci1kcml2ZW4gcmVkaXJlY3RzL25hdmlnYXRpb25zICh1c2VFZmZlY3QvPE5hdmlnYXRlPilcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IFJvdXRlclN0YXRlKSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbFxuICAgICAgICA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSlcbiAgICAgICAgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXVxuICApO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG5cbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCk6IE5hdmlnYXRvciA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiAobikgPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZSwgb3B0cykgPT5cbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT5cbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgfSksXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcblxuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICByb3V0ZXIsXG4gICAgICBuYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgfSksXG4gICAgW3JvdXRlciwgbmF2aWdhdG9yLCBiYXNlbmFtZV1cbiAgKTtcblxuICAvLyBUaGUgZnJhZ21lbnQgYW5kIHtudWxsfSBoZXJlIGFyZSBpbXBvcnRhbnQhICBXZSBuZWVkIHRoZW0gdG8ga2VlcCBSZWFjdCAxOCdzXG4gIC8vIHVzZUlkIGhhcHB5IHdoZW4gd2UgYXJlIHNlcnZlci1yZW5kZXJpbmcgc2luY2Ugd2UgbWF5IGhhdmUgYSA8c2NyaXB0PiBoZXJlXG4gIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAvLyB1c2VJZCByZWxpZXMgb24gdGhlIGNvbXBvbmVudCB0cmVlIHN0cnVjdHVyZSB0byBnZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGlkJ3NcbiAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBvbiB0aGUgY2xpZW50IGV2ZW4gdGhvdWdoXG4gIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8RGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2RhdGFSb3V0ZXJDb250ZXh0fT5cbiAgICAgICAgPERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3N0YXRlfT5cbiAgICAgICAgICA8Um91dGVyXG4gICAgICAgICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICAgICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICAgICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuaGlzdG9yeUFjdGlvbn1cbiAgICAgICAgICAgIG5hdmlnYXRvcj17bmF2aWdhdG9yfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzdGF0ZS5pbml0aWFsaXplZCA/IChcbiAgICAgICAgICAgICAgPERhdGFSb3V0ZXMgcm91dGVzPXtyb3V0ZXIucm91dGVzfSBzdGF0ZT17c3RhdGV9IC8+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICBmYWxsYmFja0VsZW1lbnRcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9Sb3V0ZXI+XG4gICAgICAgIDwvRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICB7bnVsbH1cbiAgICA8Lz5cbiAgKTtcbn1cblxuZnVuY3Rpb24gRGF0YVJvdXRlcyh7XG4gIHJvdXRlcyxcbiAgc3RhdGUsXG59OiB7XG4gIHJvdXRlczogRGF0YVJvdXRlT2JqZWN0W107XG4gIHN0YXRlOiBSb3V0ZXJTdGF0ZTtcbn0pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICBmdXR1cmU/OiBGdXR1cmVDb25maWc7XG59XG5cbi8qKlxuICogQSA8Um91dGVyPiB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9tZW1vcnktcm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXgsXG4gIGZ1dHVyZSxcbn06IE1lbW9yeVJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8TWVtb3J5SGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IHsgYWN0aW9uOiBOYXZpZ2F0aW9uVHlwZTsgbG9jYXRpb246IExvY2F0aW9uIH0pID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsXG4gICAgICAgID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKVxuICAgICAgICA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVQcm9wcyB7XG4gIHRvOiBUbztcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBOb3RlOiBUaGlzIEFQSSBpcyBtb3N0bHkgdXNlZnVsIGluIFJlYWN0LkNvbXBvbmVudCBzdWJjbGFzc2VzIHRoYXQgYXJlIG5vdFxuICogYWJsZSB0byB1c2UgaG9va3MuIEluIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgdGhlXG4gKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5hdmlnYXRlKHtcbiAgdG8sXG4gIHJlcGxhY2UsXG4gIHN0YXRlLFxuICByZWxhdGl2ZSxcbn06IE5hdmlnYXRlUHJvcHMpOiBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICB3YXJuaW5nKFxuICAgICFSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gYCArXG4gICAgICBgVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIGAgK1xuICAgICAgYG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcblxuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuXG4gIC8vIFJlc29sdmUgdGhlIHBhdGggb3V0c2lkZSBvZiB0aGUgZWZmZWN0IHNvIHRoYXQgd2hlbiBlZmZlY3RzIHJ1biB0d2ljZSBpblxuICAvLyBTdHJpY3RNb2RlIHRoZXkgbmF2aWdhdGUgdG8gdGhlIHNhbWUgcGxhY2VcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8sXG4gICAgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlKSxcbiAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICApO1xuICBsZXQganNvblBhdGggPSBKU09OLnN0cmluZ2lmeShwYXRoKTtcblxuICBSZWFjdC51c2VFZmZlY3QoXG4gICAgKCkgPT4gbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHsgcmVwbGFjZSwgc3RhdGUsIHJlbGF0aXZlIH0pLFxuICAgIFtuYXZpZ2F0ZSwganNvblBhdGgsIHJlbGF0aXZlLCByZXBsYWNlLCBzdGF0ZV1cbiAgKTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdXRsZXRQcm9wcyB7XG4gIGNvbnRleHQ/OiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNoaWxkIHJvdXRlJ3MgZWxlbWVudCwgaWYgdGhlcmUgaXMgb25lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9vdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE91dGxldChwcm9wczogT3V0bGV0UHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXRoUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiY2FzZVNlbnNpdGl2ZVwiXTtcbiAgcGF0aD86IE5vbkluZGV4Um91dGVPYmplY3RbXCJwYXRoXCJdO1xuICBpZD86IE5vbkluZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbGF6eT86IExhenlSb3V0ZUZ1bmN0aW9uPE5vbkluZGV4Um91dGVPYmplY3Q+O1xuICBsb2FkZXI/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wiYWN0aW9uXCJdO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImhhc0Vycm9yQm91bmRhcnlcIl07XG4gIHNob3VsZFJldmFsaWRhdGU/OiBOb25JbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogTm9uSW5kZXhSb3V0ZU9iamVjdFtcImhhbmRsZVwiXTtcbiAgaW5kZXg/OiBmYWxzZTtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBlcnJvckVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBDb21wb25lbnQ/OiBSZWFjdC5Db21wb25lbnRUeXBlIHwgbnVsbDtcbiAgRXJyb3JCb3VuZGFyeT86IFJlYWN0LkNvbXBvbmVudFR5cGUgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExheW91dFJvdXRlUHJvcHMgZXh0ZW5kcyBQYXRoUm91dGVQcm9wcyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4Um91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBJbmRleFJvdXRlT2JqZWN0W1wiY2FzZVNlbnNpdGl2ZVwiXTtcbiAgcGF0aD86IEluZGV4Um91dGVPYmplY3RbXCJwYXRoXCJdO1xuICBpZD86IEluZGV4Um91dGVPYmplY3RbXCJpZFwiXTtcbiAgbGF6eT86IExhenlSb3V0ZUZ1bmN0aW9uPEluZGV4Um91dGVPYmplY3Q+O1xuICBsb2FkZXI/OiBJbmRleFJvdXRlT2JqZWN0W1wibG9hZGVyXCJdO1xuICBhY3Rpb24/OiBJbmRleFJvdXRlT2JqZWN0W1wiYWN0aW9uXCJdO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogSW5kZXhSb3V0ZU9iamVjdFtcImhhc0Vycm9yQm91bmRhcnlcIl07XG4gIHNob3VsZFJldmFsaWRhdGU/OiBJbmRleFJvdXRlT2JqZWN0W1wic2hvdWxkUmV2YWxpZGF0ZVwiXTtcbiAgaGFuZGxlPzogSW5kZXhSb3V0ZU9iamVjdFtcImhhbmRsZVwiXTtcbiAgaW5kZXg6IHRydWU7XG4gIGNoaWxkcmVuPzogdW5kZWZpbmVkO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgQ29tcG9uZW50PzogUmVhY3QuQ29tcG9uZW50VHlwZSB8IG51bGw7XG4gIEVycm9yQm91bmRhcnk/OiBSZWFjdC5Db21wb25lbnRUeXBlIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgUm91dGVQcm9wcyA9IFBhdGhSb3V0ZVByb3BzIHwgTGF5b3V0Um91dGVQcm9wcyB8IEluZGV4Um91dGVQcm9wcztcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlKF9wcm9wczogUm91dGVQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgYCArXG4gICAgICBgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb246IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xuICBuYXZpZ2F0aW9uVHlwZT86IE5hdmlnYXRpb25UeXBlO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIDxSb3V0ZXI+IGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgPEJyb3dzZXJSb3V0ZXI+XG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL3JvdXRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVyKHtcbiAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gIG5hdmlnYXRpb25UeXBlID0gTmF2aWdhdGlvblR5cGUuUG9wLFxuICBuYXZpZ2F0b3IsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlLFxufTogUm91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5gICtcbiAgICAgIGAgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuXG4gIC8vIFByZXNlcnZlIHRyYWlsaW5nIHNsYXNoZXMgb24gYmFzZW5hbWUsIHNvIHdlIGNhbiBsZXQgdGhlIHVzZXIgY29udHJvbFxuICAvLyB0aGUgZW5mb3JjZW1lbnQgb2YgdHJhaWxpbmcgc2xhc2hlcyB0aHJvdWdob3V0IHRoZSBhcHBcbiAgbGV0IGJhc2VuYW1lID0gYmFzZW5hbWVQcm9wLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7IGJhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpYzogc3RhdGljUHJvcCB9KSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF1cbiAgKTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG5cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiLFxuICB9ID0gbG9jYXRpb25Qcm9wO1xuXG4gIGxldCBsb2NhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAga2V5LFxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25UeXBlLFxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleSwgbmF2aWdhdGlvblR5cGVdKTtcblxuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBgICtcbiAgICAgIGBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYCArXG4gICAgICBgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuXG4gIGlmIChsb2NhdGlvbkNvbnRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25hdmlnYXRpb25Db250ZXh0fT5cbiAgICAgIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgY2hpbGRyZW49e2NoaWxkcmVufSB2YWx1ZT17bG9jYXRpb25Db250ZXh0fSAvPlxuICAgIDwvTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVzUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb24/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiA8Um91dGU+IGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXG4gKiB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXMoe1xuICBjaGlsZHJlbixcbiAgbG9jYXRpb24sXG59OiBSb3V0ZXNQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBd2FpdFJlc29sdmVSZW5kZXJGdW5jdGlvbiB7XG4gIChkYXRhOiBBd2FpdGVkPGFueT4pOiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXdhaXRQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfCBBd2FpdFJlc29sdmVSZW5kZXJGdW5jdGlvbjtcbiAgZXJyb3JFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICByZXNvbHZlOiBUcmFja2VkUHJvbWlzZSB8IGFueTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgdG8gdXNlIGZvciByZW5kZXJpbmcgbGF6aWx5IGxvYWRlZCBkYXRhIGZyb20gcmV0dXJuaW5nIGRlZmVyKClcbiAqIGluIGEgbG9hZGVyIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBd2FpdCh7IGNoaWxkcmVuLCBlcnJvckVsZW1lbnQsIHJlc29sdmUgfTogQXdhaXRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxBd2FpdEVycm9yQm91bmRhcnkgcmVzb2x2ZT17cmVzb2x2ZX0gZXJyb3JFbGVtZW50PXtlcnJvckVsZW1lbnR9PlxuICAgICAgPFJlc29sdmVBd2FpdD57Y2hpbGRyZW59PC9SZXNvbHZlQXdhaXQ+XG4gICAgPC9Bd2FpdEVycm9yQm91bmRhcnk+XG4gICk7XG59XG5cbnR5cGUgQXdhaXRFcnJvckJvdW5kYXJ5UHJvcHMgPSBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7XG4gIGVycm9yRWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgcmVzb2x2ZTogVHJhY2tlZFByb21pc2UgfCBhbnk7XG59PjtcblxudHlwZSBBd2FpdEVycm9yQm91bmRhcnlTdGF0ZSA9IHtcbiAgZXJyb3I6IGFueTtcbn07XG5cbmVudW0gQXdhaXRSZW5kZXJTdGF0dXMge1xuICBwZW5kaW5nLFxuICBzdWNjZXNzLFxuICBlcnJvcixcbn1cblxuY29uc3QgbmV2ZXJTZXR0bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcblxuY2xhc3MgQXdhaXRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBBd2FpdEVycm9yQm91bmRhcnlQcm9wcyxcbiAgQXdhaXRFcnJvckJvdW5kYXJ5U3RhdGVcbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogQXdhaXRFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZXJyb3I6IG51bGwgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cblxuICBjb21wb25lbnREaWRDYXRjaChlcnJvcjogYW55LCBlcnJvckluZm86IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IGNoaWxkcmVuLCBlcnJvckVsZW1lbnQsIHJlc29sdmUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBsZXQgcHJvbWlzZTogVHJhY2tlZFByb21pc2UgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgc3RhdHVzOiBBd2FpdFJlbmRlclN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG5cbiAgICBpZiAoIShyZXNvbHZlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIC8vIERpZG4ndCBnZXQgYSBwcm9taXNlIC0gcHJvdmlkZSBhcyBhIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3M7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiByZXNvbHZlIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgLy8gQ2F1Z2h0IGEgcmVuZGVyIGVycm9yLCBwcm92aWRlIGl0IGFzIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3I7XG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge30pOyAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uIHdhcm5pbmdzXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gcmVuZGVyRXJyb3IgfSk7XG4gICAgfSBlbHNlIGlmICgocmVzb2x2ZSBhcyBUcmFja2VkUHJvbWlzZSkuX3RyYWNrZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID1cbiAgICAgICAgcHJvbWlzZS5fZXJyb3IgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3JcbiAgICAgICAgICA6IHByb21pc2UuX2RhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzc1xuICAgICAgICAgIDogQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmF3ICh1bnRyYWNrZWQpIHByb21pc2UgLSB0cmFjayBpdFxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihcbiAgICAgICAgKGRhdGE6IGFueSkgPT5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YSB9KSxcbiAgICAgICAgKGVycm9yOiBhbnkpID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmXG4gICAgICBwcm9taXNlLl9lcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yXG4gICAgKSB7XG4gICAgICAvLyBGcmVlemUgdGhlIFVJIGJ5IHRocm93aW5nIGEgbmV2ZXIgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgdGhyb3cgbmV2ZXJTZXR0bGVkUHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICAvLyBObyBlcnJvckVsZW1lbnQsIHRocm93IHRvIHRoZSBuZWFyZXN0IHJvdXRlLWxldmVsIGVycm9yIGJvdW5kYXJ5XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcikge1xuICAgICAgLy8gUmVuZGVyIHZpYSBvdXIgZXJyb3JFbGVtZW50XG4gICAgICByZXR1cm4gPEF3YWl0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHJvbWlzZX0gY2hpbGRyZW49e2Vycm9yRWxlbWVudH0gLz47XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIHdpdGggcmVzb2x2ZWQgdmFsdWVcbiAgICAgIHJldHVybiA8QXdhaXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwcm9taXNlfSBjaGlsZHJlbj17Y2hpbGRyZW59IC8+O1xuICAgIH1cblxuICAgIC8vIFRocm93IHRvIHRoZSBzdXNwZW5zZSBib3VuZGFyeVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW5kaXJlY3Rpb24gdG8gbGV2ZXJhZ2UgdXNlQXN5bmNWYWx1ZSBmb3IgYSByZW5kZXItcHJvcCBBUEkgb24gPEF3YWl0PlxuICovXG5mdW5jdGlvbiBSZXNvbHZlQXdhaXQoe1xuICBjaGlsZHJlbixcbn06IHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB8IEF3YWl0UmVzb2x2ZVJlbmRlckZ1bmN0aW9uO1xufSkge1xuICBsZXQgZGF0YSA9IHVzZUFzeW5jVmFsdWUoKTtcbiAgbGV0IHRvUmVuZGVyID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihkYXRhKSA6IGNoaWxkcmVuO1xuICByZXR1cm4gPD57dG9SZW5kZXJ9PC8+O1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9jcmVhdGUtcm91dGVzLWZyb20tY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSxcbiAgcGFyZW50UGF0aDogbnVtYmVyW10gPSBbXVxuKTogUm91dGVPYmplY3RbXSB7XG4gIGxldCByb3V0ZXM6IFJvdXRlT2JqZWN0W10gPSBbXTtcblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBJZ25vcmUgbm9uLWVsZW1lbnRzLiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gbW9yZSBlYXNpbHkgaW5saW5lXG4gICAgICAvLyBjb25kaXRpb25hbHMgaW4gdGhlaXIgcm91dGUgY29uZmlnLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudChcbiAgICAgIGVsZW1lbnQudHlwZSA9PT0gUm91dGUsXG4gICAgICBgWyR7XG4gICAgICAgIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZVxuICAgICAgfV0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PmBcbiAgICApO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIWVsZW1lbnQucHJvcHMuaW5kZXggfHwgIWVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIlxuICAgICk7XG5cbiAgICBsZXQgcm91dGU6IFJvdXRlT2JqZWN0ID0ge1xuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgYWN0aW9uOiBlbGVtZW50LnByb3BzLmFjdGlvbixcbiAgICAgIGVycm9yRWxlbWVudDogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQsXG4gICAgICBFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnksXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OlxuICAgICAgICBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fFxuICAgICAgICBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCAhPSBudWxsLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZWxlbWVudC5wcm9wcy5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcbiAgICAgIGxhenk6IGVsZW1lbnQucHJvcHMubGF6eSxcbiAgICB9O1xuXG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICB0cmVlUGF0aFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGxcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgQWN0aW9uRnVuY3Rpb24sXG4gIEFjdGlvbkZ1bmN0aW9uQXJncyxcbiAgQmxvY2tlcixcbiAgQmxvY2tlckZ1bmN0aW9uLFxuICBFcnJvclJlc3BvbnNlLFxuICBGZXRjaGVyLFxuICBIeWRyYXRpb25TdGF0ZSxcbiAgSW5pdGlhbEVudHJ5LFxuICBKc29uRnVuY3Rpb24sXG4gIExhenlSb3V0ZUZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTmF2aWdhdGlvbixcbiAgUGFyYW1QYXJzZUtleSxcbiAgUGFyYW1zLFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhQYXR0ZXJuLFxuICBSZWRpcmVjdEZ1bmN0aW9uLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZXIgYXMgUmVtaXhSb3V0ZXIsXG4gIEZ1dHVyZUNvbmZpZyBhcyBSb3V0ZXJGdXR1cmVDb25maWcsXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbixcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyxcbiAgVG8sXG4gIFVJTWF0Y2gsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSxcbiAgY3JlYXRlTWVtb3J5SGlzdG9yeSxcbiAgY3JlYXRlUGF0aCxcbiAgY3JlYXRlUm91dGVyLFxuICBkZWZlcixcbiAgZ2VuZXJhdGVQYXRoLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAganNvbixcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudCxcbiAgcmVzb2x2ZVBhdGgsXG4gIFVOU0FGRV93YXJuaW5nIGFzIHdhcm5pbmcsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIEF3YWl0UHJvcHMsXG4gIEZ1dHVyZUNvbmZpZyxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgT3V0bGV0UHJvcHMsXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG59IGZyb20gXCIuL2xpYi9jb21wb25lbnRzXCI7XG5pbXBvcnQge1xuICBBd2FpdCxcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIHJlbmRlck1hdGNoZXMsXG59IGZyb20gXCIuL2xpYi9jb21wb25lbnRzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU1hdGNoLFxuICBEYXRhUm91dGVPYmplY3QsXG4gIEluZGV4Um91dGVPYmplY3QsXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbn0gZnJvbSBcIi4vbGliL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQsXG4gIE5hdmlnYXRpb25Db250ZXh0LFxuICBSb3V0ZUNvbnRleHQsXG59IGZyb20gXCIuL2xpYi9jb250ZXh0XCI7XG5pbXBvcnQgdHlwZSB7IE5hdmlnYXRlRnVuY3Rpb24gfSBmcm9tIFwiLi9saWIvaG9va3NcIjtcbmltcG9ydCB7XG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUJsb2NrZXIsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUlkLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlcyxcbiAgdXNlUm91dGVzSW1wbCxcbn0gZnJvbSBcIi4vbGliL2hvb2tzXCI7XG5cbi8vIEV4cG9ydGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYnV0IG5vdCBiZWluZyB1c2VkIGludGVybmFsbHkgYW55bW9yZVxudHlwZSBIYXNoID0gc3RyaW5nO1xudHlwZSBQYXRobmFtZSA9IHN0cmluZztcbnR5cGUgU2VhcmNoID0gc3RyaW5nO1xuXG4vLyBFeHBvc2UgcmVhY3Qtcm91dGVyIHB1YmxpYyBBUElcbmV4cG9ydCB0eXBlIHtcbiAgQWN0aW9uRnVuY3Rpb24sXG4gIEFjdGlvbkZ1bmN0aW9uQXJncyxcbiAgQXdhaXRQcm9wcyxcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgRXJyb3JSZXNwb25zZSxcbiAgRmV0Y2hlcixcbiAgRnV0dXJlQ29uZmlnLFxuICBIYXNoLFxuICBJbmRleFJvdXRlT2JqZWN0LFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIEpzb25GdW5jdGlvbixcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgTGF6eVJvdXRlRnVuY3Rpb24sXG4gIExvYWRlckZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbkFyZ3MsXG4gIExvY2F0aW9uLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVGdW5jdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBOYXZpZ2F0aW9uLFxuICBOYXZpZ2F0b3IsXG4gIE5vbkluZGV4Um91dGVPYmplY3QsXG4gIE91dGxldFByb3BzLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXJhbXMsXG4gIFBhdGgsXG4gIFBhdGhNYXRjaCxcbiAgUGF0aFBhdHRlcm4sXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBQYXRobmFtZSxcbiAgUmVkaXJlY3RGdW5jdGlvbixcbiAgUmVsYXRpdmVSb3V0aW5nVHlwZSxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG4gIFJvdXRlUHJvcHMsXG4gIFJvdXRlclByb3BzLFxuICBSb3V0ZXJQcm92aWRlclByb3BzLFxuICBSb3V0ZXNQcm9wcyxcbiAgU2VhcmNoLFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24sXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbkFyZ3MsXG4gIFRvLFxuICBVSU1hdGNoLFxuICBCbG9ja2VyIGFzIHVuc3RhYmxlX0Jsb2NrZXIsXG4gIEJsb2NrZXJGdW5jdGlvbiBhcyB1bnN0YWJsZV9CbG9ja2VyRnVuY3Rpb24sXG59O1xuZXhwb3J0IHtcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBhcyBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIGRlZmVyLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqc29uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZWRpcmVjdERvY3VtZW50LFxuICByZW5kZXJNYXRjaGVzLFxuICByZXNvbHZlUGF0aCxcbiAgdXNlQmxvY2tlciBhcyB1bnN0YWJsZV91c2VCbG9ja2VyLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG59O1xuXG5mdW5jdGlvbiBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGU6IFJvdXRlT2JqZWN0KSB7XG4gIGxldCB1cGRhdGVzOiBQYXJ0aWFsPFJvdXRlT2JqZWN0PiAmIHsgaGFzRXJyb3JCb3VuZGFyeTogYm9vbGVhbiB9ID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gIH07XG5cbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICtcbiAgICAgICAgICAgIFwiYENvbXBvbmVudGAgd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgQ29tcG9uZW50OiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAocm91dGUuZXJyb3JFbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgK1xuICAgICAgICAgICAgXCJgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZXJyb3JFbGVtZW50OiBSZWFjdC5jcmVhdGVFbGVtZW50KHJvdXRlLkVycm9yQm91bmRhcnkpLFxuICAgICAgRXJyb3JCb3VuZGFyeTogdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vcnlSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IHtcbiAgICBiYXNlbmFtZT86IHN0cmluZztcbiAgICBmdXR1cmU/OiBQYXJ0aWFsPE9taXQ8Um91dGVyRnV0dXJlQ29uZmlnLCBcInY3X3ByZXBlbmRCYXNlbmFtZVwiPj47XG4gICAgaHlkcmF0aW9uRGF0YT86IEh5ZHJhdGlvblN0YXRlO1xuICAgIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICB9XG4pOiBSZW1peFJvdXRlciB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IHtcbiAgICAgIC4uLm9wdHM/LmZ1dHVyZSxcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZSxcbiAgICB9LFxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHM/LmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzPy5pbml0aWFsSW5kZXgsXG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICB9KS5pbml0aWFsaXplKCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERBTkdFUiEgUExFQVNFIFJFQUQgTUUhXG4vLyBXZSBwcm92aWRlIHRoZXNlIGV4cG9ydHMgYXMgYW4gZXNjYXBlIGhhdGNoIGluIHRoZSBldmVudCB0aGF0IHlvdSBuZWVkIGFueVxuLy8gcm91dGluZyBkYXRhIHRoYXQgd2UgZG9uJ3QgcHJvdmlkZSBhbiBleHBsaWNpdCBBUEkgZm9yLiBXaXRoIHRoYXQgc2FpZCwgd2Vcbi8vIHdhbnQgdG8gY292ZXIgeW91ciB1c2UgY2FzZSBpZiB3ZSBjYW4sIHNvIGlmIHlvdSBmZWVsIHRoZSBuZWVkIHRvIHVzZSB0aGVzZVxuLy8gd2Ugd2FudCB0byBoZWFyIGZyb20geW91LiBMZXQgdXMga25vdyB3aGF0IHlvdSdyZSBidWlsZGluZyBhbmQgd2UnbGwgZG8gb3VyXG4vLyBiZXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gc3VwcG9ydCB5b3UhXG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlc2UgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIGRvIG5vdCBndWFyYW50ZWVcbi8vIGFnYWluc3QgYW55IGJyZWFraW5nIGNoYW5nZXMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNlbXZlciByZWxlYXNlLiBVc2Ugd2l0aFxuLy8gZXh0cmVtZSBjYXV0aW9uIGFuZCBvbmx5IGlmIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuIEdvZHNwZWVkLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQge1xuICBEYXRhUm91dGVyQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBOYXZpZ2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0LFxuICBtYXBSb3V0ZVByb3BlcnRpZXMgYXMgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgdXNlUm91dGVJZCBhcyBVTlNBRkVfdXNlUm91dGVJZCxcbiAgdXNlUm91dGVzSW1wbCBhcyBVTlNBRkVfdXNlUm91dGVzSW1wbCxcbn07XG4iXSwibmFtZXMiOlsiRGF0YVJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSIsIkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJBd2FpdENvbnRleHQiLCJOYXZpZ2F0aW9uQ29udGV4dCIsIkxvY2F0aW9uQ29udGV4dCIsIlJvdXRlQ29udGV4dCIsIm91dGxldCIsIm1hdGNoZXMiLCJpc0RhdGFSb3V0ZSIsIlJvdXRlRXJyb3JDb250ZXh0IiwidXNlSHJlZiIsInRvIiwiX3RlbXAiLCJyZWxhdGl2ZSIsInVzZUluUm91dGVyQ29udGV4dCIsIlVOU0FGRV9pbnZhcmlhbnQiLCJiYXNlbmFtZSIsIm5hdmlnYXRvciIsInVzZUNvbnRleHQiLCJoYXNoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJ1c2VSZXNvbHZlZFBhdGgiLCJqb2luZWRQYXRobmFtZSIsImpvaW5QYXRocyIsImNyZWF0ZUhyZWYiLCJ1c2VMb2NhdGlvbiIsImxvY2F0aW9uIiwidXNlTmF2aWdhdGlvblR5cGUiLCJuYXZpZ2F0aW9uVHlwZSIsInVzZU1hdGNoIiwicGF0dGVybiIsInVzZU1lbW8iLCJtYXRjaFBhdGgiLCJuYXZpZ2F0ZUVmZmVjdFdhcm5pbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY2IiLCJpc1N0YXRpYyIsInN0YXRpYyIsInVzZUxheW91dEVmZmVjdCIsInVzZU5hdmlnYXRlIiwidXNlTmF2aWdhdGVTdGFibGUiLCJ1c2VOYXZpZ2F0ZVVuc3RhYmxlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJsb2NhdGlvblBhdGhuYW1lIiwicm91dGVQYXRobmFtZXNKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIlVOU0FGRV9nZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyIsIm1hcCIsIm1hdGNoIiwicGF0aG5hbWVCYXNlIiwiYWN0aXZlUmVmIiwidXNlUmVmIiwiY3VycmVudCIsIm5hdmlnYXRlIiwidXNlQ2FsbGJhY2siLCJvcHRpb25zIiwiVU5TQUZFX3dhcm5pbmciLCJnbyIsInBhdGgiLCJyZXNvbHZlVG8iLCJwYXJzZSIsInJlcGxhY2UiLCJwdXNoIiwic3RhdGUiLCJPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZU91dGxldCIsImNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVBhcmFtcyIsInJvdXRlTWF0Y2giLCJsZW5ndGgiLCJwYXJhbXMiLCJfdGVtcDIiLCJ1c2VSb3V0ZXMiLCJyb3V0ZXMiLCJsb2NhdGlvbkFyZyIsInVzZVJvdXRlc0ltcGwiLCJkYXRhUm91dGVyU3RhdGUiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsInJvdXRlIiwicGFyZW50UGF0aCIsIndhcm5pbmdPbmNlIiwiZW5kc1dpdGgiLCJsb2NhdGlvbkZyb21Db250ZXh0IiwiX3BhcnNlZExvY2F0aW9uQXJnJHBhIiwicGFyc2VkTG9jYXRpb25BcmciLCJwYXJzZVBhdGgiLCJzdGFydHNXaXRoIiwicmVtYWluaW5nUGF0aG5hbWUiLCJzbGljZSIsIm1hdGNoUm91dGVzIiwiZWxlbWVudCIsInVuZGVmaW5lZCIsIkNvbXBvbmVudCIsInJlbmRlcmVkTWF0Y2hlcyIsIl9yZW5kZXJNYXRjaGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlTG9jYXRpb24iLCJfZXh0ZW5kcyIsImtleSIsIkFjdGlvbiIsIlBvcCIsIkRlZmF1bHRFcnJvckNvbXBvbmVudCIsImVycm9yIiwidXNlUm91dGVFcnJvciIsIm1lc3NhZ2UiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJFcnJvciIsInN0YWNrIiwibGlnaHRncmV5IiwicHJlU3R5bGVzIiwicGFkZGluZyIsImJhY2tncm91bmRDb2xvciIsImNvZGVTdHlsZXMiLCJkZXZJbmZvIiwiY29uc29sZSIsIkZyYWdtZW50Iiwic3R5bGUiLCJmb250U3R5bGUiLCJkZWZhdWx0RXJyb3JFbGVtZW50IiwiUmVuZGVyRXJyb3JCb3VuZGFyeSIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJyZXZhbGlkYXRpb24iLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnREaWRDYXRjaCIsImVycm9ySW5mbyIsInJlbmRlciIsInJvdXRlQ29udGV4dCIsImNoaWxkcmVuIiwiY29tcG9uZW50IiwiUmVuZGVyZWRSb3V0ZSIsIl9yZWYiLCJzdGF0aWNDb250ZXh0IiwiZXJyb3JFbGVtZW50IiwiRXJyb3JCb3VuZGFyeSIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaWQiLCJfZGF0YVJvdXRlclN0YXRlMiIsIl9kYXRhUm91dGVyU3RhdGUiLCJlcnJvcnMiLCJlcnJvckluZGV4IiwiZmluZEluZGV4IiwibSIsImtleXMiLCJqb2luIiwiTWF0aCIsIm1pbiIsInJlZHVjZVJpZ2h0IiwiaW5kZXgiLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwidXNlRGF0YVJvdXRlclN0YXRlIiwidXNlUm91dGVDb250ZXh0IiwidXNlQ3VycmVudFJvdXRlSWQiLCJ0aGlzUm91dGUiLCJ1c2VSb3V0ZUlkIiwiVXNlUm91dGVJZCIsInVzZU5hdmlnYXRpb24iLCJVc2VOYXZpZ2F0aW9uIiwibmF2aWdhdGlvbiIsInVzZVJldmFsaWRhdG9yIiwiVXNlUmV2YWxpZGF0b3IiLCJyZXZhbGlkYXRlIiwicm91dGVyIiwidXNlTWF0Y2hlcyIsImxvYWRlckRhdGEiLCJVc2VNYXRjaGVzIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwidXNlTG9hZGVyRGF0YSIsIlVzZUxvYWRlckRhdGEiLCJyb3V0ZUlkIiwidXNlUm91dGVMb2FkZXJEYXRhIiwiVXNlUm91dGVMb2FkZXJEYXRhIiwidXNlQWN0aW9uRGF0YSIsIlVzZUFjdGlvbkRhdGEiLCJ2YWx1ZXMiLCJhY3Rpb25EYXRhIiwiX3N0YXRlJGVycm9ycyIsIlVzZVJvdXRlRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwiX2RhdGEiLCJ1c2VBc3luY0Vycm9yIiwiX2Vycm9yIiwiYmxvY2tlcklkIiwidXNlQmxvY2tlciIsInNob3VsZEJsb2NrIiwiVXNlQmxvY2tlciIsImJsb2NrZXJLZXkiLCJzZXRCbG9ja2VyS2V5IiwidXNlU3RhdGUiLCJibG9ja2VyRnVuY3Rpb24iLCJhcmciLCJjdXJyZW50TG9jYXRpb24iLCJuZXh0TG9jYXRpb24iLCJoaXN0b3J5QWN0aW9uIiwic3RyaXBCYXNlbmFtZSIsInVzZUVmZmVjdCIsIlN0cmluZyIsImRlbGV0ZUJsb2NrZXIiLCJnZXRCbG9ja2VyIiwiYmxvY2tlcnMiLCJoYXMiLCJnZXQiLCJJRExFX0JMT0NLRVIiLCJVc2VOYXZpZ2F0ZVN0YWJsZSIsImZyb21Sb3V0ZUlkIiwiYWxyZWFkeVdhcm5lZCIsImNvbmQiLCJTVEFSVF9UUkFOU0lUSU9OIiwic3RhcnRUcmFuc2l0aW9uSW1wbCIsIlJvdXRlclByb3ZpZGVyIiwiZmFsbGJhY2tFbGVtZW50IiwiZnV0dXJlIiwic2V0U3RhdGVJbXBsIiwidjdfc3RhcnRUcmFuc2l0aW9uIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsInN1YnNjcmliZSIsIm4iLCJvcHRzIiwicHJldmVudFNjcm9sbFJlc2V0IiwiUm91dGVyIiwiaW5pdGlhbGl6ZWQiLCJEYXRhUm91dGVzIiwiX3JlZjIiLCJNZW1vcnlSb3V0ZXIiLCJfcmVmMyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiaGlzdG9yeVJlZiIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJ2NUNvbXBhdCIsImhpc3RvcnkiLCJhY3Rpb24iLCJsaXN0ZW4iLCJOYXZpZ2F0ZSIsIl9yZWY0IiwianNvblBhdGgiLCJPdXRsZXQiLCJSb3V0ZSIsIl9wcm9wcyIsIl9yZWY1IiwiYmFzZW5hbWVQcm9wIiwibG9jYXRpb25Qcm9wIiwic3RhdGljUHJvcCIsIm5hdmlnYXRpb25Db250ZXh0IiwibG9jYXRpb25Db250ZXh0IiwidHJhaWxpbmdQYXRobmFtZSIsIlJvdXRlcyIsIl9yZWY2IiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiQXdhaXQiLCJfcmVmNyIsInJlc29sdmUiLCJBd2FpdEVycm9yQm91bmRhcnkiLCJSZXNvbHZlQXdhaXQiLCJBd2FpdFJlbmRlclN0YXR1cyIsIm5ldmVyU2V0dGxlZFByb21pc2UiLCJQcm9taXNlIiwicHJvbWlzZSIsInBlbmRpbmciLCJzdWNjZXNzIiwiZGVmaW5lUHJvcGVydHkiLCJyZW5kZXJFcnJvciIsInJlamVjdCIsImNhdGNoIiwiX3RyYWNrZWQiLCJ0aGVuIiwiZGF0YSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiX3JlZjgiLCJ0b1JlbmRlciIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsImlzVmFsaWRFbGVtZW50IiwidHJlZVBhdGgiLCJ0eXBlIiwiYXBwbHkiLCJuYW1lIiwiY2FzZVNlbnNpdGl2ZSIsImxvYWRlciIsImhhc0Vycm9yQm91bmRhcnkiLCJzaG91bGRSZXZhbGlkYXRlIiwiaGFuZGxlIiwibGF6eSIsInJlbmRlck1hdGNoZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJ1cGRhdGVzIiwiY3JlYXRlTWVtb3J5Um91dGVyIiwiY3JlYXRlUm91dGVyIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1807\n')},6661:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3123);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7958);\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1177);\n/* harmony import */ var dom_helpers_addClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8441);\n/* harmony import */ var dom_helpers_removeClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2062);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5466);\n/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1374);\n/* harmony import */ var _utils_reflow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8109);\n\n\n\n\n\n\n\n\n\n\nvar _addClass = function addClass(node, classes) {\n  return node && classes && classes.split(' ').forEach(function (c) {\n    return (0,dom_helpers_addClass__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z)(node, c);\n  });\n};\nvar removeClass = function removeClass(node, classes) {\n  return node && classes && classes.split(' ').forEach(function (c) {\n    return (0,dom_helpers_removeClass__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Z)(node, c);\n  });\n};\n/**\n * A transition component inspired by the excellent\n * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should\n * use it if you're using CSS transitions or animations. It's built upon the\n * [`Transition`](https://reactcommunity.org/react-transition-group/transition)\n * component, so it inherits all of its props.\n *\n * `CSSTransition` applies a pair of class names during the `appear`, `enter`,\n * and `exit` states of the transition. The first class is applied and then a\n * second `*-active` class in order to activate the CSS transition. After the\n * transition, matching `*-done` class names are applied to persist the\n * transition state.\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <CSSTransition in={inProp} timeout={200} classNames=\"my-node\">\n *         <div>\n *           {\"I'll receive my-node-* classes\"}\n *         </div>\n *       </CSSTransition>\n *       <button type=\"button\" onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the `in` prop is set to `true`, the child component will first receive\n * the class `example-enter`, then the `example-enter-active` will be added in\n * the next tick. `CSSTransition` [forces a\n * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * between before adding the `example-enter-active`. This is an important trick\n * because it allows us to transition between `example-enter` and\n * `example-enter-active` even though they were added immediately one after\n * another. Most notably, this is what makes it possible for us to animate\n * _appearance_.\n *\n * ```css\n * .my-node-enter {\n *   opacity: 0;\n * }\n * .my-node-enter-active {\n *   opacity: 1;\n *   transition: opacity 200ms;\n * }\n * .my-node-exit {\n *   opacity: 1;\n * }\n * .my-node-exit-active {\n *   opacity: 0;\n *   transition: opacity 200ms;\n * }\n * ```\n *\n * `*-active` classes represent which styles you want to animate **to**, so it's\n * important to add `transition` declaration only to them, otherwise transitions\n * might not behave as intended! This might not be obvious when the transitions\n * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in\n * the example above (minus `transition`), but it becomes apparent in more\n * complex transitions.\n *\n * **Note**: If you're using the\n * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)\n * prop, make sure to define styles for `.appear-*` classes as well.\n */\n\nvar CSSTransition = /*#__PURE__*/function (_React$Component) {\n  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Z)(CSSTransition, _React$Component);\n  function CSSTransition() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.appliedClasses = {\n      appear: {},\n      enter: {},\n      exit: {}\n    };\n    _this.onEnter = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),\n        node = _this$resolveArgument[0],\n        appearing = _this$resolveArgument[1];\n      _this.removeClasses(node, 'exit');\n      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');\n      if (_this.props.onEnter) {\n        _this.props.onEnter(maybeNode, maybeAppearing);\n      }\n    };\n    _this.onEntering = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),\n        node = _this$resolveArgument2[0],\n        appearing = _this$resolveArgument2[1];\n      var type = appearing ? 'appear' : 'enter';\n      _this.addClass(node, type, 'active');\n      if (_this.props.onEntering) {\n        _this.props.onEntering(maybeNode, maybeAppearing);\n      }\n    };\n    _this.onEntered = function (maybeNode, maybeAppearing) {\n      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),\n        node = _this$resolveArgument3[0],\n        appearing = _this$resolveArgument3[1];\n      var type = appearing ? 'appear' : 'enter';\n      _this.removeClasses(node, type);\n      _this.addClass(node, type, 'done');\n      if (_this.props.onEntered) {\n        _this.props.onEntered(maybeNode, maybeAppearing);\n      }\n    };\n    _this.onExit = function (maybeNode) {\n      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),\n        node = _this$resolveArgument4[0];\n      _this.removeClasses(node, 'appear');\n      _this.removeClasses(node, 'enter');\n      _this.addClass(node, 'exit', 'base');\n      if (_this.props.onExit) {\n        _this.props.onExit(maybeNode);\n      }\n    };\n    _this.onExiting = function (maybeNode) {\n      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),\n        node = _this$resolveArgument5[0];\n      _this.addClass(node, 'exit', 'active');\n      if (_this.props.onExiting) {\n        _this.props.onExiting(maybeNode);\n      }\n    };\n    _this.onExited = function (maybeNode) {\n      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),\n        node = _this$resolveArgument6[0];\n      _this.removeClasses(node, 'exit');\n      _this.addClass(node, 'exit', 'done');\n      if (_this.props.onExited) {\n        _this.props.onExited(maybeNode);\n      }\n    };\n    _this.resolveArguments = function (maybeNode, maybeAppearing) {\n      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`\n      : [maybeNode, maybeAppearing];\n    };\n    _this.getClassNames = function (type) {\n      var classNames = _this.props.classNames;\n      var isStringClassNames = typeof classNames === 'string';\n      var prefix = isStringClassNames && classNames ? classNames + \"-\" : '';\n      var baseClassName = isStringClassNames ? \"\" + prefix + type : classNames[type];\n      var activeClassName = isStringClassNames ? baseClassName + \"-active\" : classNames[type + \"Active\"];\n      var doneClassName = isStringClassNames ? baseClassName + \"-done\" : classNames[type + \"Done\"];\n      return {\n        baseClassName: baseClassName,\n        activeClassName: activeClassName,\n        doneClassName: doneClassName\n      };\n    };\n    return _this;\n  }\n  var _proto = CSSTransition.prototype;\n  _proto.addClass = function addClass(node, type, phase) {\n    var className = this.getClassNames(type)[phase + \"ClassName\"];\n    var _this$getClassNames = this.getClassNames('enter'),\n      doneClassName = _this$getClassNames.doneClassName;\n    if (type === 'appear' && phase === 'done' && doneClassName) {\n      className += \" \" + doneClassName;\n    } // This is to force a repaint,\n    // which is necessary in order to transition styles when adding a class name.\n\n    if (phase === 'active') {\n      if (node) (0,_utils_reflow__WEBPACK_IMPORTED_MODULE_4__/* .forceReflow */ .Q)(node);\n    }\n    if (className) {\n      this.appliedClasses[type][phase] = className;\n      _addClass(node, className);\n    }\n  };\n  _proto.removeClasses = function removeClasses(node, type) {\n    var _this$appliedClasses$ = this.appliedClasses[type],\n      baseClassName = _this$appliedClasses$.base,\n      activeClassName = _this$appliedClasses$.active,\n      doneClassName = _this$appliedClasses$.done;\n    this.appliedClasses[type] = {};\n    if (baseClassName) {\n      removeClass(node, baseClassName);\n    }\n    if (activeClassName) {\n      removeClass(node, activeClassName);\n    }\n    if (doneClassName) {\n      removeClass(node, doneClassName);\n    }\n  };\n  _proto.render = function render() {\n    var _this$props = this.props,\n      _ = _this$props.classNames,\n      props = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .Z)(_this$props, [\"classNames\"]);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Transition__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .ZP, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .Z)({}, props, {\n      onEnter: this.onEnter,\n      onEntered: this.onEntered,\n      onEntering: this.onEntering,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }));\n  };\n  return CSSTransition;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nCSSTransition.defaultProps = {\n  classNames: ''\n};\nCSSTransition.propTypes =  false ? 0 : {};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CSSTransition);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxDQUFDQSxTQUFTO01BQ3pCSCxVQUFVLEVBQUUsSUFBSSxDQUFDQSxVQUFVO01BQzNCSyxNQUFNLEVBQUUsSUFBSSxDQUFDQSxNQUFNO01BQ25CRSxTQUFTLEVBQUUsSUFBSSxDQUFDQSxTQUFTO01BQ3pCRSxRQUFRLEVBQUUsSUFBSSxDQUFDQTtJQUNqQixDQUFDLENBQUMsQ0FBQztFQUNMLENBQUM7RUFFRCxPQUFPakMsYUFBYTtBQUN0QixDQUFDLENBQUNaLDRDQUFlLENBQUM7QUFFbEJZLGFBQWEsQ0FBQzBELFlBQVksR0FBRztFQUMzQnBCLFVBQVUsRUFBRTtBQUNkLENBQUM7QUFDRHRDLGFBQWEsQ0FBQzJELFNBQVMsR0FBR0MsTUFBcUMsR0FBRzlFLENBaUloRSxHQUFHLENBQUMsQ0FBQztBQUNQLGlFQUFla0IsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL0NTU1RyYW5zaXRpb24uanM/YTUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGFkZE9uZUNsYXNzIGZyb20gJ2RvbS1oZWxwZXJzL2FkZENsYXNzJztcbmltcG9ydCByZW1vdmVPbmVDbGFzcyBmcm9tICdkb20taGVscGVycy9yZW1vdmVDbGFzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRyYW5zaXRpb24gZnJvbSAnLi9UcmFuc2l0aW9uJztcbmltcG9ydCB7IGNsYXNzTmFtZXNTaGFwZSB9IGZyb20gJy4vdXRpbHMvUHJvcFR5cGVzJztcbmltcG9ydCB7IGZvcmNlUmVmbG93IH0gZnJvbSAnLi91dGlscy9yZWZsb3cnO1xuXG52YXIgX2FkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgY2xhc3Nlcykge1xuICByZXR1cm4gbm9kZSAmJiBjbGFzc2VzICYmIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGFkZE9uZUNsYXNzKG5vZGUsIGMpO1xuICB9KTtcbn07XG5cbnZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzZXMpIHtcbiAgcmV0dXJuIG5vZGUgJiYgY2xhc3NlcyAmJiBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiByZW1vdmVPbmVDbGFzcyhub2RlLCBjKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBBIHRyYW5zaXRpb24gY29tcG9uZW50IGluc3BpcmVkIGJ5IHRoZSBleGNlbGxlbnRcbiAqIFtuZy1hbmltYXRlXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdBbmltYXRlKSBsaWJyYXJ5LCB5b3Ugc2hvdWxkXG4gKiB1c2UgaXQgaWYgeW91J3JlIHVzaW5nIENTUyB0cmFuc2l0aW9ucyBvciBhbmltYXRpb25zLiBJdCdzIGJ1aWx0IHVwb24gdGhlXG4gKiBbYFRyYW5zaXRpb25gXShodHRwczovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3RyYW5zaXRpb24pXG4gKiBjb21wb25lbnQsIHNvIGl0IGluaGVyaXRzIGFsbCBvZiBpdHMgcHJvcHMuXG4gKlxuICogYENTU1RyYW5zaXRpb25gIGFwcGxpZXMgYSBwYWlyIG9mIGNsYXNzIG5hbWVzIGR1cmluZyB0aGUgYGFwcGVhcmAsIGBlbnRlcmAsXG4gKiBhbmQgYGV4aXRgIHN0YXRlcyBvZiB0aGUgdHJhbnNpdGlvbi4gVGhlIGZpcnN0IGNsYXNzIGlzIGFwcGxpZWQgYW5kIHRoZW4gYVxuICogc2Vjb25kIGAqLWFjdGl2ZWAgY2xhc3MgaW4gb3JkZXIgdG8gYWN0aXZhdGUgdGhlIENTUyB0cmFuc2l0aW9uLiBBZnRlciB0aGVcbiAqIHRyYW5zaXRpb24sIG1hdGNoaW5nIGAqLWRvbmVgIGNsYXNzIG5hbWVzIGFyZSBhcHBsaWVkIHRvIHBlcnNpc3QgdGhlXG4gKiB0cmFuc2l0aW9uIHN0YXRlLlxuICpcbiAqIGBgYGpzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBbaW5Qcm9wLCBzZXRJblByb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8Q1NTVHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXsyMDB9IGNsYXNzTmFtZXM9XCJteS1ub2RlXCI+XG4gKiAgICAgICAgIDxkaXY+XG4gKiAgICAgICAgICAge1wiSSdsbCByZWNlaXZlIG15LW5vZGUtKiBjbGFzc2VzXCJ9XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgPC9DU1NUcmFuc2l0aW9uPlxuICogICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17KCkgPT4gc2V0SW5Qcm9wKHRydWUpfT5cbiAqICAgICAgICAgQ2xpY2sgdG8gRW50ZXJcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgYGluYCBwcm9wIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBjaGlsZCBjb21wb25lbnQgd2lsbCBmaXJzdCByZWNlaXZlXG4gKiB0aGUgY2xhc3MgYGV4YW1wbGUtZW50ZXJgLCB0aGVuIHRoZSBgZXhhbXBsZS1lbnRlci1hY3RpdmVgIHdpbGwgYmUgYWRkZWQgaW5cbiAqIHRoZSBuZXh0IHRpY2suIGBDU1NUcmFuc2l0aW9uYCBbZm9yY2VzIGFcbiAqIHJlZmxvd10oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9ibG9iLzUwMDczMDNlNzI5YTc0YmU2NmEyMWMzZTIyMDVlNDkxNjgyMTUyNGIvc3JjL0NTU1RyYW5zaXRpb24uanMjTDIwOC1MMjE1KVxuICogYmV0d2VlbiBiZWZvcmUgYWRkaW5nIHRoZSBgZXhhbXBsZS1lbnRlci1hY3RpdmVgLiBUaGlzIGlzIGFuIGltcG9ydGFudCB0cmlja1xuICogYmVjYXVzZSBpdCBhbGxvd3MgdXMgdG8gdHJhbnNpdGlvbiBiZXR3ZWVuIGBleGFtcGxlLWVudGVyYCBhbmRcbiAqIGBleGFtcGxlLWVudGVyLWFjdGl2ZWAgZXZlbiB0aG91Z2ggdGhleSB3ZXJlIGFkZGVkIGltbWVkaWF0ZWx5IG9uZSBhZnRlclxuICogYW5vdGhlci4gTW9zdCBub3RhYmx5LCB0aGlzIGlzIHdoYXQgbWFrZXMgaXQgcG9zc2libGUgZm9yIHVzIHRvIGFuaW1hdGVcbiAqIF9hcHBlYXJhbmNlXy5cbiAqXG4gKiBgYGBjc3NcbiAqIC5teS1ub2RlLWVudGVyIHtcbiAqICAgb3BhY2l0eTogMDtcbiAqIH1cbiAqIC5teS1ub2RlLWVudGVyLWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6IDE7XG4gKiAgIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XG4gKiB9XG4gKiAubXktbm9kZS1leGl0IHtcbiAqICAgb3BhY2l0eTogMTtcbiAqIH1cbiAqIC5teS1ub2RlLWV4aXQtYWN0aXZlIHtcbiAqICAgb3BhY2l0eTogMDtcbiAqICAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcbiAqIH1cbiAqIGBgYFxuICpcbiAqIGAqLWFjdGl2ZWAgY2xhc3NlcyByZXByZXNlbnQgd2hpY2ggc3R5bGVzIHlvdSB3YW50IHRvIGFuaW1hdGUgKip0byoqLCBzbyBpdCdzXG4gKiBpbXBvcnRhbnQgdG8gYWRkIGB0cmFuc2l0aW9uYCBkZWNsYXJhdGlvbiBvbmx5IHRvIHRoZW0sIG90aGVyd2lzZSB0cmFuc2l0aW9uc1xuICogbWlnaHQgbm90IGJlaGF2ZSBhcyBpbnRlbmRlZCEgVGhpcyBtaWdodCBub3QgYmUgb2J2aW91cyB3aGVuIHRoZSB0cmFuc2l0aW9uc1xuICogYXJlIHN5bW1ldHJpY2FsLCBpLmUuIHdoZW4gYCotZW50ZXItYWN0aXZlYCBpcyB0aGUgc2FtZSBhcyBgKi1leGl0YCwgbGlrZSBpblxuICogdGhlIGV4YW1wbGUgYWJvdmUgKG1pbnVzIGB0cmFuc2l0aW9uYCksIGJ1dCBpdCBiZWNvbWVzIGFwcGFyZW50IGluIG1vcmVcbiAqIGNvbXBsZXggdHJhbnNpdGlvbnMuXG4gKlxuICogKipOb3RlKio6IElmIHlvdSdyZSB1c2luZyB0aGVcbiAqIFtgYXBwZWFyYF0oaHR0cDovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3RyYW5zaXRpb24jVHJhbnNpdGlvbi1wcm9wLWFwcGVhcilcbiAqIHByb3AsIG1ha2Ugc3VyZSB0byBkZWZpbmUgc3R5bGVzIGZvciBgLmFwcGVhci0qYCBjbGFzc2VzIGFzIHdlbGwuXG4gKi9cblxuXG52YXIgQ1NTVHJhbnNpdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShDU1NUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDU1NUcmFuc2l0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmFwcGxpZWRDbGFzc2VzID0ge1xuICAgICAgYXBwZWFyOiB7fSxcbiAgICAgIGVudGVyOiB7fSxcbiAgICAgIGV4aXQ6IHt9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRW50ZXIgPSBmdW5jdGlvbiAobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudCA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudFswXSxcbiAgICAgICAgICBhcHBlYXJpbmcgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnRbMV07XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2V4aXQnKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInLCAnYmFzZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyaW5nID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQyID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MlswXSxcbiAgICAgICAgICBhcHBlYXJpbmcgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQyWzFdO1xuXG4gICAgICB2YXIgdHlwZSA9IGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJztcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgdHlwZSwgJ2FjdGl2ZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcmluZykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyaW5nKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyZWQgPSBmdW5jdGlvbiAobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZykge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDMgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQzWzBdLFxuICAgICAgICAgIGFwcGVhcmluZyA9IF90aGlzJHJlc29sdmVBcmd1bWVudDNbMV07XG5cbiAgICAgIHZhciB0eXBlID0gYXBwZWFyaW5nID8gJ2FwcGVhcicgOiAnZW50ZXInO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsIHR5cGUpO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCB0eXBlLCAnZG9uZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FbnRlcmVkKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRW50ZXJlZChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0ID0gZnVuY3Rpb24gKG1heWJlTm9kZSkge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDQgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDRbMF07XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2FwcGVhcicpO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdlbnRlcicpO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCAnZXhpdCcsICdiYXNlJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0KG1heWJlTm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdGluZyA9IGZ1bmN0aW9uIChtYXliZU5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQ1ID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQ1WzBdO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCAnZXhpdCcsICdhY3RpdmUnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRXhpdGluZykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXRpbmcobWF5YmVOb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FeGl0ZWQgPSBmdW5jdGlvbiAobWF5YmVOb2RlKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NiA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NlswXTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZXhpdCcpO1xuXG4gICAgICBfdGhpcy5hZGRDbGFzcyhub2RlLCAnZXhpdCcsICdkb25lJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXRlZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkV4aXRlZChtYXliZU5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5yZXNvbHZlQXJndW1lbnRzID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5ub2RlUmVmID8gW190aGlzLnByb3BzLm5vZGVSZWYuY3VycmVudCwgbWF5YmVOb2RlXSAvLyBoZXJlIGBtYXliZU5vZGVgIGlzIGFjdHVhbGx5IGBhcHBlYXJpbmdgXG4gICAgICA6IFttYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Q2xhc3NOYW1lcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IF90aGlzLnByb3BzLmNsYXNzTmFtZXM7XG4gICAgICB2YXIgaXNTdHJpbmdDbGFzc05hbWVzID0gdHlwZW9mIGNsYXNzTmFtZXMgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIHByZWZpeCA9IGlzU3RyaW5nQ2xhc3NOYW1lcyAmJiBjbGFzc05hbWVzID8gY2xhc3NOYW1lcyArIFwiLVwiIDogJyc7XG4gICAgICB2YXIgYmFzZUNsYXNzTmFtZSA9IGlzU3RyaW5nQ2xhc3NOYW1lcyA/IFwiXCIgKyBwcmVmaXggKyB0eXBlIDogY2xhc3NOYW1lc1t0eXBlXTtcbiAgICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBpc1N0cmluZ0NsYXNzTmFtZXMgPyBiYXNlQ2xhc3NOYW1lICsgXCItYWN0aXZlXCIgOiBjbGFzc05hbWVzW3R5cGUgKyBcIkFjdGl2ZVwiXTtcbiAgICAgIHZhciBkb25lQ2xhc3NOYW1lID0gaXNTdHJpbmdDbGFzc05hbWVzID8gYmFzZUNsYXNzTmFtZSArIFwiLWRvbmVcIiA6IGNsYXNzTmFtZXNbdHlwZSArIFwiRG9uZVwiXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VDbGFzc05hbWU6IGJhc2VDbGFzc05hbWUsXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZTogYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgICBkb25lQ2xhc3NOYW1lOiBkb25lQ2xhc3NOYW1lXG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ1NTVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgdHlwZSwgcGhhc2UpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWVzKHR5cGUpW3BoYXNlICsgXCJDbGFzc05hbWVcIl07XG5cbiAgICB2YXIgX3RoaXMkZ2V0Q2xhc3NOYW1lcyA9IHRoaXMuZ2V0Q2xhc3NOYW1lcygnZW50ZXInKSxcbiAgICAgICAgZG9uZUNsYXNzTmFtZSA9IF90aGlzJGdldENsYXNzTmFtZXMuZG9uZUNsYXNzTmFtZTtcblxuICAgIGlmICh0eXBlID09PSAnYXBwZWFyJyAmJiBwaGFzZSA9PT0gJ2RvbmUnICYmIGRvbmVDbGFzc05hbWUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIGRvbmVDbGFzc05hbWU7XG4gICAgfSAvLyBUaGlzIGlzIHRvIGZvcmNlIGEgcmVwYWludCxcbiAgICAvLyB3aGljaCBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gdHJhbnNpdGlvbiBzdHlsZXMgd2hlbiBhZGRpbmcgYSBjbGFzcyBuYW1lLlxuXG5cbiAgICBpZiAocGhhc2UgPT09ICdhY3RpdmUnKSB7XG4gICAgICBpZiAobm9kZSkgZm9yY2VSZWZsb3cobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5hcHBsaWVkQ2xhc3Nlc1t0eXBlXVtwaGFzZV0gPSBjbGFzc05hbWU7XG5cbiAgICAgIF9hZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMobm9kZSwgdHlwZSkge1xuICAgIHZhciBfdGhpcyRhcHBsaWVkQ2xhc3NlcyQgPSB0aGlzLmFwcGxpZWRDbGFzc2VzW3R5cGVdLFxuICAgICAgICBiYXNlQ2xhc3NOYW1lID0gX3RoaXMkYXBwbGllZENsYXNzZXMkLmJhc2UsXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF90aGlzJGFwcGxpZWRDbGFzc2VzJC5hY3RpdmUsXG4gICAgICAgIGRvbmVDbGFzc05hbWUgPSBfdGhpcyRhcHBsaWVkQ2xhc3NlcyQuZG9uZTtcbiAgICB0aGlzLmFwcGxpZWRDbGFzc2VzW3R5cGVdID0ge307XG5cbiAgICBpZiAoYmFzZUNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgYmFzZUNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZUNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgYWN0aXZlQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZG9uZUNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgZG9uZUNsYXNzTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgXyA9IF90aGlzJHByb3BzLmNsYXNzTmFtZXMsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNsYXNzTmFtZXNcIl0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb24sIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgb25FbnRlcjogdGhpcy5vbkVudGVyLFxuICAgICAgb25FbnRlcmVkOiB0aGlzLm9uRW50ZXJlZCxcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMub25FbnRlcmluZyxcbiAgICAgIG9uRXhpdDogdGhpcy5vbkV4aXQsXG4gICAgICBvbkV4aXRpbmc6IHRoaXMub25FeGl0aW5nLFxuICAgICAgb25FeGl0ZWQ6IHRoaXMub25FeGl0ZWRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIENTU1RyYW5zaXRpb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkNTU1RyYW5zaXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWVzOiAnJ1xufTtcbkNTU1RyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gX2V4dGVuZHMoe30sIFRyYW5zaXRpb24ucHJvcFR5cGVzLCB7XG4gIC8qKlxuICAgKiBUaGUgYW5pbWF0aW9uIGNsYXNzTmFtZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50IGFzIGl0IGFwcGVhcnMsIGVudGVycyxcbiAgICogZXhpdHMgb3IgaGFzIGZpbmlzaGVkIHRoZSB0cmFuc2l0aW9uLiBBIHNpbmdsZSBuYW1lIGNhbiBiZSBwcm92aWRlZCwgd2hpY2hcbiAgICogd2lsbCBiZSBzdWZmaXhlZCBmb3IgZWFjaCBzdGFnZSwgZS5nLiBgY2xhc3NOYW1lcz1cImZhZGVcImAgYXBwbGllczpcbiAgICpcbiAgICogLSBgZmFkZS1hcHBlYXJgLCBgZmFkZS1hcHBlYXItYWN0aXZlYCwgYGZhZGUtYXBwZWFyLWRvbmVgXG4gICAqIC0gYGZhZGUtZW50ZXJgLCBgZmFkZS1lbnRlci1hY3RpdmVgLCBgZmFkZS1lbnRlci1kb25lYFxuICAgKiAtIGBmYWRlLWV4aXRgLCBgZmFkZS1leGl0LWFjdGl2ZWAsIGBmYWRlLWV4aXQtZG9uZWBcbiAgICpcbiAgICogQSBmZXcgZGV0YWlscyB0byBub3RlIGFib3V0IGhvdyB0aGVzZSBjbGFzc2VzIGFyZSBhcHBsaWVkOlxuICAgKlxuICAgKiAxLiBUaGV5IGFyZSBfam9pbmVkXyB3aXRoIHRoZSBvbmVzIHRoYXQgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGUgY2hpbGRcbiAgICogICAgY29tcG9uZW50LCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgc29tZSBiYXNlIHN0eWxlcywgeW91IGNhbiB1c2VcbiAgICogICAgYGNsYXNzTmFtZWAgd2l0aG91dCB3b3JyeWluZyB0aGF0IGl0IHdpbGwgYmUgb3ZlcnJpZGRlbi5cbiAgICpcbiAgICogMi4gSWYgdGhlIHRyYW5zaXRpb24gY29tcG9uZW50IG1vdW50cyB3aXRoIGBpbj17ZmFsc2V9YCwgbm8gY2xhc3NlcyBhcmVcbiAgICogICAgYXBwbGllZCB5ZXQuIFlvdSBtaWdodCBiZSBleHBlY3RpbmcgYCotZXhpdC1kb25lYCwgYnV0IGlmIHlvdSB0aGlua1xuICAgKiAgICBhYm91dCBpdCwgYSBjb21wb25lbnQgY2Fubm90IGZpbmlzaCBleGl0aW5nIGlmIGl0IGhhc24ndCBlbnRlcmVkIHlldC5cbiAgICpcbiAgICogMi4gYGZhZGUtYXBwZWFyLWRvbmVgIGFuZCBgZmFkZS1lbnRlci1kb25lYCB3aWxsIF9ib3RoXyBiZSBhcHBsaWVkLiBUaGlzXG4gICAqICAgIGFsbG93cyB5b3UgdG8gZGVmaW5lIGRpZmZlcmVudCBiZWhhdmlvciBmb3Igd2hlbiBhcHBlYXJpbmcgaXMgZG9uZSBhbmRcbiAgICogICAgd2hlbiByZWd1bGFyIGVudGVyaW5nIGlzIGRvbmUsIHVzaW5nIHNlbGVjdG9ycyBsaWtlXG4gICAqICAgIGAuZmFkZS1lbnRlci1kb25lOm5vdCguZmFkZS1hcHBlYXItZG9uZSlgLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGFwcGx5XG4gICAqICAgIGFuIGVwaWMgZW50cmFuY2UgYW5pbWF0aW9uIHdoZW4gZWxlbWVudCBmaXJzdCBhcHBlYXJzIGluIHRoZSBET00gdXNpbmdcbiAgICogICAgW0FuaW1hdGUuY3NzXShodHRwczovL2RhbmVkZW4uZ2l0aHViLmlvL2FuaW1hdGUuY3NzLykuIE90aGVyd2lzZSB5b3UgY2FuXG4gICAqICAgIHNpbXBseSB1c2UgYGZhZGUtZW50ZXItZG9uZWAgZm9yIGRlZmluaW5nIGJvdGggY2FzZXMuXG4gICAqXG4gICAqIEVhY2ggaW5kaXZpZHVhbCBjbGFzc05hbWVzIGNhbiBhbHNvIGJlIHNwZWNpZmllZCBpbmRlcGVuZGVudGx5IGxpa2U6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNsYXNzTmFtZXM9e3tcbiAgICogIGFwcGVhcjogJ215LWFwcGVhcicsXG4gICAqICBhcHBlYXJBY3RpdmU6ICdteS1hY3RpdmUtYXBwZWFyJyxcbiAgICogIGFwcGVhckRvbmU6ICdteS1kb25lLWFwcGVhcicsXG4gICAqICBlbnRlcjogJ215LWVudGVyJyxcbiAgICogIGVudGVyQWN0aXZlOiAnbXktYWN0aXZlLWVudGVyJyxcbiAgICogIGVudGVyRG9uZTogJ215LWRvbmUtZW50ZXInLFxuICAgKiAgZXhpdDogJ215LWV4aXQnLFxuICAgKiAgZXhpdEFjdGl2ZTogJ215LWFjdGl2ZS1leGl0JyxcbiAgICogIGV4aXREb25lOiAnbXktZG9uZS1leGl0JyxcbiAgICogfX1cbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHNldCB0aGVzZSBjbGFzc2VzIHVzaW5nIENTUyBNb2R1bGVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLmNzcyc7XG4gICAqIGBgYFxuICAgKlxuICAgKiB5b3UgbWlnaHQgd2FudCB0byB1c2UgY2FtZWxDYXNlIGluIHlvdXIgQ1NTIGZpbGUsIHRoYXQgd2F5IGNvdWxkIHNpbXBseVxuICAgKiBzcHJlYWQgdGhlbSBpbnN0ZWFkIG9mIGxpc3RpbmcgdGhlbSBvbmUgYnkgb25lOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGFzc05hbWVzPXt7IC4uLnN0eWxlcyB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge3N0cmluZyB8IHtcbiAgICogIGFwcGVhcj86IHN0cmluZyxcbiAgICogIGFwcGVhckFjdGl2ZT86IHN0cmluZyxcbiAgICogIGFwcGVhckRvbmU/OiBzdHJpbmcsXG4gICAqICBlbnRlcj86IHN0cmluZyxcbiAgICogIGVudGVyQWN0aXZlPzogc3RyaW5nLFxuICAgKiAgZW50ZXJEb25lPzogc3RyaW5nLFxuICAgKiAgZXhpdD86IHN0cmluZyxcbiAgICogIGV4aXRBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBleGl0RG9uZT86IHN0cmluZyxcbiAgICogfX1cbiAgICovXG4gIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXNTaGFwZSxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyJyBvciAnYXBwZWFyJyBjbGFzcyBpc1xuICAgKiBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyLWFjdGl2ZScgb3JcbiAgICogJ2FwcGVhci1hY3RpdmUnIGNsYXNzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZW50ZXInIG9yXG4gICAqICdhcHBlYXInIGNsYXNzZXMgYXJlICoqcmVtb3ZlZCoqIGFuZCB0aGUgYGRvbmVgIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBET00gbm9kZS5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQnIGNsYXNzIGlzXG4gICAqIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdC1hY3RpdmUnIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIGA8VHJhbnNpdGlvbj5gIGNhbGxiYWNrIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnZXhpdCcgY2xhc3Nlc1xuICAgKiBhcmUgKipyZW1vdmVkKiogYW5kIHRoZSBgZXhpdC1kb25lYCBjbGFzcyBpcyBhZGRlZCB0byB0aGUgRE9NIG5vZGUuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmNcbn0pIDoge307XG5leHBvcnQgZGVmYXVsdCBDU1NUcmFuc2l0aW9uOyJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX2luaGVyaXRzTG9vc2UiLCJQcm9wVHlwZXMiLCJhZGRPbmVDbGFzcyIsInJlbW92ZU9uZUNsYXNzIiwiUmVhY3QiLCJUcmFuc2l0aW9uIiwiY2xhc3NOYW1lc1NoYXBlIiwiZm9yY2VSZWZsb3ciLCJfYWRkQ2xhc3MiLCJhZGRDbGFzcyIsIm5vZGUiLCJjbGFzc2VzIiwic3BsaXQiLCJmb3JFYWNoIiwiYyIsInJlbW92ZUNsYXNzIiwiQ1NTVHJhbnNpdGlvbiIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY2FsbCIsImFwcGx5IiwiY29uY2F0IiwiYXBwbGllZENsYXNzZXMiLCJhcHBlYXIiLCJlbnRlciIsImV4aXQiLCJvbkVudGVyIiwibWF5YmVOb2RlIiwibWF5YmVBcHBlYXJpbmciLCJfdGhpcyRyZXNvbHZlQXJndW1lbnQiLCJyZXNvbHZlQXJndW1lbnRzIiwiYXBwZWFyaW5nIiwicmVtb3ZlQ2xhc3NlcyIsInByb3BzIiwib25FbnRlcmluZyIsIl90aGlzJHJlc29sdmVBcmd1bWVudDIiLCJ0eXBlIiwib25FbnRlcmVkIiwiX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MyIsIm9uRXhpdCIsIl90aGlzJHJlc29sdmVBcmd1bWVudDQiLCJvbkV4aXRpbmciLCJfdGhpcyRyZXNvbHZlQXJndW1lbnQ1Iiwib25FeGl0ZWQiLCJfdGhpcyRyZXNvbHZlQXJndW1lbnQ2Iiwibm9kZVJlZiIsImN1cnJlbnQiLCJnZXRDbGFzc05hbWVzIiwiY2xhc3NOYW1lcyIsImlzU3RyaW5nQ2xhc3NOYW1lcyIsInByZWZpeCIsImJhc2VDbGFzc05hbWUiLCJhY3RpdmVDbGFzc05hbWUiLCJkb25lQ2xhc3NOYW1lIiwiX3Byb3RvIiwicHJvdG90eXBlIiwicGhhc2UiLCJjbGFzc05hbWUiLCJfdGhpcyRnZXRDbGFzc05hbWVzIiwiX3RoaXMkYXBwbGllZENsYXNzZXMkIiwiYmFzZSIsImFjdGl2ZSIsImRvbmUiLCJyZW5kZXIiLCJfdGhpcyRwcm9wcyIsIl8iLCJjcmVhdGVFbGVtZW50IiwiQ29tcG9uZW50IiwiZGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZnVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6661\n")},1374:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  ZP: () => (/* binding */ esm_Transition)\n});\n\n// UNUSED EXPORTS: ENTERED, ENTERING, EXITED, EXITING, UNMOUNTED\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nvar objectWithoutPropertiesLoose = __webpack_require__(7958);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js + 1 modules\nvar inheritsLoose = __webpack_require__(1177);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(5466);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(6116);\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/config.js\n/* harmony default export */ const config = ({\n  disabled: false\n});\n// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js\nvar TransitionGroupContext = __webpack_require__(8992);\n// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/utils/reflow.js\nvar reflow = __webpack_require__(8109);\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/Transition.js\n\n\n\n\n\n\n\n\n\nvar UNMOUNTED = 'unmounted';\nvar EXITED = 'exited';\nvar ENTERING = 'entering';\nvar ENTERED = 'entered';\nvar EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you're using\n * transitions in CSS, you'll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the\n * components. It's up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from 'react-transition-group';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the \"Enter\" stage. During this stage, the component will shift from\n * its current transition state, to `'entering'` for the duration of the\n * transition and then to the `'entered'` stage once it's complete. Let's take\n * the following example (we'll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `'exiting'` to `'exited'`.\n */\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  (0,inheritsLoose/* default */.Z)(Transition, _React$Component);\n  function Transition(props, context) {\n    var _this;\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n    return null;\n  } // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n  ;\n\n  var _proto = Transition.prototype;\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n    this.updateStatus(false, nextStatus);\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n      if (nextStatus === ENTERING) {\n        if (this.props.unmountOnExit || this.props.mountOnEnter) {\n          var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749\n          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.\n          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.\n\n          if (node) (0,reflow/* forceReflow */.Q)(node);\n        }\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom.findDOMNode(this), appearing],\n      maybeNode = _ref2[0],\n      maybeAppearing = _ref2[1];\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(maybeNode);\n      });\n      return;\n    }\n    this.props.onEnter(maybeNode, maybeAppearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(maybeNode, maybeAppearing);\n      _this2.onTransitionEnd(enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(maybeNode, maybeAppearing);\n        });\n      });\n    });\n  };\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts();\n    var maybeNode = this.props.nodeRef ? undefined : react_dom.findDOMNode(this); // no exit animation skip right to EXITED\n\n    if (!exit || config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(maybeNode);\n      });\n      return;\n    }\n    this.props.onExit(maybeNode);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(maybeNode);\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(maybeNode);\n        });\n      });\n    });\n  };\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n    var active = true;\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n    return this.nextCallback;\n  };\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n    if (this.props.addEndListener) {\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\n        maybeNode = _ref3[0],\n        maybeNextCallback = _ref3[1];\n      this.props.addEndListener(maybeNode, maybeNextCallback);\n    }\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n  _proto.render = function render() {\n    var status = this.state.status;\n    if (status === UNMOUNTED) {\n      return null;\n    }\n    var _this$props = this.props,\n      children = _this$props.children,\n      _in = _this$props.in,\n      _mountOnEnter = _this$props.mountOnEnter,\n      _unmountOnExit = _this$props.unmountOnExit,\n      _appear = _this$props.appear,\n      _enter = _this$props.enter,\n      _exit = _this$props.exit,\n      _timeout = _this$props.timeout,\n      _addEndListener = _this$props.addEndListener,\n      _onEnter = _this$props.onEnter,\n      _onEntering = _this$props.onEntering,\n      _onEntered = _this$props.onEntered,\n      _onExit = _this$props.onExit,\n      _onExiting = _this$props.onExiting,\n      _onExited = _this$props.onExited,\n      _nodeRef = _this$props.nodeRef,\n      childProps = (0,objectWithoutPropertiesLoose/* default */.Z)(_this$props, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n    return /*#__PURE__*/(\n      // allows for nested Transitions\n      react.createElement(TransitionGroupContext/* default */.Z.Provider, {\n        value: null\n      }, typeof children === 'function' ? children(status, childProps) : react.cloneElement(react.Children.only(children), childProps))\n    );\n  };\n  return Transition;\n}(react.Component);\nTransition.contextType = TransitionGroupContext/* default */.Z;\nTransition.propTypes =  false ? 0 : {}; // Name the function so it is clearer in the documentation\n\nfunction noop() {}\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = UNMOUNTED;\nTransition.EXITED = EXITED;\nTransition.ENTERING = ENTERING;\nTransition.ENTERED = ENTERED;\nTransition.EXITING = EXITING;\n/* harmony default export */ const esm_Transition = (Transition);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBLEVBQUcsQ0FBQztBQUVqQmpJLFVBQVUsQ0FBQ2tJLFlBQVksR0FBRztFQUN4QnRILEVBQUUsRUFBRSxLQUFLO0VBQ1RFLFlBQVksRUFBRSxLQUFLO0VBQ25CRCxhQUFhLEVBQUUsS0FBSztFQUNwQk4sTUFBTSxFQUFFLEtBQUs7RUFDYkUsS0FBSyxFQUFFLElBQUk7RUFDWHdCLElBQUksRUFBRSxJQUFJO0VBQ1ZtQixPQUFPLEVBQUU2RSxJQUFJO0VBQ2I1RSxVQUFVLEVBQUU0RSxJQUFJO0VBQ2hCOUUsU0FBUyxFQUFFOEUsSUFBSTtFQUNmeEUsTUFBTSxFQUFFd0UsSUFBSTtFQUNadkUsU0FBUyxFQUFFdUUsSUFBSTtFQUNmekUsUUFBUSxFQUFFeUU7QUFDWixDQUFDO0FBQ0RqSSxVQUFVLENBQUNMLFNBQVMsR0FBR0EsU0FBUztBQUNoQ0ssVUFBVSxDQUFDSixNQUFNLEdBQUdBLE1BQU07QUFDMUJJLFVBQVUsQ0FBQ0gsUUFBUSxHQUFHQSxRQUFRO0FBQzlCRyxVQUFVLENBQUNGLE9BQU8sR0FBR0EsT0FBTztBQUM1QkUsVUFBVSxDQUFDRCxPQUFPLEdBQUdBLE9BQU87QUFDNUIscURBQWVDLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9jb25maWcuanM/MmE0MiIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9UcmFuc2l0aW9uLmpzPzc1MWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICBkaXNhYmxlZDogZmFsc2Vcbn07IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IHRpbWVvdXRzU2hhcGUgfSBmcm9tICcuL3V0aWxzL1Byb3BUeXBlcyc7XG5pbXBvcnQgVHJhbnNpdGlvbkdyb3VwQ29udGV4dCBmcm9tICcuL1RyYW5zaXRpb25Hcm91cENvbnRleHQnO1xuaW1wb3J0IHsgZm9yY2VSZWZsb3cgfSBmcm9tICcuL3V0aWxzL3JlZmxvdyc7XG5leHBvcnQgdmFyIFVOTU9VTlRFRCA9ICd1bm1vdW50ZWQnO1xuZXhwb3J0IHZhciBFWElURUQgPSAnZXhpdGVkJztcbmV4cG9ydCB2YXIgRU5URVJJTkcgPSAnZW50ZXJpbmcnO1xuZXhwb3J0IHZhciBFTlRFUkVEID0gJ2VudGVyZWQnO1xuZXhwb3J0IHZhciBFWElUSU5HID0gJ2V4aXRpbmcnO1xuLyoqXG4gKiBUaGUgVHJhbnNpdGlvbiBjb21wb25lbnQgbGV0cyB5b3UgZGVzY3JpYmUgYSB0cmFuc2l0aW9uIGZyb20gb25lIGNvbXBvbmVudFxuICogc3RhdGUgdG8gYW5vdGhlciBfb3ZlciB0aW1lXyB3aXRoIGEgc2ltcGxlIGRlY2xhcmF0aXZlIEFQSS4gTW9zdCBjb21tb25seVxuICogaXQncyB1c2VkIHRvIGFuaW1hdGUgdGhlIG1vdW50aW5nIGFuZCB1bm1vdW50aW5nIG9mIGEgY29tcG9uZW50LCBidXQgY2FuIGFsc29cbiAqIGJlIHVzZWQgdG8gZGVzY3JpYmUgaW4tcGxhY2UgdHJhbnNpdGlvbiBzdGF0ZXMgYXMgd2VsbC5cbiAqXG4gKiAtLS1cbiAqXG4gKiAqKk5vdGUqKjogYFRyYW5zaXRpb25gIGlzIGEgcGxhdGZvcm0tYWdub3N0aWMgYmFzZSBjb21wb25lbnQuIElmIHlvdSdyZSB1c2luZ1xuICogdHJhbnNpdGlvbnMgaW4gQ1NTLCB5b3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAqIFtgQ1NTVHJhbnNpdGlvbmBdKGh0dHBzOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvY3NzLXRyYW5zaXRpb24pXG4gKiBpbnN0ZWFkLiBJdCBpbmhlcml0cyBhbGwgdGhlIGZlYXR1cmVzIG9mIGBUcmFuc2l0aW9uYCwgYnV0IGNvbnRhaW5zXG4gKiBhZGRpdGlvbmFsIGZlYXR1cmVzIG5lY2Vzc2FyeSB0byBwbGF5IG5pY2Ugd2l0aCBDU1MgdHJhbnNpdGlvbnMgKGhlbmNlIHRoZVxuICogbmFtZSBvZiB0aGUgY29tcG9uZW50KS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IGRvZXMgbm90IGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGVcbiAqIGNvbXBvbmVudCBpdCByZW5kZXJzLCBpdCBvbmx5IHRyYWNrcyBcImVudGVyXCIgYW5kIFwiZXhpdFwiIHN0YXRlcyBmb3IgdGhlXG4gKiBjb21wb25lbnRzLiBJdCdzIHVwIHRvIHlvdSB0byBnaXZlIG1lYW5pbmcgYW5kIGVmZmVjdCB0byB0aG9zZSBzdGF0ZXMuIEZvclxuICogZXhhbXBsZSB3ZSBjYW4gYWRkIHN0eWxlcyB0byBhIGNvbXBvbmVudCB3aGVuIGl0IGVudGVycyBvciBleGl0czpcbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcbiAqXG4gKiBjb25zdCBkdXJhdGlvbiA9IDMwMDtcbiAqXG4gKiBjb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gKiAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgZWFzZS1pbi1vdXRgLFxuICogICBvcGFjaXR5OiAwLFxuICogfVxuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25TdHlsZXMgPSB7XG4gKiAgIGVudGVyaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAqICAgZW50ZXJlZDogIHsgb3BhY2l0eTogMSB9LFxuICogICBleGl0aW5nOiAgeyBvcGFjaXR5OiAwIH0sXG4gKiAgIGV4aXRlZDogIHsgb3BhY2l0eTogMCB9LFxuICogfTtcbiAqXG4gKiBjb25zdCBGYWRlID0gKHsgaW46IGluUHJvcCB9KSA9PiAoXG4gKiAgIDxUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9e2R1cmF0aW9ufT5cbiAqICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgPGRpdiBzdHlsZT17e1xuICogICAgICAgICAuLi5kZWZhdWx0U3R5bGUsXG4gKiAgICAgICAgIC4uLnRyYW5zaXRpb25TdHlsZXNbc3RhdGVdXG4gKiAgICAgICB9fT5cbiAqICAgICAgICAgSSdtIGEgZmFkZSBUcmFuc2l0aW9uIVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgKX1cbiAqICAgPC9UcmFuc2l0aW9uPlxuICogKTtcbiAqIGBgYFxuICpcbiAqIFRoZXJlIGFyZSA0IG1haW4gc3RhdGVzIGEgVHJhbnNpdGlvbiBjYW4gYmUgaW46XG4gKiAgLSBgJ2VudGVyaW5nJ2BcbiAqICAtIGAnZW50ZXJlZCdgXG4gKiAgLSBgJ2V4aXRpbmcnYFxuICogIC0gYCdleGl0ZWQnYFxuICpcbiAqIFRyYW5zaXRpb24gc3RhdGUgaXMgdG9nZ2xlZCB2aWEgdGhlIGBpbmAgcHJvcC4gV2hlbiBgdHJ1ZWAgdGhlIGNvbXBvbmVudFxuICogYmVnaW5zIHRoZSBcIkVudGVyXCIgc3RhZ2UuIER1cmluZyB0aGlzIHN0YWdlLCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgZnJvbVxuICogaXRzIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0ZSwgdG8gYCdlbnRlcmluZydgIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiB0cmFuc2l0aW9uIGFuZCB0aGVuIHRvIHRoZSBgJ2VudGVyZWQnYCBzdGFnZSBvbmNlIGl0J3MgY29tcGxldGUuIExldCdzIHRha2VcbiAqIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSAod2UnbGwgdXNlIHRoZVxuICogW3VzZVN0YXRlXShodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlc3RhdGUpIGhvb2spOlxuICpcbiAqIGBgYGpzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBbaW5Qcm9wLCBzZXRJblByb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8VHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXs1MDB9PlxuICogICAgICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICApfVxuICogICAgICAgPC9UcmFuc2l0aW9uPlxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRJblByb3AodHJ1ZSl9PlxuICogICAgICAgICBDbGljayB0byBFbnRlclxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgdG8gdGhlIGAnZW50ZXJpbmcnYCBzdGF0ZVxuICogYW5kIHN0YXkgdGhlcmUgZm9yIDUwMG1zICh0aGUgdmFsdWUgb2YgYHRpbWVvdXRgKSBiZWZvcmUgaXQgZmluYWxseSBzd2l0Y2hlc1xuICogdG8gYCdlbnRlcmVkJ2AuXG4gKlxuICogV2hlbiBgaW5gIGlzIGBmYWxzZWAgdGhlIHNhbWUgdGhpbmcgaGFwcGVucyBleGNlcHQgdGhlIHN0YXRlIG1vdmVzIGZyb21cbiAqIGAnZXhpdGluZydgIHRvIGAnZXhpdGVkJ2AuXG4gKi9cblxudmFyIFRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgIHZhciBwYXJlbnRHcm91cCA9IGNvbnRleHQ7IC8vIEluIHRoZSBjb250ZXh0IG9mIGEgVHJhbnNpdGlvbkdyb3VwIGFsbCBlbnRlcnMgYXJlIHJlYWxseSBhcHBlYXJzXG5cbiAgICB2YXIgYXBwZWFyID0gcGFyZW50R3JvdXAgJiYgIXBhcmVudEdyb3VwLmlzTW91bnRpbmcgPyBwcm9wcy5lbnRlciA6IHByb3BzLmFwcGVhcjtcbiAgICB2YXIgaW5pdGlhbFN0YXR1cztcbiAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByb3BzLmluKSB7XG4gICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVOVEVSRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy51bm1vdW50T25FeGl0IHx8IHByb3BzLm1vdW50T25FbnRlcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gVU5NT1VOVEVEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogaW5pdGlhbFN0YXR1c1xuICAgIH07XG4gICAgX3RoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUcmFuc2l0aW9uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgbmV4dEluID0gX3JlZi5pbjtcblxuICAgIGlmIChuZXh0SW4gJiYgcHJldlN0YXRlLnN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgLy8gICBsZXQgbmV4dFN0YXR1cyA9IG51bGxcbiAgLy8gICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gIC8vICAgICBjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5zdGF0ZVxuICAvLyAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHsgbmV4dFN0YXR1cyB9XG4gIC8vIH1cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyh0cnVlLCB0aGlzLmFwcGVhclN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgbmV4dFN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklORztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyhmYWxzZSwgbmV4dFN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGltZW91dHMgPSBmdW5jdGlvbiBnZXRUaW1lb3V0cygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICB2YXIgZXhpdCwgZW50ZXIsIGFwcGVhcjtcbiAgICBleGl0ID0gZW50ZXIgPSBhcHBlYXIgPSB0aW1lb3V0O1xuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCAmJiB0eXBlb2YgdGltZW91dCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGV4aXQgPSB0aW1lb3V0LmV4aXQ7XG4gICAgICBlbnRlciA9IHRpbWVvdXQuZW50ZXI7IC8vIFRPRE86IHJlbW92ZSBmYWxsYmFjayBmb3IgbmV4dCBtYWpvclxuXG4gICAgICBhcHBlYXIgPSB0aW1lb3V0LmFwcGVhciAhPT0gdW5kZWZpbmVkID8gdGltZW91dC5hcHBlYXIgOiBlbnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpdDogZXhpdCxcbiAgICAgIGVudGVyOiBlbnRlcixcbiAgICAgIGFwcGVhcjogYXBwZWFyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlU3RhdHVzKG1vdW50aW5nLCBuZXh0U3RhdHVzKSB7XG4gICAgaWYgKG1vdW50aW5nID09PSB2b2lkIDApIHtcbiAgICAgIG1vdW50aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5leHRTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIC8vIG5leHRTdGF0dXMgd2lsbCBhbHdheXMgYmUgRU5URVJJTkcgb3IgRVhJVElORy5cbiAgICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG5cbiAgICAgIGlmIChuZXh0U3RhdHVzID09PSBFTlRFUklORykge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy51bm1vdW50T25FeGl0IHx8IHRoaXMucHJvcHMubW91bnRPbkVudGVyKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB0aGlzLnByb3BzLm5vZGVSZWYuY3VycmVudCA6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3B1bGwvNzQ5XG4gICAgICAgICAgLy8gV2l0aCB1bm1vdW50T25FeGl0IG9yIG1vdW50T25FbnRlciwgdGhlIGVudGVyIGFuaW1hdGlvbiBzaG91bGQgaGFwcGVuIGF0IHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gYGV4aXRlZGAgYW5kIGBlbnRlcmluZ2AuXG4gICAgICAgICAgLy8gVG8gbWFrZSB0aGUgYW5pbWF0aW9uIGhhcHBlbiwgIHdlIGhhdmUgdG8gc2VwYXJhdGUgZWFjaCByZW5kZXJpbmcgYW5kIGF2b2lkIGJlaW5nIHByb2Nlc3NlZCBhcyBiYXRjaGVkLlxuXG4gICAgICAgICAgaWYgKG5vZGUpIGZvcmNlUmVmbG93KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wZXJmb3JtRW50ZXIobW91bnRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRXhpdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy51bm1vdW50T25FeGl0ICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSBFWElURUQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IFVOTU9VTlRFRFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRW50ZXIgPSBmdW5jdGlvbiBwZXJmb3JtRW50ZXIobW91bnRpbmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBlbnRlciA9IHRoaXMucHJvcHMuZW50ZXI7XG4gICAgdmFyIGFwcGVhcmluZyA9IHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5pc01vdW50aW5nIDogbW91bnRpbmc7XG5cbiAgICB2YXIgX3JlZjIgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyBbYXBwZWFyaW5nXSA6IFtSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSwgYXBwZWFyaW5nXSxcbiAgICAgICAgbWF5YmVOb2RlID0gX3JlZjJbMF0sXG4gICAgICAgIG1heWJlQXBwZWFyaW5nID0gX3JlZjJbMV07XG5cbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7XG4gICAgdmFyIGVudGVyVGltZW91dCA9IGFwcGVhcmluZyA/IHRpbWVvdXRzLmFwcGVhciA6IHRpbWVvdXRzLmVudGVyOyAvLyBubyBlbnRlciBhbmltYXRpb24gc2tpcCByaWdodCB0byBFTlRFUkVEXG4gICAgLy8gaWYgd2UgYXJlIG1vdW50aW5nIGFuZCBydW5uaW5nIHRoaXMgaXQgbWVhbnMgYXBwZWFyIF9tdXN0XyBiZSBzZXRcblxuICAgIGlmICghbW91bnRpbmcgJiYgIWVudGVyIHx8IGNvbmZpZy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChtYXliZU5vZGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkVudGVyKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRU5URVJJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIucHJvcHMub25FbnRlcmluZyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcblxuICAgICAgX3RoaXMyLm9uVHJhbnNpdGlvbkVuZChlbnRlclRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRXhpdCA9IGZ1bmN0aW9uIHBlcmZvcm1FeGl0KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGV4aXQgPSB0aGlzLnByb3BzLmV4aXQ7XG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpO1xuICAgIHZhciBtYXliZU5vZGUgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB1bmRlZmluZWQgOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTsgLy8gbm8gZXhpdCBhbmltYXRpb24gc2tpcCByaWdodCB0byBFWElURURcblxuICAgIGlmICghZXhpdCB8fCBjb25maWcuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKG1heWJlTm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRXhpdChtYXliZU5vZGUpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRVhJVElOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRpbmcobWF5YmVOb2RlKTtcblxuICAgICAgX3RoaXMzLm9uVHJhbnNpdGlvbkVuZCh0aW1lb3V0cy5leGl0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2FuY2VsTmV4dENhbGxiYWNrID0gZnVuY3Rpb24gY2FuY2VsTmV4dENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLm5leHRDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsKCk7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zYWZlU2V0U3RhdGUgPSBmdW5jdGlvbiBzYWZlU2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSwgYnV0IHRoZXJlIGFyZSB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgd2l0aFxuICAgIC8vIHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgdW5tb3VudGluZyBpbiB0ZXN0aW5nLCBzbyBhbHdheXMgbWFrZSBzdXJlIHRoYXRcbiAgICAvLyB3ZSBjYW4gY2FuY2VsIGFueSBwZW5kaW5nIHNldFN0YXRlIGNhbGxiYWNrcyBhZnRlciB3ZSB1bm1vdW50LlxuICAgIGNhbGxiYWNrID0gdGhpcy5zZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spO1xuICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnNldE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIHNldE5leHRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIGFjdGl2ZSA9IHRydWU7XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXM0Lm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm5leHRDYWxsYmFjaztcbiAgfTtcblxuICBfcHJvdG8ub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKHRpbWVvdXQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnNldE5leHRDYWxsYmFjayhoYW5kbGVyKTtcbiAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHRoaXMucHJvcHMubm9kZVJlZi5jdXJyZW50IDogUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGRvZXNOb3RIYXZlVGltZW91dE9yTGlzdGVuZXIgPSB0aW1lb3V0ID09IG51bGwgJiYgIXRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXI7XG5cbiAgICBpZiAoIW5vZGUgfHwgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lcikge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIpIHtcbiAgICAgIHZhciBfcmVmMyA9IHRoaXMucHJvcHMubm9kZVJlZiA/IFt0aGlzLm5leHRDYWxsYmFja10gOiBbbm9kZSwgdGhpcy5uZXh0Q2FsbGJhY2tdLFxuICAgICAgICAgIG1heWJlTm9kZSA9IF9yZWYzWzBdLFxuICAgICAgICAgIG1heWJlTmV4dENhbGxiYWNrID0gX3JlZjNbMV07XG5cbiAgICAgIHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIobWF5YmVOb2RlLCBtYXliZU5leHRDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgdGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBfaW4gPSBfdGhpcyRwcm9wcy5pbixcbiAgICAgICAgX21vdW50T25FbnRlciA9IF90aGlzJHByb3BzLm1vdW50T25FbnRlcixcbiAgICAgICAgX3VubW91bnRPbkV4aXQgPSBfdGhpcyRwcm9wcy51bm1vdW50T25FeGl0LFxuICAgICAgICBfYXBwZWFyID0gX3RoaXMkcHJvcHMuYXBwZWFyLFxuICAgICAgICBfZW50ZXIgPSBfdGhpcyRwcm9wcy5lbnRlcixcbiAgICAgICAgX2V4aXQgPSBfdGhpcyRwcm9wcy5leGl0LFxuICAgICAgICBfdGltZW91dCA9IF90aGlzJHByb3BzLnRpbWVvdXQsXG4gICAgICAgIF9hZGRFbmRMaXN0ZW5lciA9IF90aGlzJHByb3BzLmFkZEVuZExpc3RlbmVyLFxuICAgICAgICBfb25FbnRlciA9IF90aGlzJHByb3BzLm9uRW50ZXIsXG4gICAgICAgIF9vbkVudGVyaW5nID0gX3RoaXMkcHJvcHMub25FbnRlcmluZyxcbiAgICAgICAgX29uRW50ZXJlZCA9IF90aGlzJHByb3BzLm9uRW50ZXJlZCxcbiAgICAgICAgX29uRXhpdCA9IF90aGlzJHByb3BzLm9uRXhpdCxcbiAgICAgICAgX29uRXhpdGluZyA9IF90aGlzJHByb3BzLm9uRXhpdGluZyxcbiAgICAgICAgX29uRXhpdGVkID0gX3RoaXMkcHJvcHMub25FeGl0ZWQsXG4gICAgICAgIF9ub2RlUmVmID0gX3RoaXMkcHJvcHMubm9kZVJlZixcbiAgICAgICAgY2hpbGRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImluXCIsIFwibW91bnRPbkVudGVyXCIsIFwidW5tb3VudE9uRXhpdFwiLCBcImFwcGVhclwiLCBcImVudGVyXCIsIFwiZXhpdFwiLCBcInRpbWVvdXRcIiwgXCJhZGRFbmRMaXN0ZW5lclwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyaW5nXCIsIFwib25FbnRlcmVkXCIsIFwib25FeGl0XCIsIFwib25FeGl0aW5nXCIsIFwib25FeGl0ZWRcIiwgXCJub2RlUmVmXCJdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBhbGxvd3MgZm9yIG5lc3RlZCBUcmFuc2l0aW9uc1xuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LCB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihzdGF0dXMsIGNoaWxkUHJvcHMpIDogUmVhY3QuY2xvbmVFbGVtZW50KFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCBjaGlsZFByb3BzKSlcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5UcmFuc2l0aW9uLmNvbnRleHRUeXBlID0gVHJhbnNpdGlvbkdyb3VwQ29udGV4dDtcblRyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogQSBSZWFjdCByZWZlcmVuY2UgdG8gRE9NIGVsZW1lbnQgdGhhdCBuZWVkIHRvIHRyYW5zaXRpb246XG4gICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MTEyNzEzMC80NjcxOTMyXG4gICAqXG4gICAqICAgLSBXaGVuIGBub2RlUmVmYCBwcm9wIGlzIHVzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgKiAgICAgIChlLmcuIGBvbkVudGVyYCkgYmVjYXVzZSB1c2VyIGFscmVhZHkgaGFzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIG5vZGUuXG4gICAqICAgLSBXaGVuIGNoYW5naW5nIGBrZXlgIHByb3Agb2YgYFRyYW5zaXRpb25gIGluIGEgYFRyYW5zaXRpb25Hcm91cGAgYSBuZXdcbiAgICogICAgIGBub2RlUmVmYCBuZWVkIHRvIGJlIHByb3ZpZGVkIHRvIGBUcmFuc2l0aW9uYCB3aXRoIGNoYW5nZWQgYGtleWAgcHJvcFxuICAgKiAgICAgKHNlZVxuICAgKiAgICAgW3Rlc3QvQ1NTVHJhbnNpdGlvbi10ZXN0LmpzXShodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2Jsb2IvMTM0MzVmODk3YjNhYjcxZjZlMTlkNzI0ZjE0NTU5NmY1OTEwNTgxYy90ZXN0L0NTU1RyYW5zaXRpb24tdGVzdC5qcyNMMzYyLUw0MzcpKS5cbiAgICovXG4gIG5vZGVSZWY6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY3VycmVudDogdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gUHJvcFR5cGVzLmFueSA6IGZ1bmN0aW9uIChwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wVmFsdWVba2V5XTtcbiAgICAgIHJldHVybiBQcm9wVHlwZXMuaW5zdGFuY2VPZih2YWx1ZSAmJiAnb3duZXJEb2N1bWVudCcgaW4gdmFsdWUgPyB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LkVsZW1lbnQgOiBFbGVtZW50KShwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KTtcbiAgICB9XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBBIGBmdW5jdGlvbmAgY2hpbGQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBhIFJlYWN0IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gaXNcbiAgICogY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0dXMgKGAnZW50ZXJpbmcnYCwgYCdlbnRlcmVkJ2AsXG4gICAqIGAnZXhpdGluZydgLCBgJ2V4aXRlZCdgKSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYXBwbHkgY29udGV4dFxuICAgKiBzcGVjaWZpYyBwcm9wcyB0byBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIDxUcmFuc2l0aW9uIGluPXt0aGlzLnN0YXRlLmlufSB0aW1lb3V0PXsxNTB9PlxuICAgKiAgIHtzdGF0ZSA9PiAoXG4gICAqICAgICA8TXlDb21wb25lbnQgY2xhc3NOYW1lPXtgZmFkZSBmYWRlLSR7c3RhdGV9YH0gLz5cbiAgICogICApfVxuICAgKiA8L1RyYW5zaXRpb24+XG4gICAqIGBgYFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsIFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRdKS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQ7IHRyaWdnZXJzIHRoZSBlbnRlciBvciBleGl0IHN0YXRlc1xuICAgKi9cbiAgaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgaXMgbW91bnRlZCBpbW1lZGlhdGVseSBhbG9uZyB3aXRoXG4gICAqIHRoZSBwYXJlbnQgYFRyYW5zaXRpb25gIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gXCJsYXp5IG1vdW50XCIgdGhlIGNvbXBvbmVudCBvbiB0aGVcbiAgICogZmlyc3QgYGluPXt0cnVlfWAgeW91IGNhbiBzZXQgYG1vdW50T25FbnRlcmAuIEFmdGVyIHRoZSBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIHRoZSBjb21wb25lbnQgd2lsbCBzdGF5XG4gICAqIG1vdW50ZWQsIGV2ZW4gb24gXCJleGl0ZWRcIiwgdW5sZXNzIHlvdSBhbHNvIHNwZWNpZnkgYHVubW91bnRPbkV4aXRgLlxuICAgKi9cbiAgbW91bnRPbkVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IHN0YXlzIG1vdW50ZWQgYWZ0ZXIgaXQgcmVhY2hlcyB0aGUgYCdleGl0ZWQnYCBzdGF0ZS5cbiAgICogU2V0IGB1bm1vdW50T25FeGl0YCBpZiB5b3UnZCBwcmVmZXIgdG8gdW5tb3VudCB0aGUgY29tcG9uZW50IGFmdGVyIGl0IGZpbmlzaGVzIGV4aXRpbmcuXG4gICAqL1xuICB1bm1vdW50T25FeGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IGRvZXMgbm90IHBlcmZvcm0gdGhlIGVudGVyIHRyYW5zaXRpb24gd2hlblxuICAgKiBpdCBmaXJzdCBtb3VudHMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBpbmAuIElmIHlvdSB3YW50IHRoaXNcbiAgICogYmVoYXZpb3IsIHNldCBib3RoIGBhcHBlYXJgIGFuZCBgaW5gIHRvIGB0cnVlYC5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogdGhlcmUgYXJlIG5vIHNwZWNpYWwgYXBwZWFyIHN0YXRlcyBsaWtlIGBhcHBlYXJpbmdgL2BhcHBlYXJlZGAsIHRoaXMgcHJvcFxuICAgKiA+IG9ubHkgYWRkcyBhbiBhZGRpdGlvbmFsIGVudGVyIHRyYW5zaXRpb24uIEhvd2V2ZXIsIGluIHRoZVxuICAgKiA+IGA8Q1NTVHJhbnNpdGlvbj5gIGNvbXBvbmVudCB0aGF0IGZpcnN0IGVudGVyIHRyYW5zaXRpb24gZG9lcyByZXN1bHQgaW5cbiAgICogPiBhZGRpdGlvbmFsIGAuYXBwZWFyLSpgIGNsYXNzZXMsIHRoYXQgd2F5IHlvdSBjYW4gY2hvb3NlIHRvIHN0eWxlIGl0XG4gICAqID4gZGlmZmVyZW50bHkuXG4gICAqL1xuICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlbnRlciB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZXhpdCB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24sIGluIG1pbGxpc2Vjb25kcy5cbiAgICogUmVxdWlyZWQgdW5sZXNzIGBhZGRFbmRMaXN0ZW5lcmAgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnM6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXs1MDB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBvciBpbmRpdmlkdWFsbHk6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXt7XG4gICAqICBhcHBlYXI6IDUwMCxcbiAgICogIGVudGVyOiAzMDAsXG4gICAqICBleGl0OiA1MDAsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiAtIGBhcHBlYXJgIGRlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgZW50ZXJgXG4gICAqIC0gYGVudGVyYCBkZWZhdWx0cyB0byBgMGBcbiAgICogLSBgZXhpdGAgZGVmYXVsdHMgdG8gYDBgXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXIgfCB7IGVudGVyPzogbnVtYmVyLCBleGl0PzogbnVtYmVyLCBhcHBlYXI/OiBudW1iZXIgfX1cbiAgICovXG4gIHRpbWVvdXQ6IGZ1bmN0aW9uIHRpbWVvdXQocHJvcHMpIHtcbiAgICB2YXIgcHQgPSB0aW1lb3V0c1NoYXBlO1xuICAgIGlmICghcHJvcHMuYWRkRW5kTGlzdGVuZXIpIHB0ID0gcHQuaXNSZXF1aXJlZDtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwdC5hcHBseSh2b2lkIDAsIFtwcm9wc10uY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIHRyYW5zaXRpb24gZW5kIHRyaWdnZXIuIENhbGxlZCB3aXRoIHRoZSB0cmFuc2l0aW9uaW5nXG4gICAqIERPTSBub2RlIGFuZCBhIGBkb25lYCBjYWxsYmFjay4gQWxsb3dzIGZvciBtb3JlIGZpbmUgZ3JhaW5lZCB0cmFuc2l0aW9uIGVuZFxuICAgKiBsb2dpYy4gVGltZW91dHMgYXJlIHN0aWxsIHVzZWQgYXMgYSBmYWxsYmFjayBpZiBwcm92aWRlZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIGFkZEVuZExpc3RlbmVyPXsobm9kZSwgZG9uZSkgPT4ge1xuICAgKiAgIC8vIHVzZSB0aGUgY3NzIHRyYW5zaXRpb25lbmQgZXZlbnQgdG8gbWFyayB0aGUgZmluaXNoIG9mIGEgdHJhbnNpdGlvblxuICAgKiAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGRvbmUsIGZhbHNlKTtcbiAgICogfX1cbiAgICogYGBgXG4gICAqL1xuICBhZGRFbmRMaXN0ZW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyZWRcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0ZWRcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jXG59IDoge307IC8vIE5hbWUgdGhlIGZ1bmN0aW9uIHNvIGl0IGlzIGNsZWFyZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblRyYW5zaXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBpbjogZmFsc2UsXG4gIG1vdW50T25FbnRlcjogZmFsc2UsXG4gIHVubW91bnRPbkV4aXQ6IGZhbHNlLFxuICBhcHBlYXI6IGZhbHNlLFxuICBlbnRlcjogdHJ1ZSxcbiAgZXhpdDogdHJ1ZSxcbiAgb25FbnRlcjogbm9vcCxcbiAgb25FbnRlcmluZzogbm9vcCxcbiAgb25FbnRlcmVkOiBub29wLFxuICBvbkV4aXQ6IG5vb3AsXG4gIG9uRXhpdGluZzogbm9vcCxcbiAgb25FeGl0ZWQ6IG5vb3Bcbn07XG5UcmFuc2l0aW9uLlVOTU9VTlRFRCA9IFVOTU9VTlRFRDtcblRyYW5zaXRpb24uRVhJVEVEID0gRVhJVEVEO1xuVHJhbnNpdGlvbi5FTlRFUklORyA9IEVOVEVSSU5HO1xuVHJhbnNpdGlvbi5FTlRFUkVEID0gRU5URVJFRDtcblRyYW5zaXRpb24uRVhJVElORyA9IEVYSVRJTkc7XG5leHBvcnQgZGVmYXVsdCBUcmFuc2l0aW9uOyJdLCJuYW1lcyI6WyJkaXNhYmxlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX2luaGVyaXRzTG9vc2UiLCJQcm9wVHlwZXMiLCJSZWFjdCIsIlJlYWN0RE9NIiwiY29uZmlnIiwidGltZW91dHNTaGFwZSIsIlRyYW5zaXRpb25Hcm91cENvbnRleHQiLCJmb3JjZVJlZmxvdyIsIlVOTU9VTlRFRCIsIkVYSVRFRCIsIkVOVEVSSU5HIiwiRU5URVJFRCIsIkVYSVRJTkciLCJUcmFuc2l0aW9uIiwiX1JlYWN0JENvbXBvbmVudCIsInByb3BzIiwiY29udGV4dCIsIl90aGlzIiwiY2FsbCIsInBhcmVudEdyb3VwIiwiYXBwZWFyIiwiaXNNb3VudGluZyIsImVudGVyIiwiaW5pdGlhbFN0YXR1cyIsImFwcGVhclN0YXR1cyIsImluIiwidW5tb3VudE9uRXhpdCIsIm1vdW50T25FbnRlciIsInN0YXRlIiwic3RhdHVzIiwibmV4dENhbGxiYWNrIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiX3JlZiIsInByZXZTdGF0ZSIsIm5leHRJbiIsIl9wcm90byIsInByb3RvdHlwZSIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlU3RhdHVzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwibmV4dFN0YXR1cyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY2FuY2VsTmV4dENhbGxiYWNrIiwiZ2V0VGltZW91dHMiLCJ0aW1lb3V0IiwiZXhpdCIsInVuZGVmaW5lZCIsIm1vdW50aW5nIiwibm9kZSIsIm5vZGVSZWYiLCJjdXJyZW50IiwiZmluZERPTU5vZGUiLCJwZXJmb3JtRW50ZXIiLCJwZXJmb3JtRXhpdCIsInNldFN0YXRlIiwiX3RoaXMyIiwiYXBwZWFyaW5nIiwiX3JlZjIiLCJtYXliZU5vZGUiLCJtYXliZUFwcGVhcmluZyIsInRpbWVvdXRzIiwiZW50ZXJUaW1lb3V0Iiwic2FmZVNldFN0YXRlIiwib25FbnRlcmVkIiwib25FbnRlciIsIm9uRW50ZXJpbmciLCJvblRyYW5zaXRpb25FbmQiLCJfdGhpczMiLCJvbkV4aXRlZCIsIm9uRXhpdCIsIm9uRXhpdGluZyIsImNhbmNlbCIsIm5leHRTdGF0ZSIsImNhbGxiYWNrIiwic2V0TmV4dENhbGxiYWNrIiwiX3RoaXM0IiwiYWN0aXZlIiwiZXZlbnQiLCJoYW5kbGVyIiwiZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lciIsImFkZEVuZExpc3RlbmVyIiwic2V0VGltZW91dCIsIl9yZWYzIiwibWF5YmVOZXh0Q2FsbGJhY2siLCJyZW5kZXIiLCJfdGhpcyRwcm9wcyIsImNoaWxkcmVuIiwiX2luIiwiX21vdW50T25FbnRlciIsIl91bm1vdW50T25FeGl0IiwiX2FwcGVhciIsIl9lbnRlciIsIl9leGl0IiwiX3RpbWVvdXQiLCJfYWRkRW5kTGlzdGVuZXIiLCJfb25FbnRlciIsIl9vbkVudGVyaW5nIiwiX29uRW50ZXJlZCIsIl9vbkV4aXQiLCJfb25FeGl0aW5nIiwiX29uRXhpdGVkIiwiX25vZGVSZWYiLCJjaGlsZFByb3BzIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJjbG9uZUVsZW1lbnQiLCJDaGlsZHJlbiIsIm9ubHkiLCJDb21wb25lbnQiLCJjb250ZXh0VHlwZSIsInByb3BUeXBlcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInNoYXBlIiwiRWxlbWVudCIsImFueSIsInByb3BWYWx1ZSIsImtleSIsImNvbXBvbmVudE5hbWUiLCJsb2NhdGlvbiIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImluc3RhbmNlT2YiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJvbmVPZlR5cGUiLCJmdW5jIiwiaXNSZXF1aXJlZCIsImVsZW1lbnQiLCJib29sIiwicHQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImFwcGx5IiwiY29uY2F0Iiwibm9vcCIsImRlZmF1bHRQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1374\n")},8874:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ esm_TransitionGroup)\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nvar objectWithoutPropertiesLoose = __webpack_require__(7958);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __webpack_require__(3123);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nvar assertThisInitialized = __webpack_require__(6464);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js + 1 modules\nvar inheritsLoose = __webpack_require__(1177);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(5466);\n// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js\nvar TransitionGroupContext = __webpack_require__(8992);\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/utils/ChildMapping.js\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\n\nfunction getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && (0,react.isValidElement)(child) ? mapFn(child) : child;\n  };\n  var result = Object.create(null);\n  if (children) react.Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n  var i;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n  return childMapping;\n}\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\nfunction getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return (0,react.cloneElement)(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!(0,react.isValidElement)(child)) return;\n    var hasPrev = (key in prevChildMapping);\n    var hasNext = (key in nextChildMapping);\n    var prevChild = prevChildMapping[key];\n    var isLeaving = (0,react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = (0,react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = (0,react.cloneElement)(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && (0,react.isValidElement)(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = (0,react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}\n;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroup.js\n\n\n\n\n\n\n\n\nvar values = Object.values || function (obj) {\n  return Object.keys(obj).map(function (k) {\n    return obj[k];\n  });\n};\nvar defaultProps = {\n  component: 'div',\n  childFactory: function childFactory(child) {\n    return child;\n  }\n};\n/**\n * The `<TransitionGroup>` component manages a set of transition components\n * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition\n * components, `<TransitionGroup>` is a state machine for managing the mounting\n * and unmounting of components over time.\n *\n * Consider the example below. As items are removed or added to the TodoList the\n * `in` prop is toggled automatically by the `<TransitionGroup>`.\n *\n * Note that `<TransitionGroup>`  does not define any animation behavior!\n * Exactly _how_ a list item animates is up to the individual transition\n * component. This means you can mix and match animations across different list\n * items.\n */\n\nvar TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  (0,inheritsLoose/* default */.Z)(TransitionGroup, _React$Component);\n  function TransitionGroup(props, context) {\n    var _this;\n    _this = _React$Component.call(this, props, context) || this;\n    var handleExited = _this.handleExited.bind((0,assertThisInitialized/* default */.Z)(_this)); // Initial children should all be entering, dependent on appear\n\n    _this.state = {\n      contextValue: {\n        isMounting: true\n      },\n      handleExited: handleExited,\n      firstRender: true\n    };\n    return _this;\n  }\n  var _proto = TransitionGroup.prototype;\n  _proto.componentDidMount = function componentDidMount() {\n    this.mounted = true;\n    this.setState({\n      contextValue: {\n        isMounting: false\n      }\n    });\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.mounted = false;\n  };\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {\n    var prevChildMapping = _ref.children,\n      handleExited = _ref.handleExited,\n      firstRender = _ref.firstRender;\n    return {\n      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),\n      firstRender: false\n    };\n  } // node is `undefined` when user provided `nodeRef` prop\n  ;\n\n  _proto.handleExited = function handleExited(child, node) {\n    var currentChildMapping = getChildMapping(this.props.children);\n    if (child.key in currentChildMapping) return;\n    if (child.props.onExited) {\n      child.props.onExited(node);\n    }\n    if (this.mounted) {\n      this.setState(function (state) {\n        var children = (0,esm_extends/* default */.Z)({}, state.children);\n        delete children[child.key];\n        return {\n          children: children\n        };\n      });\n    }\n  };\n  _proto.render = function render() {\n    var _this$props = this.props,\n      Component = _this$props.component,\n      childFactory = _this$props.childFactory,\n      props = (0,objectWithoutPropertiesLoose/* default */.Z)(_this$props, [\"component\", \"childFactory\"]);\n    var contextValue = this.state.contextValue;\n    var children = values(this.state.children).map(childFactory);\n    delete props.appear;\n    delete props.enter;\n    delete props.exit;\n    if (Component === null) {\n      return /*#__PURE__*/react.createElement(TransitionGroupContext/* default */.Z.Provider, {\n        value: contextValue\n      }, children);\n    }\n    return /*#__PURE__*/react.createElement(TransitionGroupContext/* default */.Z.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/react.createElement(Component, props, children));\n  };\n  return TransitionGroup;\n}(react.Component);\nTransitionGroup.propTypes =  false ? 0 : {};\nTransitionGroup.defaultProps = defaultProps;\n/* harmony default export */ const esm_TransitionGroup = (TransitionGroup);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c0IsV0FBVyxDQUFDdEIsWUFBWTtNQUN2QzdCLEtBQUssR0FBR2lCLCtDQUE2QixDQUFDa0MsV0FBVyxFQUFFLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBRXJGLElBQUlkLFlBQVksR0FBRyxJQUFJLENBQUNELEtBQUssQ0FBQ0MsWUFBWTtJQUMxQyxJQUFJL0QsUUFBUSxHQUFHa0QsTUFBTSxDQUFDLElBQUksQ0FBQ1ksS0FBSyxDQUFDOUQsUUFBUSxDQUFDLENBQUNPLEdBQUcsQ0FBQ2dELFlBQVksQ0FBQztJQUM1RCxPQUFPN0IsS0FBSyxDQUFDSyxNQUFNO0lBQ25CLE9BQU9MLEtBQUssQ0FBQ00sS0FBSztJQUNsQixPQUFPTixLQUFLLENBQUNPLElBQUk7SUFFakIsSUFBSTZDLFNBQVMsS0FBSyxJQUFJLEVBQUU7TUFDdEIsT0FBTyxhQUFhOUIsbUJBQW1CLENBQUNDLHFDQUFzQixDQUFDK0IsUUFBUSxFQUFFO1FBQ3ZFQyxLQUFLLEVBQUVsQjtNQUNULENBQUMsRUFBRS9ELFFBQVEsQ0FBQztJQUNkO0lBRUEsT0FBTyxhQUFhZ0QsbUJBQW1CLENBQUNDLHFDQUFzQixDQUFDK0IsUUFBUSxFQUFFO01BQ3ZFQyxLQUFLLEVBQUVsQjtJQUNULENBQUMsRUFBRSxhQUFhZixtQkFBbUIsQ0FBQzhCLFNBQVMsRUFBRXBELEtBQUssRUFBRTFCLFFBQVEsQ0FBQyxDQUFDO0VBQ2xFLENBQUM7RUFFRCxPQUFPd0QsZUFBZTtBQUN4QixDQUFDLENBQUNSLGVBQWUsQ0FBQztBQUVsQlEsZUFBZSxDQUFDMEIsU0FBUyxHQUFHQyxNQUFxQyxHQUFHLENBeURuRSxHQUFHLENBQUMsQ0FBQztBQUNOM0IsZUFBZSxDQUFDSCxZQUFZLEdBQUdBLFlBQVk7QUFDM0MsMERBQWVHLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS91dGlscy9DaGlsZE1hcHBpbmcuanM/MjBjOCIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9UcmFuc2l0aW9uR3JvdXAuanM/NTVlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGlsZHJlbiwgY2xvbmVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogR2l2ZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gLCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcga2V5IHRvIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Kn0gY2hpbGRyZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcHBpbmcgb2Yga2V5IHRvIGNoaWxkXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkTWFwcGluZyhjaGlsZHJlbiwgbWFwRm4pIHtcbiAgdmFyIG1hcHBlciA9IGZ1bmN0aW9uIG1hcHBlcihjaGlsZCkge1xuICAgIHJldHVybiBtYXBGbiAmJiBpc1ZhbGlkRWxlbWVudChjaGlsZCkgPyBtYXBGbihjaGlsZCkgOiBjaGlsZDtcbiAgfTtcblxuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGNoaWxkcmVuKSBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGM7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgLy8gcnVuIHRoZSBtYXAgZnVuY3Rpb24gaGVyZSBpbnN0ZWFkIHNvIHRoYXQgdGhlIGtleSBpcyB0aGUgY29tcHV0ZWQgb25lXG4gICAgcmVzdWx0W2NoaWxkLmtleV0gPSBtYXBwZXIoY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogV2hlbiB5b3UncmUgYWRkaW5nIG9yIHJlbW92aW5nIGNoaWxkcmVuIHNvbWUgbWF5IGJlIGFkZGVkIG9yIHJlbW92ZWQgaW4gdGhlXG4gKiBzYW1lIHJlbmRlciBwYXNzLiBXZSB3YW50IHRvIHNob3cgKmJvdGgqIHNpbmNlIHdlIHdhbnQgdG8gc2ltdWx0YW5lb3VzbHlcbiAqIGFuaW1hdGUgZWxlbWVudHMgaW4gYW5kIG91dC4gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHByZXZpb3VzIHNldCBvZiBrZXlzXG4gKiBhbmQgYSBuZXcgc2V0IG9mIGtleXMgYW5kIG1lcmdlcyB0aGVtIHdpdGggaXRzIGJlc3QgZ3Vlc3Mgb2YgdGhlIGNvcnJlY3RcbiAqIG9yZGVyaW5nLiBJbiB0aGUgZnV0dXJlIHdlIG1heSBleHBvc2Ugc29tZSBvZiB0aGUgdXRpbGl0aWVzIGluXG4gKiBSZWFjdE11bHRpQ2hpbGQgdG8gbWFrZSB0aGlzIGVhc3ksIGJ1dCBmb3Igbm93IFJlYWN0IGl0c2VsZiBkb2VzIG5vdFxuICogZGlyZWN0bHkgaGF2ZSB0aGlzIGNvbmNlcHQgb2YgdGhlIHVuaW9uIG9mIHByZXZDaGlsZHJlbiBhbmQgbmV4dENoaWxkcmVuXG4gKiBzbyB3ZSBpbXBsZW1lbnQgaXQgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJldiBwcmV2IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICogQHBhcmFtIHtvYmplY3R9IG5leHQgbmV4dCBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gKiBgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZygpYC5cbiAqIEByZXR1cm4ge29iamVjdH0gYSBrZXkgc2V0IHRoYXQgY29udGFpbnMgYWxsIGtleXMgaW4gYHByZXZgIGFuZCBhbGwga2V5c1xuICogaW4gYG5leHRgIGluIGEgcmVhc29uYWJsZSBvcmRlci5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDaGlsZE1hcHBpbmdzKHByZXYsIG5leHQpIHtcbiAgcHJldiA9IHByZXYgfHwge307XG4gIG5leHQgPSBuZXh0IHx8IHt9O1xuXG4gIGZ1bmN0aW9uIGdldFZhbHVlRm9yS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gbmV4dCA/IG5leHRba2V5XSA6IHByZXZba2V5XTtcbiAgfSAvLyBGb3IgZWFjaCBrZXkgb2YgYG5leHRgLCB0aGUgbGlzdCBvZiBrZXlzIHRvIGluc2VydCBiZWZvcmUgdGhhdCBrZXkgaW5cbiAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcblxuXG4gIHZhciBuZXh0S2V5c1BlbmRpbmcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgcGVuZGluZ0tleXMgPSBbXTtcblxuICBmb3IgKHZhciBwcmV2S2V5IGluIHByZXYpIHtcbiAgICBpZiAocHJldktleSBpbiBuZXh0KSB7XG4gICAgICBpZiAocGVuZGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRLZXlzUGVuZGluZ1twcmV2S2V5XSA9IHBlbmRpbmdLZXlzO1xuICAgICAgICBwZW5kaW5nS2V5cyA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nS2V5cy5wdXNoKHByZXZLZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgY2hpbGRNYXBwaW5nID0ge307XG5cbiAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0KSB7XG4gICAgaWYgKG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGVuZGluZ05leHRLZXkgPSBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV07XG4gICAgICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ05leHRLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5XSA9IGdldFZhbHVlRm9yS2V5KG5leHRLZXkpO1xuICB9IC8vIEZpbmFsbHksIGFkZCB0aGUga2V5cyB3aGljaCBkaWRuJ3QgYXBwZWFyIGJlZm9yZSBhbnkga2V5IGluIGBuZXh0YFxuXG5cbiAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hpbGRNYXBwaW5nW3BlbmRpbmdLZXlzW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdLZXlzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZE1hcHBpbmc7XG59XG5cbmZ1bmN0aW9uIGdldFByb3AoY2hpbGQsIHByb3AsIHByb3BzKSB7XG4gIHJldHVybiBwcm9wc1twcm9wXSAhPSBudWxsID8gcHJvcHNbcHJvcF0gOiBjaGlsZC5wcm9wc1twcm9wXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluaXRpYWxDaGlsZE1hcHBpbmcocHJvcHMsIG9uRXhpdGVkKSB7XG4gIHJldHVybiBnZXRDaGlsZE1hcHBpbmcocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIG9uRXhpdGVkOiBvbkV4aXRlZC5iaW5kKG51bGwsIGNoaWxkKSxcbiAgICAgIGluOiB0cnVlLFxuICAgICAgYXBwZWFyOiBnZXRQcm9wKGNoaWxkLCAnYXBwZWFyJywgcHJvcHMpLFxuICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIHByb3BzKSxcbiAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgcHJvcHMpXG4gICAgfSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRDaGlsZE1hcHBpbmcobmV4dFByb3BzLCBwcmV2Q2hpbGRNYXBwaW5nLCBvbkV4aXRlZCkge1xuICB2YXIgbmV4dENoaWxkTWFwcGluZyA9IGdldENoaWxkTWFwcGluZyhuZXh0UHJvcHMuY2hpbGRyZW4pO1xuICB2YXIgY2hpbGRyZW4gPSBtZXJnZUNoaWxkTWFwcGluZ3MocHJldkNoaWxkTWFwcGluZywgbmV4dENoaWxkTWFwcGluZyk7XG4gIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltrZXldO1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSByZXR1cm47XG4gICAgdmFyIGhhc1ByZXYgPSAoa2V5IGluIHByZXZDaGlsZE1hcHBpbmcpO1xuICAgIHZhciBoYXNOZXh0ID0gKGtleSBpbiBuZXh0Q2hpbGRNYXBwaW5nKTtcbiAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkTWFwcGluZ1trZXldO1xuICAgIHZhciBpc0xlYXZpbmcgPSBpc1ZhbGlkRWxlbWVudChwcmV2Q2hpbGQpICYmICFwcmV2Q2hpbGQucHJvcHMuaW47IC8vIGl0ZW0gaXMgbmV3IChlbnRlcmluZylcblxuICAgIGlmIChoYXNOZXh0ICYmICghaGFzUHJldiB8fCBpc0xlYXZpbmcpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZW50ZXJpbmcnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIG9uRXhpdGVkOiBvbkV4aXRlZC5iaW5kKG51bGwsIGNoaWxkKSxcbiAgICAgICAgaW46IHRydWUsXG4gICAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgbmV4dFByb3BzKSxcbiAgICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIG5leHRQcm9wcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWhhc05leHQgJiYgaGFzUHJldiAmJiAhaXNMZWF2aW5nKSB7XG4gICAgICAvLyBpdGVtIGlzIG9sZCAoZXhpdGluZylcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdsZWF2aW5nJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9IGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBpbjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaGFzTmV4dCAmJiBoYXNQcmV2ICYmIGlzVmFsaWRFbGVtZW50KHByZXZDaGlsZCkpIHtcbiAgICAgIC8vIGl0ZW0gaGFzbid0IGNoYW5nZWQgdHJhbnNpdGlvbiBzdGF0ZXNcbiAgICAgIC8vIGNvcHkgb3ZlciB0aGUgbGFzdCB0cmFuc2l0aW9uIHByb3BzO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3VuY2hhbmdlZCcsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgICBpbjogcHJldkNoaWxkLnByb3BzLmluLFxuICAgICAgICBleGl0OiBnZXRQcm9wKGNoaWxkLCAnZXhpdCcsIG5leHRQcm9wcyksXG4gICAgICAgIGVudGVyOiBnZXRQcm9wKGNoaWxkLCAnZW50ZXInLCBuZXh0UHJvcHMpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2hpbGRyZW47XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVHJhbnNpdGlvbkdyb3VwQ29udGV4dCBmcm9tICcuL1RyYW5zaXRpb25Hcm91cENvbnRleHQnO1xuaW1wb3J0IHsgZ2V0Q2hpbGRNYXBwaW5nLCBnZXRJbml0aWFsQ2hpbGRNYXBwaW5nLCBnZXROZXh0Q2hpbGRNYXBwaW5nIH0gZnJvbSAnLi91dGlscy9DaGlsZE1hcHBpbmcnO1xuXG52YXIgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBvYmpba107XG4gIH0pO1xufTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29tcG9uZW50OiAnZGl2JyxcbiAgY2hpbGRGYWN0b3J5OiBmdW5jdGlvbiBjaGlsZEZhY3RvcnkoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbn07XG4vKipcbiAqIFRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIGNvbXBvbmVudCBtYW5hZ2VzIGEgc2V0IG9mIHRyYW5zaXRpb24gY29tcG9uZW50c1xuICogKGA8VHJhbnNpdGlvbj5gIGFuZCBgPENTU1RyYW5zaXRpb24+YCkgaW4gYSBsaXN0LiBMaWtlIHdpdGggdGhlIHRyYW5zaXRpb25cbiAqIGNvbXBvbmVudHMsIGA8VHJhbnNpdGlvbkdyb3VwPmAgaXMgYSBzdGF0ZSBtYWNoaW5lIGZvciBtYW5hZ2luZyB0aGUgbW91bnRpbmdcbiAqIGFuZCB1bm1vdW50aW5nIG9mIGNvbXBvbmVudHMgb3ZlciB0aW1lLlxuICpcbiAqIENvbnNpZGVyIHRoZSBleGFtcGxlIGJlbG93LiBBcyBpdGVtcyBhcmUgcmVtb3ZlZCBvciBhZGRlZCB0byB0aGUgVG9kb0xpc3QgdGhlXG4gKiBgaW5gIHByb3AgaXMgdG9nZ2xlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gLlxuICpcbiAqIE5vdGUgdGhhdCBgPFRyYW5zaXRpb25Hcm91cD5gICBkb2VzIG5vdCBkZWZpbmUgYW55IGFuaW1hdGlvbiBiZWhhdmlvciFcbiAqIEV4YWN0bHkgX2hvd18gYSBsaXN0IGl0ZW0gYW5pbWF0ZXMgaXMgdXAgdG8gdGhlIGluZGl2aWR1YWwgdHJhbnNpdGlvblxuICogY29tcG9uZW50LiBUaGlzIG1lYW5zIHlvdSBjYW4gbWl4IGFuZCBtYXRjaCBhbmltYXRpb25zIGFjcm9zcyBkaWZmZXJlbnQgbGlzdFxuICogaXRlbXMuXG4gKi9cblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUcmFuc2l0aW9uR3JvdXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25Hcm91cChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuXG4gICAgdmFyIGhhbmRsZUV4aXRlZCA9IF90aGlzLmhhbmRsZUV4aXRlZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsgLy8gSW5pdGlhbCBjaGlsZHJlbiBzaG91bGQgYWxsIGJlIGVudGVyaW5nLCBkZXBlbmRlbnQgb24gYXBwZWFyXG5cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6IHRydWVcbiAgICAgIH0sXG4gICAgICBoYW5kbGVFeGl0ZWQ6IGhhbmRsZUV4aXRlZCxcbiAgICAgIGZpcnN0UmVuZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gIH07XG5cbiAgVHJhbnNpdGlvbkdyb3VwLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgcHJldkNoaWxkTWFwcGluZyA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgIGhhbmRsZUV4aXRlZCA9IF9yZWYuaGFuZGxlRXhpdGVkLFxuICAgICAgICBmaXJzdFJlbmRlciA9IF9yZWYuZmlyc3RSZW5kZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBmaXJzdFJlbmRlciA/IGdldEluaXRpYWxDaGlsZE1hcHBpbmcobmV4dFByb3BzLCBoYW5kbGVFeGl0ZWQpIDogZ2V0TmV4dENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIGhhbmRsZUV4aXRlZCksXG4gICAgICBmaXJzdFJlbmRlcjogZmFsc2VcbiAgICB9O1xuICB9IC8vIG5vZGUgaXMgYHVuZGVmaW5lZGAgd2hlbiB1c2VyIHByb3ZpZGVkIGBub2RlUmVmYCBwcm9wXG4gIDtcblxuICBfcHJvdG8uaGFuZGxlRXhpdGVkID0gZnVuY3Rpb24gaGFuZGxlRXhpdGVkKGNoaWxkLCBub2RlKSB7XG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBnZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkLmtleSBpbiBjdXJyZW50Q2hpbGRNYXBwaW5nKSByZXR1cm47XG5cbiAgICBpZiAoY2hpbGQucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgIGNoaWxkLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IF9leHRlbmRzKHt9LCBzdGF0ZS5jaGlsZHJlbik7XG5cbiAgICAgICAgZGVsZXRlIGNoaWxkcmVuW2NoaWxkLmtleV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBDb21wb25lbnQgPSBfdGhpcyRwcm9wcy5jb21wb25lbnQsXG4gICAgICAgIGNoaWxkRmFjdG9yeSA9IF90aGlzJHByb3BzLmNoaWxkRmFjdG9yeSxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50XCIsIFwiY2hpbGRGYWN0b3J5XCJdKTtcblxuICAgIHZhciBjb250ZXh0VmFsdWUgPSB0aGlzLnN0YXRlLmNvbnRleHRWYWx1ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2YWx1ZXModGhpcy5zdGF0ZS5jaGlsZHJlbikubWFwKGNoaWxkRmFjdG9yeSk7XG4gICAgZGVsZXRlIHByb3BzLmFwcGVhcjtcbiAgICBkZWxldGUgcHJvcHMuZW50ZXI7XG4gICAgZGVsZXRlIHByb3BzLmV4aXQ7XG5cbiAgICBpZiAoQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbikpO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uR3JvdXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb25Hcm91cC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBgPFRyYW5zaXRpb25Hcm91cD5gIHJlbmRlcnMgYSBgPGRpdj5gIGJ5IGRlZmF1bHQuIFlvdSBjYW4gY2hhbmdlIHRoaXNcbiAgICogYmVoYXZpb3IgYnkgcHJvdmlkaW5nIGEgYGNvbXBvbmVudGAgcHJvcC5cbiAgICogSWYgeW91IHVzZSBSZWFjdCB2MTYrIGFuZCB3b3VsZCBsaWtlIHRvIGF2b2lkIGEgd3JhcHBpbmcgYDxkaXY+YCBlbGVtZW50XG4gICAqIHlvdSBjYW4gcGFzcyBpbiBgY29tcG9uZW50PXtudWxsfWAuIFRoaXMgaXMgdXNlZnVsIGlmIHRoZSB3cmFwcGluZyBkaXZcbiAgICogYm9ya3MgeW91ciBjc3Mgc3R5bGVzLlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBgPFRyYW5zaXRpb24+YCBjb21wb25lbnRzLCB0aGF0IGFyZSB0b2dnbGVkIGBpbmAgYW5kIG91dCBhcyB0aGV5XG4gICAqIGxlYXZlLiB0aGUgYDxUcmFuc2l0aW9uR3JvdXA+YCB3aWxsIGluamVjdCBzcGVjaWZpYyB0cmFuc2l0aW9uIHByb3BzLCBzb1xuICAgKiByZW1lbWJlciB0byBzcHJlYWQgdGhlbSB0aHJvdWdoIGlmIHlvdSBhcmUgd3JhcHBpbmcgdGhlIGA8VHJhbnNpdGlvbj5gIGFzXG4gICAqIHdpdGggb3VyIGA8RmFkZT5gIGV4YW1wbGUuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgY29tcG9uZW50IGlzIG1lYW50IGZvciBtdWx0aXBsZSBgVHJhbnNpdGlvbmAgb3IgYENTU1RyYW5zaXRpb25gXG4gICAqIGNoaWxkcmVuLCBzb21ldGltZXMgeW91IG1heSB3YW50IHRvIGhhdmUgYSBzaW5nbGUgdHJhbnNpdGlvbiBjaGlsZCB3aXRoXG4gICAqIGNvbnRlbnQgdGhhdCB5b3Ugd2FudCB0byBiZSB0cmFuc2l0aW9uZWQgb3V0IGFuZCBpbiB3aGVuIHlvdSBjaGFuZ2UgaXRcbiAgICogKGUuZy4gcm91dGVzLCBpbWFnZXMgZXRjLikgSW4gdGhhdCBjYXNlIHlvdSBjYW4gY2hhbmdlIHRoZSBga2V5YCBwcm9wIG9mXG4gICAqIHRoZSB0cmFuc2l0aW9uIGNoaWxkIGFzIHlvdSBjaGFuZ2UgaXRzIGNvbnRlbnQsIHRoaXMgd2lsbCBjYXVzZVxuICAgKiBgVHJhbnNpdGlvbkdyb3VwYCB0byB0cmFuc2l0aW9uIHRoZSBjaGlsZCBvdXQgYW5kIGJhY2sgaW4uXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgYXBwZWFyIGFuaW1hdGlvbnNcbiAgICogZm9yIGFsbCBjaGlsZHJlbi4gTm90ZSB0aGF0IHNwZWNpZnlpbmcgdGhpcyB3aWxsIG92ZXJyaWRlIGFueSBkZWZhdWx0cyBzZXRcbiAgICogb24gaW5kaXZpZHVhbCBjaGlsZHJlbiBUcmFuc2l0aW9ucy5cbiAgICovXG4gIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZW50ZXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGV4aXQgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFlvdSBtYXkgbmVlZCB0byBhcHBseSByZWFjdGl2ZSB1cGRhdGVzIHRvIGEgY2hpbGQgYXMgaXQgaXMgZXhpdGluZy5cbiAgICogVGhpcyBpcyBnZW5lcmFsbHkgZG9uZSBieSB1c2luZyBgY2xvbmVFbGVtZW50YCBob3dldmVyIGluIHRoZSBjYXNlIG9mIGFuIGV4aXRpbmdcbiAgICogY2hpbGQgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGFuZCBub3QgYWNjZXNzaWJsZSB0byB0aGUgY29uc3VtZXIuXG4gICAqXG4gICAqIElmIHlvdSBkbyBuZWVkIHRvIHVwZGF0ZSBhIGNoaWxkIGFzIGl0IGxlYXZlcyB5b3UgY2FuIHByb3ZpZGUgYSBgY2hpbGRGYWN0b3J5YFxuICAgKiB0byB3cmFwIGV2ZXJ5IGNoaWxkLCBldmVuIHRoZSBvbmVzIHRoYXQgYXJlIGxlYXZpbmcuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKGNoaWxkOiBSZWFjdEVsZW1lbnQpIC0+IFJlYWN0RWxlbWVudFxuICAgKi9cbiAgY2hpbGRGYWN0b3J5OiBQcm9wVHlwZXMuZnVuY1xufSA6IHt9O1xuVHJhbnNpdGlvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb25Hcm91cDsiXSwibmFtZXMiOlsiQ2hpbGRyZW4iLCJjbG9uZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsImdldENoaWxkTWFwcGluZyIsImNoaWxkcmVuIiwibWFwRm4iLCJtYXBwZXIiLCJjaGlsZCIsInJlc3VsdCIsIk9iamVjdCIsImNyZWF0ZSIsIm1hcCIsImMiLCJmb3JFYWNoIiwia2V5IiwibWVyZ2VDaGlsZE1hcHBpbmdzIiwicHJldiIsIm5leHQiLCJnZXRWYWx1ZUZvcktleSIsIm5leHRLZXlzUGVuZGluZyIsInBlbmRpbmdLZXlzIiwicHJldktleSIsImxlbmd0aCIsInB1c2giLCJpIiwiY2hpbGRNYXBwaW5nIiwibmV4dEtleSIsInBlbmRpbmdOZXh0S2V5IiwiZ2V0UHJvcCIsInByb3AiLCJwcm9wcyIsImdldEluaXRpYWxDaGlsZE1hcHBpbmciLCJvbkV4aXRlZCIsImJpbmQiLCJpbiIsImFwcGVhciIsImVudGVyIiwiZXhpdCIsImdldE5leHRDaGlsZE1hcHBpbmciLCJuZXh0UHJvcHMiLCJwcmV2Q2hpbGRNYXBwaW5nIiwibmV4dENoaWxkTWFwcGluZyIsImtleXMiLCJoYXNQcmV2IiwiaGFzTmV4dCIsInByZXZDaGlsZCIsImlzTGVhdmluZyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX2V4dGVuZHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX2luaGVyaXRzTG9vc2UiLCJQcm9wVHlwZXMiLCJSZWFjdCIsIlRyYW5zaXRpb25Hcm91cENvbnRleHQiLCJ2YWx1ZXMiLCJvYmoiLCJrIiwiZGVmYXVsdFByb3BzIiwiY29tcG9uZW50IiwiY2hpbGRGYWN0b3J5IiwiVHJhbnNpdGlvbkdyb3VwIiwiX1JlYWN0JENvbXBvbmVudCIsImNvbnRleHQiLCJfdGhpcyIsImNhbGwiLCJoYW5kbGVFeGl0ZWQiLCJzdGF0ZSIsImNvbnRleHRWYWx1ZSIsImlzTW91bnRpbmciLCJmaXJzdFJlbmRlciIsIl9wcm90byIsInByb3RvdHlwZSIsImNvbXBvbmVudERpZE1vdW50IiwibW91bnRlZCIsInNldFN0YXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJfcmVmIiwibm9kZSIsImN1cnJlbnRDaGlsZE1hcHBpbmciLCJyZW5kZXIiLCJfdGhpcyRwcm9wcyIsIkNvbXBvbmVudCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwicHJvcFR5cGVzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiYW55IiwiYm9vbCIsImZ1bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8874\n")},8992:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5466);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (react__WEBPACK_IMPORTED_MODULE_0__.createContext(null));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTBCO0FBQzFCLGlFQUFlQSxnREFBbUIsQ0FBQyxJQUFJLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9UcmFuc2l0aW9uR3JvdXBDb250ZXh0LmpzP2QwZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7Il0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8992\n")},8109:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ forceReflow)\n/* harmony export */ });\nvar forceReflow = function forceReflow(node) {\n  return node.scrollTop;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEwOS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBTyxJQUFJQSxXQUFXLEdBQUcsU0FBU0EsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFO0VBQ2xELE9BQU9BLElBQUksQ0FBQ0MsU0FBUztBQUN2QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vdXRpbHMvcmVmbG93LmpzP2I1N2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBmb3JjZVJlZmxvdyA9IGZ1bmN0aW9uIGZvcmNlUmVmbG93KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuc2Nyb2xsVG9wO1xufTsiXSwibmFtZXMiOlsiZm9yY2VSZWZsb3ciLCJub2RlIiwic2Nyb2xsVG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8109\n")},4043:(__unused_webpack_module,exports,__webpack_require__)=>{eval('/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar f = __webpack_require__(5466),\n  k = Symbol.for("react.element"),\n  l = Symbol.for("react.fragment"),\n  m = Object.prototype.hasOwnProperty,\n  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,\n  p = {\n    key: !0,\n    ref: !0,\n    __self: !0,\n    __source: !0\n  };\nfunction q(c, a, g) {\n  var b,\n    d = {},\n    e = null,\n    h = null;\n  void 0 !== g && (e = "" + g);\n  void 0 !== a.key && (e = "" + a.key);\n  void 0 !== a.ref && (h = a.ref);\n  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);\n  return {\n    $$typeof: k,\n    type: c,\n    key: e,\n    ref: h,\n    props: d,\n    _owner: n.current\n  };\n}\nexports.Fragment = l;\nexports.jsx = q;\nexports.jsxs = q;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA0My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFBQSxJQUFJQSxDQUFDLEdBQUNDLG1CQUFPLENBQUMsSUFBTyxDQUFDO0VBQUNDLENBQUMsR0FBQ0MsTUFBTSxDQUFDQyxHQUFHLENBQUMsZUFBZSxDQUFDO0VBQUNDLENBQUMsR0FBQ0YsTUFBTSxDQUFDQyxHQUFHLENBQUMsZ0JBQWdCLENBQUM7RUFBQ0UsQ0FBQyxHQUFDQyxNQUFNLENBQUNDLFNBQVMsQ0FBQ0MsY0FBYztFQUFDQyxDQUFDLEdBQUNWLENBQUMsQ0FBQ1csa0RBQWtELENBQUNDLGlCQUFpQjtFQUFDQyxDQUFDLEdBQUM7SUFBQ0MsR0FBRyxFQUFDLENBQUMsQ0FBQztJQUFDQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO0lBQUNDLE1BQU0sRUFBQyxDQUFDLENBQUM7SUFBQ0MsUUFBUSxFQUFDLENBQUM7RUFBQyxDQUFDO0FBQ25QLFNBQVNDLENBQUNBLENBQUNDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDLEVBQUM7RUFBQyxJQUFJQyxDQUFDO0lBQUNDLENBQUMsR0FBQyxDQUFDLENBQUM7SUFBQ0MsQ0FBQyxHQUFDLElBQUk7SUFBQ0MsQ0FBQyxHQUFDLElBQUk7RUFBQyxLQUFLLENBQUMsS0FBR0osQ0FBQyxLQUFHRyxDQUFDLEdBQUMsRUFBRSxHQUFDSCxDQUFDLENBQUM7RUFBQyxLQUFLLENBQUMsS0FBR0QsQ0FBQyxDQUFDTixHQUFHLEtBQUdVLENBQUMsR0FBQyxFQUFFLEdBQUNKLENBQUMsQ0FBQ04sR0FBRyxDQUFDO0VBQUMsS0FBSyxDQUFDLEtBQUdNLENBQUMsQ0FBQ0wsR0FBRyxLQUFHVSxDQUFDLEdBQUNMLENBQUMsQ0FBQ0wsR0FBRyxDQUFDO0VBQUMsS0FBSU8sQ0FBQyxJQUFJRixDQUFDLEVBQUNkLENBQUMsQ0FBQ29CLElBQUksQ0FBQ04sQ0FBQyxFQUFDRSxDQUFDLENBQUMsSUFBRSxDQUFDVCxDQUFDLENBQUNKLGNBQWMsQ0FBQ2EsQ0FBQyxDQUFDLEtBQUdDLENBQUMsQ0FBQ0QsQ0FBQyxDQUFDLEdBQUNGLENBQUMsQ0FBQ0UsQ0FBQyxDQUFDLENBQUM7RUFBQyxJQUFHSCxDQUFDLElBQUVBLENBQUMsQ0FBQ1EsWUFBWSxFQUFDLEtBQUlMLENBQUMsSUFBSUYsQ0FBQyxHQUFDRCxDQUFDLENBQUNRLFlBQVksRUFBQ1AsQ0FBQyxFQUFDLEtBQUssQ0FBQyxLQUFHRyxDQUFDLENBQUNELENBQUMsQ0FBQyxLQUFHQyxDQUFDLENBQUNELENBQUMsQ0FBQyxHQUFDRixDQUFDLENBQUNFLENBQUMsQ0FBQyxDQUFDO0VBQUMsT0FBTTtJQUFDTSxRQUFRLEVBQUMxQixDQUFDO0lBQUMyQixJQUFJLEVBQUNWLENBQUM7SUFBQ0wsR0FBRyxFQUFDVSxDQUFDO0lBQUNULEdBQUcsRUFBQ1UsQ0FBQztJQUFDSyxLQUFLLEVBQUNQLENBQUM7SUFBQ1EsTUFBTSxFQUFDckIsQ0FBQyxDQUFDc0I7RUFBTyxDQUFDO0FBQUE7QUFBQ0MsZ0JBQWdCLEdBQUM1QixDQUFDO0FBQUM0QixXQUFXLEdBQUNmLENBQUM7QUFBQ2UsWUFBWSxHQUFDZixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzP2QzMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3ZhciBmPXJlcXVpcmUoXCJyZWFjdFwiKSxrPVN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLGw9U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLG09T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxuPWYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIscD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gcShjLGEsZyl7dmFyIGIsZD17fSxlPW51bGwsaD1udWxsO3ZvaWQgMCE9PWcmJihlPVwiXCIrZyk7dm9pZCAwIT09YS5rZXkmJihlPVwiXCIrYS5rZXkpO3ZvaWQgMCE9PWEucmVmJiYoaD1hLnJlZik7Zm9yKGIgaW4gYSltLmNhbGwoYSxiKSYmIXAuaGFzT3duUHJvcGVydHkoYikmJihkW2JdPWFbYl0pO2lmKGMmJmMuZGVmYXVsdFByb3BzKWZvcihiIGluIGE9Yy5kZWZhdWx0UHJvcHMsYSl2b2lkIDA9PT1kW2JdJiYoZFtiXT1hW2JdKTtyZXR1cm57JCR0eXBlb2Y6ayx0eXBlOmMsa2V5OmUscmVmOmgscHJvcHM6ZCxfb3duZXI6bi5jdXJyZW50fX1leHBvcnRzLkZyYWdtZW50PWw7ZXhwb3J0cy5qc3g9cTtleHBvcnRzLmpzeHM9cTtcbiJdLCJuYW1lcyI6WyJmIiwicmVxdWlyZSIsImsiLCJTeW1ib2wiLCJmb3IiLCJsIiwibSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwibiIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiUmVhY3RDdXJyZW50T3duZXIiLCJwIiwia2V5IiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJxIiwiYyIsImEiLCJnIiwiYiIsImQiLCJlIiwiaCIsImNhbGwiLCJkZWZhdWx0UHJvcHMiLCIkJHR5cGVvZiIsInR5cGUiLCJwcm9wcyIsIl9vd25lciIsImN1cnJlbnQiLCJleHBvcnRzIiwiRnJhZ21lbnQiLCJqc3giLCJqc3hzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4043\n')},6751:(__unused_webpack_module,exports)=>{eval('/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar l = Symbol.for("react.element"),\n  n = Symbol.for("react.portal"),\n  p = Symbol.for("react.fragment"),\n  q = Symbol.for("react.strict_mode"),\n  r = Symbol.for("react.profiler"),\n  t = Symbol.for("react.provider"),\n  u = Symbol.for("react.context"),\n  v = Symbol.for("react.forward_ref"),\n  w = Symbol.for("react.suspense"),\n  x = Symbol.for("react.memo"),\n  y = Symbol.for("react.lazy"),\n  z = Symbol.iterator;\nfunction A(a) {\n  if (null === a || "object" !== typeof a) return null;\n  a = z && a[z] || a["@@iterator"];\n  return "function" === typeof a ? a : null;\n}\nvar B = {\n    isMounted: function () {\n      return !1;\n    },\n    enqueueForceUpdate: function () {},\n    enqueueReplaceState: function () {},\n    enqueueSetState: function () {}\n  },\n  C = Object.assign,\n  D = {};\nfunction E(a, b, e) {\n  this.props = a;\n  this.context = b;\n  this.refs = D;\n  this.updater = e || B;\n}\nE.prototype.isReactComponent = {};\nE.prototype.setState = function (a, b) {\n  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");\n  this.updater.enqueueSetState(this, a, b, "setState");\n};\nE.prototype.forceUpdate = function (a) {\n  this.updater.enqueueForceUpdate(this, a, "forceUpdate");\n};\nfunction F() {}\nF.prototype = E.prototype;\nfunction G(a, b, e) {\n  this.props = a;\n  this.context = b;\n  this.refs = D;\n  this.updater = e || B;\n}\nvar H = G.prototype = new F();\nH.constructor = G;\nC(H, E.prototype);\nH.isPureReactComponent = !0;\nvar I = Array.isArray,\n  J = Object.prototype.hasOwnProperty,\n  K = {\n    current: null\n  },\n  L = {\n    key: !0,\n    ref: !0,\n    __self: !0,\n    __source: !0\n  };\nfunction M(a, b, e) {\n  var d,\n    c = {},\n    k = null,\n    h = null;\n  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);\n  var g = arguments.length - 2;\n  if (1 === g) c.children = e;else if (1 < g) {\n    for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];\n    c.children = f;\n  }\n  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);\n  return {\n    $$typeof: l,\n    type: a,\n    key: k,\n    ref: h,\n    props: c,\n    _owner: K.current\n  };\n}\nfunction N(a, b) {\n  return {\n    $$typeof: l,\n    type: a.type,\n    key: b,\n    ref: a.ref,\n    props: a.props,\n    _owner: a._owner\n  };\n}\nfunction O(a) {\n  return "object" === typeof a && null !== a && a.$$typeof === l;\n}\nfunction escape(a) {\n  var b = {\n    "=": "=0",\n    ":": "=2"\n  };\n  return "$" + a.replace(/[=:]/g, function (a) {\n    return b[a];\n  });\n}\nvar P = /\\/+/g;\nfunction Q(a, b) {\n  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);\n}\nfunction R(a, b, e, d, c) {\n  var k = typeof a;\n  if ("undefined" === k || "boolean" === k) a = null;\n  var h = !1;\n  if (null === a) h = !0;else switch (k) {\n    case "string":\n    case "number":\n      h = !0;\n      break;\n    case "object":\n      switch (a.$$typeof) {\n        case l:\n        case n:\n          h = !0;\n      }\n  }\n  if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function (a) {\n    return a;\n  })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;\n  h = 0;\n  d = "" === d ? "." : d + ":";\n  if (I(a)) for (var g = 0; g < a.length; g++) {\n    k = a[g];\n    var f = d + Q(k, g);\n    h += R(k, b, e, f, c);\n  } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");\n  return h;\n}\nfunction S(a, b, e) {\n  if (null == a) return a;\n  var d = [],\n    c = 0;\n  R(a, d, "", "", function (a) {\n    return b.call(e, a, c++);\n  });\n  return d;\n}\nfunction T(a) {\n  if (-1 === a._status) {\n    var b = a._result;\n    b = b();\n    b.then(function (b) {\n      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;\n    }, function (b) {\n      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;\n    });\n    -1 === a._status && (a._status = 0, a._result = b);\n  }\n  if (1 === a._status) return a._result.default;\n  throw a._result;\n}\nvar U = {\n    current: null\n  },\n  V = {\n    transition: null\n  },\n  W = {\n    ReactCurrentDispatcher: U,\n    ReactCurrentBatchConfig: V,\n    ReactCurrentOwner: K\n  };\nexports.Children = {\n  map: S,\n  forEach: function (a, b, e) {\n    S(a, function () {\n      b.apply(this, arguments);\n    }, e);\n  },\n  count: function (a) {\n    var b = 0;\n    S(a, function () {\n      b++;\n    });\n    return b;\n  },\n  toArray: function (a) {\n    return S(a, function (a) {\n      return a;\n    }) || [];\n  },\n  only: function (a) {\n    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");\n    return a;\n  }\n};\nexports.Component = E;\nexports.Fragment = p;\nexports.Profiler = r;\nexports.PureComponent = G;\nexports.StrictMode = q;\nexports.Suspense = w;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;\nexports.cloneElement = function (a, b, e) {\n  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");\n  var d = C({}, a.props),\n    c = a.key,\n    k = a.ref,\n    h = a._owner;\n  if (null != b) {\n    void 0 !== b.ref && (k = b.ref, h = K.current);\n    void 0 !== b.key && (c = "" + b.key);\n    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;\n    for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);\n  }\n  var f = arguments.length - 2;\n  if (1 === f) d.children = e;else if (1 < f) {\n    g = Array(f);\n    for (var m = 0; m < f; m++) g[m] = arguments[m + 2];\n    d.children = g;\n  }\n  return {\n    $$typeof: l,\n    type: a.type,\n    key: c,\n    ref: k,\n    props: d,\n    _owner: h\n  };\n};\nexports.createContext = function (a) {\n  a = {\n    $$typeof: u,\n    _currentValue: a,\n    _currentValue2: a,\n    _threadCount: 0,\n    Provider: null,\n    Consumer: null,\n    _defaultValue: null,\n    _globalName: null\n  };\n  a.Provider = {\n    $$typeof: t,\n    _context: a\n  };\n  return a.Consumer = a;\n};\nexports.createElement = M;\nexports.createFactory = function (a) {\n  var b = M.bind(null, a);\n  b.type = a;\n  return b;\n};\nexports.createRef = function () {\n  return {\n    current: null\n  };\n};\nexports.forwardRef = function (a) {\n  return {\n    $$typeof: v,\n    render: a\n  };\n};\nexports.isValidElement = O;\nexports.lazy = function (a) {\n  return {\n    $$typeof: y,\n    _payload: {\n      _status: -1,\n      _result: a\n    },\n    _init: T\n  };\n};\nexports.memo = function (a, b) {\n  return {\n    $$typeof: x,\n    type: a,\n    compare: void 0 === b ? null : b\n  };\n};\nexports.startTransition = function (a) {\n  var b = V.transition;\n  V.transition = {};\n  try {\n    a();\n  } finally {\n    V.transition = b;\n  }\n};\nexports.unstable_act = function () {\n  throw Error("act(...) is not supported in production builds of React.");\n};\nexports.useCallback = function (a, b) {\n  return U.current.useCallback(a, b);\n};\nexports.useContext = function (a) {\n  return U.current.useContext(a);\n};\nexports.useDebugValue = function () {};\nexports.useDeferredValue = function (a) {\n  return U.current.useDeferredValue(a);\n};\nexports.useEffect = function (a, b) {\n  return U.current.useEffect(a, b);\n};\nexports.useId = function () {\n  return U.current.useId();\n};\nexports.useImperativeHandle = function (a, b, e) {\n  return U.current.useImperativeHandle(a, b, e);\n};\nexports.useInsertionEffect = function (a, b) {\n  return U.current.useInsertionEffect(a, b);\n};\nexports.useLayoutEffect = function (a, b) {\n  return U.current.useLayoutEffect(a, b);\n};\nexports.useMemo = function (a, b) {\n  return U.current.useMemo(a, b);\n};\nexports.useReducer = function (a, b, e) {\n  return U.current.useReducer(a, b, e);\n};\nexports.useRef = function (a) {\n  return U.current.useRef(a);\n};\nexports.useState = function (a) {\n  return U.current.useState(a);\n};\nexports.useSyncExternalStore = function (a, b, e) {\n  return U.current.useSyncExternalStore(a, b, e);\n};\nexports.useTransition = function () {\n  return U.current.useTransition();\n};\nexports.version = "18.2.0";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDbUYsNEJBQTRCLEdBQUMsVUFBU25GLENBQUMsRUFBQ1csQ0FBQyxFQUFDQyxDQUFDLEVBQUM7RUFBQyxPQUFPZ0UsQ0FBQyxDQUFDM0MsT0FBTyxDQUFDc0csb0JBQW9CLENBQUN2SSxDQUFDLEVBQUNXLENBQUMsRUFBQ0MsQ0FBQyxDQUFDO0FBQUEsQ0FBQztBQUNoZnVFLHFCQUFxQixHQUFDLFlBQVU7RUFBQyxPQUFPUCxDQUFDLENBQUMzQyxPQUFPLENBQUN1RyxhQUFhLENBQUMsQ0FBQztBQUFBLENBQUM7QUFBQ3JELGVBQWUsR0FBQyxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzP2JlMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3ZhciBsPVN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLG49U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxwPVN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxxPVN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxyPVN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSx0PVN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSx1PVN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLHY9U3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLHc9U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLHg9U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikseT1TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSx6PVN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiBBKGEpe2lmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT16JiZhW3pdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9XG52YXIgQj17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKCl7fX0sQz1PYmplY3QuYXNzaWduLEQ9e307ZnVuY3Rpb24gRShhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1EO3RoaXMudXBkYXRlcj1lfHxCfUUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307XG5FLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWEpdGhyb3cgRXJyb3IoXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIik7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGEsYixcInNldFN0YXRlXCIpfTtFLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsYSxcImZvcmNlVXBkYXRlXCIpfTtmdW5jdGlvbiBGKCl7fUYucHJvdG90eXBlPUUucHJvdG90eXBlO2Z1bmN0aW9uIEcoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9RDt0aGlzLnVwZGF0ZXI9ZXx8Qn12YXIgSD1HLnByb3RvdHlwZT1uZXcgRjtcbkguY29uc3RydWN0b3I9RztDKEgsRS5wcm90b3R5cGUpO0guaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIEk9QXJyYXkuaXNBcnJheSxKPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksSz17Y3VycmVudDpudWxsfSxMPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5mdW5jdGlvbiBNKGEsYixlKXt2YXIgZCxjPXt9LGs9bnVsbCxoPW51bGw7aWYobnVsbCE9Yilmb3IoZCBpbiB2b2lkIDAhPT1iLnJlZiYmKGg9Yi5yZWYpLHZvaWQgMCE9PWIua2V5JiYoaz1cIlwiK2Iua2V5KSxiKUouY2FsbChiLGQpJiYhTC5oYXNPd25Qcm9wZXJ0eShkKSYmKGNbZF09YltkXSk7dmFyIGc9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1nKWMuY2hpbGRyZW49ZTtlbHNlIGlmKDE8Zyl7Zm9yKHZhciBmPUFycmF5KGcpLG09MDttPGc7bSsrKWZbbV09YXJndW1lbnRzW20rMl07Yy5jaGlsZHJlbj1mfWlmKGEmJmEuZGVmYXVsdFByb3BzKWZvcihkIGluIGc9YS5kZWZhdWx0UHJvcHMsZyl2b2lkIDA9PT1jW2RdJiYoY1tkXT1nW2RdKTtyZXR1cm57JCR0eXBlb2Y6bCx0eXBlOmEsa2V5OmsscmVmOmgscHJvcHM6Yyxfb3duZXI6Sy5jdXJyZW50fX1cbmZ1bmN0aW9uIE4oYSxiKXtyZXR1cm57JCR0eXBlb2Y6bCx0eXBlOmEudHlwZSxrZXk6YixyZWY6YS5yZWYscHJvcHM6YS5wcm9wcyxfb3duZXI6YS5fb3duZXJ9fWZ1bmN0aW9uIE8oYSl7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PWx9ZnVuY3Rpb24gZXNjYXBlKGEpe3ZhciBiPXtcIj1cIjpcIj0wXCIsXCI6XCI6XCI9MlwifTtyZXR1cm5cIiRcIithLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBQPS9cXC8rL2c7ZnVuY3Rpb24gUShhLGIpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJm51bGwhPWEua2V5P2VzY2FwZShcIlwiK2Eua2V5KTpiLnRvU3RyaW5nKDM2KX1cbmZ1bmN0aW9uIFIoYSxiLGUsZCxjKXt2YXIgaz10eXBlb2YgYTtpZihcInVuZGVmaW5lZFwiPT09a3x8XCJib29sZWFuXCI9PT1rKWE9bnVsbDt2YXIgaD0hMTtpZihudWxsPT09YSloPSEwO2Vsc2Ugc3dpdGNoKGspe2Nhc2UgXCJzdHJpbmdcIjpjYXNlIFwibnVtYmVyXCI6aD0hMDticmVhaztjYXNlIFwib2JqZWN0XCI6c3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgbDpjYXNlIG46aD0hMH19aWYoaClyZXR1cm4gaD1hLGM9YyhoKSxhPVwiXCI9PT1kP1wiLlwiK1EoaCwwKTpkLEkoYyk/KGU9XCJcIixudWxsIT1hJiYoZT1hLnJlcGxhY2UoUCxcIiQmL1wiKStcIi9cIiksUihjLGIsZSxcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBhfSkpOm51bGwhPWMmJihPKGMpJiYoYz1OKGMsZSsoIWMua2V5fHxoJiZoLmtleT09PWMua2V5P1wiXCI6KFwiXCIrYy5rZXkpLnJlcGxhY2UoUCxcIiQmL1wiKStcIi9cIikrYSkpLGIucHVzaChjKSksMTtoPTA7ZD1cIlwiPT09ZD9cIi5cIjpkK1wiOlwiO2lmKEkoYSkpZm9yKHZhciBnPTA7ZzxhLmxlbmd0aDtnKyspe2s9XG5hW2ddO3ZhciBmPWQrUShrLGcpO2grPVIoayxiLGUsZixjKX1lbHNlIGlmKGY9QShhKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmb3IoYT1mLmNhbGwoYSksZz0wOyEoaz1hLm5leHQoKSkuZG9uZTspaz1rLnZhbHVlLGY9ZCtRKGssZysrKSxoKz1SKGssYixlLGYsYyk7ZWxzZSBpZihcIm9iamVjdFwiPT09ayl0aHJvdyBiPVN0cmluZyhhKSxFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIrKFwiW29iamVjdCBPYmplY3RdXCI9PT1iP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmIpK1wiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiKTtyZXR1cm4gaH1cbmZ1bmN0aW9uIFMoYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGQ9W10sYz0wO1IoYSxkLFwiXCIsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYi5jYWxsKGUsYSxjKyspfSk7cmV0dXJuIGR9ZnVuY3Rpb24gVChhKXtpZigtMT09PWEuX3N0YXR1cyl7dmFyIGI9YS5fcmVzdWx0O2I9YigpO2IudGhlbihmdW5jdGlvbihiKXtpZigwPT09YS5fc3RhdHVzfHwtMT09PWEuX3N0YXR1cylhLl9zdGF0dXM9MSxhLl9yZXN1bHQ9Yn0sZnVuY3Rpb24oYil7aWYoMD09PWEuX3N0YXR1c3x8LTE9PT1hLl9zdGF0dXMpYS5fc3RhdHVzPTIsYS5fcmVzdWx0PWJ9KTstMT09PWEuX3N0YXR1cyYmKGEuX3N0YXR1cz0wLGEuX3Jlc3VsdD1iKX1pZigxPT09YS5fc3RhdHVzKXJldHVybiBhLl9yZXN1bHQuZGVmYXVsdDt0aHJvdyBhLl9yZXN1bHQ7fVxudmFyIFU9e2N1cnJlbnQ6bnVsbH0sVj17dHJhbnNpdGlvbjpudWxsfSxXPXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyOlUsUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6VixSZWFjdEN1cnJlbnRPd25lcjpLfTtleHBvcnRzLkNoaWxkcmVuPXttYXA6Uyxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtTKGEsZnVuY3Rpb24oKXtiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZSl9LGNvdW50OmZ1bmN0aW9uKGEpe3ZhciBiPTA7UyhhLGZ1bmN0aW9uKCl7YisrfSk7cmV0dXJuIGJ9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7cmV0dXJuIFMoYSxmdW5jdGlvbihhKXtyZXR1cm4gYX0pfHxbXX0sb25seTpmdW5jdGlvbihhKXtpZighTyhhKSl0aHJvdyBFcnJvcihcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiKTtyZXR1cm4gYX19O2V4cG9ydHMuQ29tcG9uZW50PUU7ZXhwb3J0cy5GcmFnbWVudD1wO1xuZXhwb3J0cy5Qcm9maWxlcj1yO2V4cG9ydHMuUHVyZUNvbXBvbmVudD1HO2V4cG9ydHMuU3RyaWN0TW9kZT1xO2V4cG9ydHMuU3VzcGVuc2U9dztleHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPVc7XG5leHBvcnRzLmNsb25lRWxlbWVudD1mdW5jdGlvbihhLGIsZSl7aWYobnVsbD09PWF8fHZvaWQgMD09PWEpdGhyb3cgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIithK1wiLlwiKTt2YXIgZD1DKHt9LGEucHJvcHMpLGM9YS5rZXksaz1hLnJlZixoPWEuX293bmVyO2lmKG51bGwhPWIpe3ZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZixoPUsuY3VycmVudCk7dm9pZCAwIT09Yi5rZXkmJihjPVwiXCIrYi5rZXkpO2lmKGEudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgZz1hLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihmIGluIGIpSi5jYWxsKGIsZikmJiFMLmhhc093blByb3BlcnR5KGYpJiYoZFtmXT12b2lkIDA9PT1iW2ZdJiZ2b2lkIDAhPT1nP2dbZl06YltmXSl9dmFyIGY9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1mKWQuY2hpbGRyZW49ZTtlbHNlIGlmKDE8Zil7Zz1BcnJheShmKTtcbmZvcih2YXIgbT0wO208ZjttKyspZ1ttXT1hcmd1bWVudHNbbSsyXTtkLmNoaWxkcmVuPWd9cmV0dXJueyQkdHlwZW9mOmwsdHlwZTphLnR5cGUsa2V5OmMscmVmOmsscHJvcHM6ZCxfb3duZXI6aH19O2V4cG9ydHMuY3JlYXRlQ29udGV4dD1mdW5jdGlvbihhKXthPXskJHR5cGVvZjp1LF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbCxfZGVmYXVsdFZhbHVlOm51bGwsX2dsb2JhbE5hbWU6bnVsbH07YS5Qcm92aWRlcj17JCR0eXBlb2Y6dCxfY29udGV4dDphfTtyZXR1cm4gYS5Db25zdW1lcj1hfTtleHBvcnRzLmNyZWF0ZUVsZW1lbnQ9TTtleHBvcnRzLmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rpb24oYSl7dmFyIGI9TS5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9O2V4cG9ydHMuY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19O1xuZXhwb3J0cy5mb3J3YXJkUmVmPWZ1bmN0aW9uKGEpe3JldHVybnskJHR5cGVvZjp2LHJlbmRlcjphfX07ZXhwb3J0cy5pc1ZhbGlkRWxlbWVudD1PO2V4cG9ydHMubGF6eT1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6eSxfcGF5bG9hZDp7X3N0YXR1czotMSxfcmVzdWx0OmF9LF9pbml0OlR9fTtleHBvcnRzLm1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm57JCR0eXBlb2Y6eCx0eXBlOmEsY29tcGFyZTp2b2lkIDA9PT1iP251bGw6Yn19O2V4cG9ydHMuc3RhcnRUcmFuc2l0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPVYudHJhbnNpdGlvbjtWLnRyYW5zaXRpb249e307dHJ5e2EoKX1maW5hbGx5e1YudHJhbnNpdGlvbj1ifX07ZXhwb3J0cy51bnN0YWJsZV9hY3Q9ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcImFjdCguLi4pIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgb2YgUmVhY3QuXCIpO307XG5leHBvcnRzLnVzZUNhbGxiYWNrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VDYWxsYmFjayhhLGIpfTtleHBvcnRzLnVzZUNvbnRleHQ9ZnVuY3Rpb24oYSl7cmV0dXJuIFUuY3VycmVudC51c2VDb250ZXh0KGEpfTtleHBvcnRzLnVzZURlYnVnVmFsdWU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZT1mdW5jdGlvbihhKXtyZXR1cm4gVS5jdXJyZW50LnVzZURlZmVycmVkVmFsdWUoYSl9O2V4cG9ydHMudXNlRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VJZD1mdW5jdGlvbigpe3JldHVybiBVLmN1cnJlbnQudXNlSWQoKX07ZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gVS5jdXJyZW50LnVzZUltcGVyYXRpdmVIYW5kbGUoYSxiLGUpfTtcbmV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VJbnNlcnRpb25FZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VMYXlvdXRFZmZlY3Q9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVS5jdXJyZW50LnVzZUxheW91dEVmZmVjdChhLGIpfTtleHBvcnRzLnVzZU1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVS5jdXJyZW50LnVzZU1lbW8oYSxiKX07ZXhwb3J0cy51c2VSZWR1Y2VyPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gVS5jdXJyZW50LnVzZVJlZHVjZXIoYSxiLGUpfTtleHBvcnRzLnVzZVJlZj1mdW5jdGlvbihhKXtyZXR1cm4gVS5jdXJyZW50LnVzZVJlZihhKX07ZXhwb3J0cy51c2VTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gVS5jdXJyZW50LnVzZVN0YXRlKGEpfTtleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gVS5jdXJyZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlKGEsYixlKX07XG5leHBvcnRzLnVzZVRyYW5zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gVS5jdXJyZW50LnVzZVRyYW5zaXRpb24oKX07ZXhwb3J0cy52ZXJzaW9uPVwiMTguMi4wXCI7XG4iXSwibmFtZXMiOlsibCIsIlN5bWJvbCIsImZvciIsIm4iLCJwIiwicSIsInIiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiaXRlcmF0b3IiLCJBIiwiYSIsIkIiLCJpc01vdW50ZWQiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwiQyIsIk9iamVjdCIsImFzc2lnbiIsIkQiLCJFIiwiYiIsImUiLCJwcm9wcyIsImNvbnRleHQiLCJyZWZzIiwidXBkYXRlciIsInByb3RvdHlwZSIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsIkVycm9yIiwiZm9yY2VVcGRhdGUiLCJGIiwiRyIsIkgiLCJjb25zdHJ1Y3RvciIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiSSIsIkFycmF5IiwiaXNBcnJheSIsIkoiLCJoYXNPd25Qcm9wZXJ0eSIsIksiLCJjdXJyZW50IiwiTCIsImtleSIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwiTSIsImQiLCJjIiwiayIsImgiLCJjYWxsIiwiZyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNoaWxkcmVuIiwiZiIsIm0iLCJkZWZhdWx0UHJvcHMiLCIkJHR5cGVvZiIsInR5cGUiLCJfb3duZXIiLCJOIiwiTyIsImVzY2FwZSIsInJlcGxhY2UiLCJQIiwiUSIsInRvU3RyaW5nIiwiUiIsInB1c2giLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwiU3RyaW5nIiwia2V5cyIsImpvaW4iLCJTIiwiVCIsIl9zdGF0dXMiLCJfcmVzdWx0IiwidGhlbiIsImRlZmF1bHQiLCJVIiwiViIsInRyYW5zaXRpb24iLCJXIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnIiwiUmVhY3RDdXJyZW50T3duZXIiLCJleHBvcnRzIiwiQ2hpbGRyZW4iLCJtYXAiLCJmb3JFYWNoIiwiYXBwbHkiLCJjb3VudCIsInRvQXJyYXkiLCJvbmx5IiwiQ29tcG9uZW50IiwiRnJhZ21lbnQiLCJQcm9maWxlciIsIlB1cmVDb21wb25lbnQiLCJTdHJpY3RNb2RlIiwiU3VzcGVuc2UiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImNsb25lRWxlbWVudCIsImNyZWF0ZUNvbnRleHQiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRWYWx1ZTIiLCJfdGhyZWFkQ291bnQiLCJQcm92aWRlciIsIkNvbnN1bWVyIiwiX2RlZmF1bHRWYWx1ZSIsIl9nbG9iYWxOYW1lIiwiX2NvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRmFjdG9yeSIsImJpbmQiLCJjcmVhdGVSZWYiLCJmb3J3YXJkUmVmIiwicmVuZGVyIiwiaXNWYWxpZEVsZW1lbnQiLCJsYXp5IiwiX3BheWxvYWQiLCJfaW5pdCIsIm1lbW8iLCJjb21wYXJlIiwic3RhcnRUcmFuc2l0aW9uIiwidW5zdGFibGVfYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRGVidWdWYWx1ZSIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VUcmFuc2l0aW9uIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6751\n')},5466:(module,__unused_webpack_exports,__webpack_require__)=>{eval("\n\nif (true) {\n  module.exports = __webpack_require__(6751);\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJQSxJQUFxQyxFQUFFO0VBQ3pDRywwQ0FBeUQ7QUFDM0QsQ0FBQyxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5466\n")},3823:(module,__unused_webpack_exports,__webpack_require__)=>{eval("\n\nif (true) {\n  module.exports = __webpack_require__(4043);\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzgyMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJQSxJQUFxQyxFQUFFO0VBQ3pDRywwQ0FBcUU7QUFDdkUsQ0FBQyxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/OWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3823\n")}}]);