"use strict";(self.webpackChunkelder_books_fe=self.webpackChunkelder_books_fe||[]).push([[5584],{1300:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ep: () => (/* binding */ createPath),\n/* harmony export */   J0: () => (/* binding */ invariant),\n/* harmony export */   LX: () => (/* binding */ matchPath),\n/* harmony export */   OF: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   RQ: () => (/* binding */ joinPaths),\n/* harmony export */   WK: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   X3: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Zn: () => (/* binding */ stripBasename),\n/* harmony export */   Zq: () => (/* binding */ getPathContributingMatches),\n/* harmony export */   aU: () => (/* binding */ Action),\n/* harmony export */   cP: () => (/* binding */ parsePath),\n/* harmony export */   fp: () => (/* binding */ matchRoutes),\n/* harmony export */   lX: () => (/* binding */ createBrowserHistory),\n/* harmony export */   p7: () => (/* binding */ createRouter),\n/* harmony export */   pC: () => (/* binding */ resolveTo),\n/* harmony export */   uX: () => (/* binding */ redirect)\n/* harmony export */ });\n/* unused harmony exports IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, UNSAFE_DeferredData, UNSAFE_convertRouteMatchToUiMatch, UNSAFE_convertRoutesToDataRoutes, UNSAFE_warning, createHashHistory, createMemoryHistory, createStaticHandler, defer, generatePath, getStaticContextFromError, getToPathname, isDeferredData, json, normalizePathname, redirectDocument, resolvePath */\n/* provided dependency */ var console = __webpack_require__(1283);\n/**\n * @remix-run/router v1.9.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action["Pop"] = "POP";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action["Push"] = "PUSH";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action["Replace"] = "REPLACE";\n})(Action || (Action = {}));\nconst PopStateEventType = "popstate";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = ["/"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);\n    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === "string" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), "http://localhost");\n    },\n    encodeLocation(to) {\n      let path = typeof to === "string" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || "",\n        search: path.search || "",\n        hash: path.hash || ""\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation("", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === "string" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don\'t want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = "/",\n      search = "",\n      hash = ""\n    } = parsePath(window.location.hash.substr(1));\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path="*">) since that matches internally against\n    // "/*" and we\'d expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {\n      pathname = "/" + pathname;\n    }\n    return createLocation("", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector("base");\n    let href = "";\n    if (base && base.getAttribute("href")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf("#");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + "#" + (typeof to === "string" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === "undefined") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== "undefined") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling "pause on exceptions" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === "string" ? current : current.pathname,\n    search: "",\n    hash: ""\n  }, typeof to === "string" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that\'s a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = "/",\n    search = "",\n    hash = ""\n  } = _ref;\n  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;\n  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf("#");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf("?");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it\'s because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), "");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, "", url);\n    } catch (error) {\n      // If the exception is because `state` can\'t be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === "DataCloneError") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, "", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is "null" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;\n    let href = typeof to === "string" ? to : createPath(to);\n    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error("A history only accepts one active listener");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType["data"] = "data";\n  ResultType["deferred"] = "deferred";\n  ResultType["redirect"] = "redirect";\n  ResultType["error"] = "error";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject\'s within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === "string" ? route.id : treePath.join("-");\n    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");\n    invariant(!manifest[id], "Found a route id collision on id \\"" + id + "\\".  Route " + "id\'s must be globally unique within Data Router usages");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = "/";\n  }\n  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || "/", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i],\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won\'t be\n    // encoded here but there also shouldn\'t be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    safelyDecodeURI(pathname));\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = "";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || "" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith("/")) {\n      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \\"" + meta.relativePath + "\\" nested under path " + ("\\"" + parentPath + "\\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the "flattened" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \\"" + path + "\\"."));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn\'t ever match by themselves unless they are\n    // index routes, so don\'t add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split("/");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith("?");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, "");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, ""] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join("/"));\n  let result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === "*";\nfunction computeScore(path, index) {\n  let segments = path.split("/");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn\'t really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = "/";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== "/") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {\n    warning(false, "Route path \\"" + path + "\\" will be treated as if it were " + ("\\"" + path.replace(/\\*$/, "/*") + "\\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \\"" + path.replace(/\\*$/, "/*") + "\\"."));\n    path = path.replace(/\\*$/, "/*");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith("/") ? "/" : "";\n  const stringify = p => p == null ? "" : typeof p === "string" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    // only apply the splat if it\'s the last segment\n    if (isLastSegment && segment === "*") {\n      const star = "*";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === "?" || param != null, "Missing \\":" + key + "\\" param");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, "");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join("/");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === "string") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, "$1");\n  let captureGroups = match.slice(1);\n  let params = paramNames.reduce((memo, paramName, index) => {\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params["*"] later because it will be decoded then\n    if (paramName === "*") {\n      let splatValue = captureGroups[index] || "";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, "$1");\n    }\n    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \\"" + path + "\\" will be treated as if it were " + ("\\"" + path.replace(/\\*$/, "/*") + "\\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \\"" + path.replace(/\\*$/, "/*") + "\\"."));\n  let paramNames = [];\n  let regexpSource = "^" + path.replace(/\\/*\\*?$/, "") // Ignore trailing / and /*, we\'ll handle it below\n  .replace(/^\\/*/, "/") // Make sure it has a leading /\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, "\\\\$&") // Escape special regex chars\n  .replace(/\\/:(\\w+)/g, (_, paramName) => {\n    paramNames.push(paramName);\n    return "/([^\\\\/]+)";\n  });\n  if (path.endsWith("*")) {\n    paramNames.push("*");\n    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest\n    : "(?:\\\\/(.+)|\\\\/*)$"; // Don\'t include the / in params["*"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += "\\\\/*$";\n  } else if (path !== "" && path !== "/") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we\'ve matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += "(?:(?=\\\\/|$))";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");\n  return [matcher, paramNames];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, "The URL path \\"" + value + "\\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, "The value for the URL param \\"" + paramName + "\\" will not be decoded because" + (" the string \\"" + value + "\\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === "/") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user\'s control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== "/") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || "/";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = "/";\n  }\n  let {\n    pathname: toPathname,\n    search = "",\n    hash = ""\n  } = typeof to === "string" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, "").split("/");\n  let relativeSegments = relativePath.split("/");\n  relativeSegments.forEach(segment => {\n    if (segment === "..") {\n      // Keep the root "" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== ".") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join("/") : "/";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return "Cannot include a \'" + char + "\' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\\"...\\"> and the router will parse it for you.";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don\'t\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path="/">\n *     <Route path="accounts" element={<Link to=".."}>\n *   </Route>\n *\n *   <Route path="/">\n *     <Route path="accounts">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=".."} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === "string") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));\n    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));\n    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));\n  }\n  let isEmptyPath = toArg === "" || to.pathname === "";\n  let toPathname = isEmptyPath ? "/" : to.pathname;\n  let from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location\'s pathname and *not* the route pathname.\n  if (isPathRelative || toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith("..")) {\n      let toSegments = toPathname.split("/");\n      // Each leading .. segment means "go up one route" instead of "go up one\n      // URL segment".  This is a key difference from how <a href> works and a\n      // major reason we call this a "to" value instead of a "href".\n      while (toSegments[0] === "..") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join("/");\n    }\n    // If there are more ".." segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";\n  }\n  let path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original "to" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");\n  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += "/";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nconst joinPaths = paths => paths.join("/").replace(/\\/\\/+/g, "/");\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, "").replace(/^\\/*/, "/");\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === "number" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has("Content-Type")) {\n    headers.set("Content-Type", "application/json; charset=utf-8");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);\n    this.controller.signal.addEventListener("abort", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref) => {\n      let [key, value] = _ref;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, "_tracked", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, "_error", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n    // If the promise was resolved/rejected with undefined, we\'ll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error("Deferred data for key \\"" + key + "\\" resolved/rejected with `undefined`, " + "you must resolve/reject with a value or `null`.");\n      Object.defineProperty(promise, "_error", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, "_error", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, "_data", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener("abort", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener("abort", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");\n    return Object.entries(this.data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === "number" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to "302 Found".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === "number") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === "undefined") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set("Location", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to "302 Found".\n */\nconst redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set("X-Remix-Reload-Document", "true");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */\nclass ErrorResponseImpl {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || "";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;\n}\nconst validMutationMethodsArr = ["post", "put", "patch", "delete"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = ["get", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: "idle",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: "idle",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: "unblocked",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : undefined;\n  const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || "/";\n  // Config driven behavior flags\n  let future = _extends({\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don\'t get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR\'d and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized =\n  // All initialMatches need to be loaded before we\'re ready.  If we have lazy\n  // functions around still then we\'ll need to run them in initialize()\n  !initialMatches.some(m => m.route.lazy) && (\n  // And we have to either have no loaders or have been provided hydrationData\n  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don\'t restore on initial updateState() if we were SSR\'d\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: "idle",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don\'t need to update UI state if they change\n  let blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We\'ll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don\'t update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: "blocked",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: "proceeding",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don\'t do any handling of lazy here.  For SPA\'s it\'ll get handled\n    // in the normal navigation flow.  For SSR it\'s expected that lazy modules are\n    // resolved prior to router creation since we can\'t go into a fallbackElement\n    // UI for SSR\'d apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location);\n    }\n    return router;\n  }\n  // Clean up a router and it\'s side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState) {\n    state = _extends({}, state, newState);\n    subscribers.forEach(subscriber => subscriber(state));\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState) {\n    var _location$state, _location$state2;\n    // Deduce if we\'re in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We\'re past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we\'re wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    // Always respect the user flag.  Otherwise don\'t reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: "idle",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }));\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === "number") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    // When using navigate as a PUSH/REPLACE we aren\'t reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we\'d get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don\'t have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: "blocked",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: "proceeding",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace\n    });\n  }\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to "succeed" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: "loading"\n    });\n    // If we\'re currently submitting an action, we don\'t need to start a new\n    // navigation, we\'ll just let the follow up loader execution call all loaders\n    if (state.navigation.state === "submitting") {\n      return;\n    }\n    // If we\'re currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === "idle") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we\'re currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don\'t keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      });\n      return;\n    }\n    // Short circuit if it\'s only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be "same hash".  For example, on /page#hash and submit a <Form method="post">\n    // which will default to a navigation to /page\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      });\n      return;\n    }\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It\'s not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      // Create a GET request for the loaders\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    // Call loaders\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    // Clean up now that the action/loaders have completed.  Don\'t clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    });\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn\'t explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we\'re currently at to avoid\n        // double back-buttons\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that\'ll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: "defer-action"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    // If this was a redirect from an action we don\'t have a "submission" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    // Cancel pending deferreds for no-longer-matched routes or routes we\'re\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we\'re short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n      return {\n        shortCircuited: true\n      };\n    }\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(rf => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n    }\n    revalidatingFetchers.forEach(rf => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    // Clean up _after_ loaders have completed.  Don\'t clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn\'t get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  function getFetcher(key) {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error("router.fetch() was called during the server render, but it shouldn\'t be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }));\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error);\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, submission);\n      return;\n    }\n    // Store off the match so we can call it\'s shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId\n      });\n      setFetcherError(key, routeId, error);\n      return;\n    }\n    // Put this fetcher into it\'s submitting state\n    let existingFetcher = state.fetchers.get(key);\n    let fetcher = getSubmittingFetcher(submission, existingFetcher);\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren\'t aborted by ou our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        let loadingFetcher = getLoadingFetcher(submission);\n        state.fetchers.set(key, loadingFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: "defer-action"\n      });\n    }\n    // Start the data load for current matches, or the next location if we\'re\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, "Didn\'t find any matches after fetcher action");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n      [match.route.id]: actionResult.data\n    }, undefined // No need to send through errors since we short circuit above\n    );\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it\'s current loading state which\n    // contains it\'s action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn\'t get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn\'t been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, "Expected pending action");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren\'t going through completeNavigation\n      updateState(_extends({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)\n      }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n      isRevalidationRequired = false;\n    }\n  }\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    // Put this fetcher into it\'s loading state\n    let loadingFetcher = getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined);\n    state.fetchers.set(key, loadingFetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n    // Deferred isn\'t supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n    // We can delete this so long as we weren\'t aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\n      state.fetchers.delete(key);\n      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n      // do we need to behave any differently with our non-redirect errors?\n      // What if it was a non-redirect Response?\n      updateState({\n        fetchers: new Map(state.fetchers),\n        errors: {\n          [boundaryMatch.route.id]: result.error\n        }\n      });\n      return;\n    }\n    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");\n    // Put the fetcher back into an idle state\n    let doneFetcher = getDoneFetcher(result.data);\n    state.fetchers.set(key, doneFetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect "replaces" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we\'ve processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(state, redirect, _temp) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp === void 0 ? {} : _temp;\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state.location, redirect.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, "Expected a location on the redirect navigation");\n    if (isBrowser) {\n      let isDocumentReload = false;\n      if (redirect.reloadDocument) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n        const url = init.history.createURL(redirect.location);\n        isDocumentReload =\n        // Hard reload if it\'s an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin ||\n        // Hard reload if it\'s an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n    // There\'s no need to abort on redirects, since we don\'t detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map(f => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function setFetcherError(key, routeId, error) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don\'t abort the controller if this is a deletion of a fetcher.submit()\n    // in it\'s loading phase since - we don\'t want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, "Expected fetch controller: " + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, "Expected fetcher: " + key);\n      if (fetcher.state === "loading") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, "Expected fetcher: " + key);\n        if (fetcher.state === "loading") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don\'t have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, "A router only supports one blocker at a time");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === "proceeding") {\n      // If the blocker is currently proceeding, we don\'t need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we\'re unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we\'ve not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === "number") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it\'s temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || "/";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(request, _temp2) {\n    let {\n      requestContext\n    } = _temp2 === void 0 ? {} : _temp2;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation("", createPath(url), null, "default");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn\'t\n    if (!isValidMethod(method) && method !== "HEAD") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(request, _temp3) {\n    let {\n      routeId,\n      requestContext\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation("", createPath(url), null, "default");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn\'t\n    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don\'t think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn\'t a Response, but it\'s not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the "error" state outside of queryImpl.\n      throw error;\n    }\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, routeMatch) {\n    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don\'t propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n        isStaticRequest: true,\n        isRouteRequest,\n        requestContext\n      });\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? "queryRoute" : "query";\n        throw new Error(method + "() call aborted: " + request.method + " " + request.url);\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the "throw all redirect responses" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: "defer-action"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(request, matches, requestContext, undefined, {\n        [boundaryMatch.route.id]: result.error\n      });\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n    return _extends({}, context, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      actionHeaders: _extends({}, result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {})\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n    let isRouteRequest = routeMatch != null;\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, {\n      isStaticRequest: true,\n      isRouteRequest,\n      requestContext\n    }))]);\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? "queryRoute" : "query";\n      throw new Error(method + "() call aborted: " + request.method + " " + request.url);\n    }\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId != null && relative !== "path") {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route.  When using relative:path,\n    // fromRouteId is ignored since that is always relative to the current\n    // location path\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  let path = resolveTo(to ? to : ".", getPathContributingMatches(contextualMatches).map(m => m.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === "path");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to="." and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Add an ?index param for matched index routes if we don\'t already have one\n  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, "?index&") : "?index";\n  }\n  // If we\'re operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== "/") {\n    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: "invalid-body"\n    })\n  });\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || "get";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === "text/plain") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n        let [name, value] = _ref3;\n        return "" + acc + name + "=" + value + "\\n";\n      }, "") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === "application/json") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === "function", "FormData is not available in this environment");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append("index", "");\n  }\n  parsedPath.search = "?" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n// Filter out all routes below any caught error as they aren\'t going to\n// render so we don\'t need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex(m => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven\'t loaded this route yet so we don\'t know if it\'s got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it\'s own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate:\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired ||\n      // Clicked the same link, resubmitted a GET form\n      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don\'t revalidate if fetcher won\'t be present in the subsequent render\n    if (!matches.some(m => m.route.id === f.routeId)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === undefined) {\n      // If the fetcher hasn\'t ever completed loading yet, then this isn\'t a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don\'t have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don\'t yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === "boolean") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, "No route found in manifest");\n  // Update the route in place.  This should be safe because there\'s no way\n  // we could yet be sitting on this route as we can\'t get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR "update" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to "does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn\'t static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== "hasErrorBoundary";\n    warning(!isPropertyStaticallyDefined, "Route \\"" + routeToUpdate.id + "\\" has a static property \\"" + lazyRouteProperty + "\\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \\"" + lazyRouteProperty + "\\" will be ignored."));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don\'t resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener("abort", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let values = await Promise.all([\n        // If the handler throws, don\'t let it immediately bubble out,\n        // since we need to let the lazy() execution finish so we know if this\n        // route has a boundary that can handle the error\n        runHandler(handler).catch(e => {\n          handlerError = e;\n        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === "action") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don\'t\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            data: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\\"" + match.route.id + "\\" but didn\'t return anything from your `" + type + "` ") + "function. Please return a value or `null`.");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener("abort", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get("Location");\n      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      // Don\'t process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set("Location", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get("X-Remix-Revalidate") !== null,\n        reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null\n      };\n    }\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    let contentType = result.headers.get("Content-Type");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn\'t think we needed this but it turns out unlike other methods, patch\n    // won\'t be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === "application/json") {\n      init.headers = new Headers({\n        "Content-Type": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === "text/plain") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === "string" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  // If we didn\'t consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");\n    let result = fetcherResults[index];\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, "Unhandled fetcher revalidation redirect");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, "Unhandled fetcher deferred data");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn\'t removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don\'t keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.find(r => r.index || !r.path || r.path === "/") || {\n    id: "__shim-error-route__"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: "",\n      pathnameBase: "",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp4) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp4 === void 0 ? {} : _temp4;\n  let statusText = "Unknown Server Error";\n  let errorMessage = "Unknown @remix-run/router error";\n  if (status === 400) {\n    statusText = "Bad Request";\n    if (method && pathname && routeId) {\n      errorMessage = "You made a " + method + " request to \\"" + pathname + "\\" but " + ("did not provide a `loader` for route \\"" + routeId + "\\", ") + "so there is no way to handle the request.";\n    } else if (type === "defer-action") {\n      errorMessage = "defer() is not supported in actions";\n    } else if (type === "invalid-body") {\n      errorMessage = "Unable to encode submission body";\n    }\n  } else if (status === 403) {\n    statusText = "Forbidden";\n    errorMessage = "Route \\"" + routeId + "\\" does not match URL \\"" + pathname + "\\"";\n  } else if (status === 404) {\n    statusText = "Not Found";\n    errorMessage = "No route matches URL \\"" + pathname + "\\"";\n  } else if (status === 405) {\n    statusText = "Method Not Allowed";\n    if (method && pathname && routeId) {\n      errorMessage = "You made a " + method.toUpperCase() + " request to \\"" + pathname + "\\" but " + ("did not provide an `action` for route \\"" + routeId + "\\", ") + "so there is no way to handle the request.";\n    } else if (method) {\n      errorMessage = "Invalid request method \\"" + method.toUpperCase() + "\\"";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === "string" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: ""\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === "") {\n    // /page -> /page#hash\n    return b.hash !== "";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== "") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get("Location");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don\'t have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they\'ll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll("index").some(v => v === "");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === "string" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest "path contributing" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: "loading",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: "loading",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: "submitting",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: "loading",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: "loading",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: "submitting",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: "idle",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data\n  };\n  return fetcher;\n}\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjdFLElBQUksRUFBRXNLLFVBQVUsQ0FBQ3RLLElBQUk7SUFDckI4RSxJQUFJLEVBQUV3RixVQUFVLENBQUN4RixJQUFJO0lBQ3JCOUwsSUFBSSxFQUFFMlYsZUFBZSxHQUFHQSxlQUFlLENBQUMzVixJQUFJLEdBQUcvSDtHQUNoRDtFQUNELE9BQU9tYyxPQUFPO0FBQ2hCO0FBRUEsU0FBUzhCLGNBQWNBLENBQUNsVyxJQUFxQjtFQUMzQyxJQUFJb1UsT0FBTyxHQUEwQjtJQUNuQ3BjLEtBQUssRUFBRSxNQUFNO0lBQ2IwVCxVQUFVLEVBQUV6VCxTQUFTO0lBQ3JCMFQsVUFBVSxFQUFFMVQsU0FBUztJQUNyQjJULFdBQVcsRUFBRTNULFNBQVM7SUFDdEI0VCxRQUFRLEVBQUU1VCxTQUFTO0lBQ25CK08sSUFBSSxFQUFFL08sU0FBUztJQUNmNlQsSUFBSSxFQUFFN1QsU0FBUztJQUNmK0g7R0FDRDtFQUNELE9BQU9vVSxPQUFPO0FBQ2hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uLi9oaXN0b3J5LnRzPzcxZjkiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi4vdXRpbHMudHM/YWMxMSIsIndlYnBhY2s6Ly9lbGRlci1ib29rcy1mZS8uLi9yb3V0ZXIudHM/YTY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXG4gKi9cbmV4cG9ydCBlbnVtIEFjdGlvbiB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBQb3AgPSBcIlBPUFwiLFxuXG4gIC8qKlxuICAgKiBBIFBVU0ggaW5kaWNhdGVzIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoIGFzIHdoZW5cbiAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxuICAgKiBlbnRyaWVzIGluIHRoZSBzdGFjayBhcmUgbG9zdC5cbiAgICovXG4gIFB1c2ggPSBcIlBVU0hcIixcblxuICAvKipcbiAgICogQSBSRVBMQUNFIGluZGljYXRlcyB0aGUgZW50cnkgYXQgdGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogYmVpbmcgcmVwbGFjZWQgYnkgYSBuZXcgb25lLlxuICAgKi9cbiAgUmVwbGFjZSA9IFwiUkVQTEFDRVwiLFxufVxuXG4vKipcbiAqIFRoZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCB2YWx1ZXMgb2YgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aCB7XG4gIC8qKlxuICAgKiBBIFVSTCBwYXRobmFtZSwgYmVnaW5uaW5nIHdpdGggYSAvLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogQSBVUkwgc2VhcmNoIHN0cmluZywgYmVnaW5uaW5nIHdpdGggYSA/LlxuICAgKi9cbiAgc2VhcmNoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgVVJMIGZyYWdtZW50IGlkZW50aWZpZXIsIGJlZ2lubmluZyB3aXRoIGEgIy5cbiAgICovXG4gIGhhc2g6IHN0cmluZztcbn1cblxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIExvY2F0aW9uIGdlbmVyaWMgZGVmYXVsdCBmcm9tIGBhbnlgIHRvIGB1bmtub3duYCBhbmRcbi8vIHJlbW92ZSBSZW1peCBgdXNlTG9jYXRpb25gIHdyYXBwZXIuXG5cbi8qKlxuICogQW4gZW50cnkgaW4gYSBoaXN0b3J5IHN0YWNrLiBBIGxvY2F0aW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogVVJMIHBhdGgsIGFzIHdlbGwgYXMgcG9zc2libHkgc29tZSBhcmJpdHJhcnkgc3RhdGUgYW5kIGEga2V5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uPFN0YXRlID0gYW55PiBleHRlbmRzIFBhdGgge1xuICAvKipcbiAgICogQSB2YWx1ZSBvZiBhcmJpdHJhcnkgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBsb2NhdGlvbi5cbiAgICovXG4gIHN0YXRlOiBTdGF0ZTtcblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLiBNYXkgYmUgdXNlZCB0byBzYWZlbHkgc3RvcmVcbiAgICogYW5kIHJldHJpZXZlIGRhdGEgaW4gc29tZSBvdGhlciBzdG9yYWdlIEFQSSwgbGlrZSBgbG9jYWxTdG9yYWdlYC5cbiAgICpcbiAgICogTm90ZTogVGhpcyB2YWx1ZSBpcyBhbHdheXMgXCJkZWZhdWx0XCIgb24gdGhlIGluaXRpYWwgbG9jYXRpb24uXG4gICAqL1xuICBrZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNoYW5nZSB0byB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGUgY2hhbmdlLlxuICAgKi9cbiAgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBuZXcgbG9jYXRpb24uXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBiZXR3ZWVuIHRoaXMgbG9jYXRpb24gYW5kIHRoZSBmb3JtZXIgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIGRlbHRhOiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBub3RpZmljYXRpb25zIGFib3V0IGxvY2F0aW9uIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXIge1xuICAodXBkYXRlOiBVcGRhdGUpOiB2b2lkO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIGxvY2F0aW9uIHRoYXQgaXMgdGhlIGRlc3RpbmF0aW9uIG9mIHNvbWUgbmF2aWdhdGlvbiwgZWl0aGVyIHZpYVxuICogYGhpc3RvcnkucHVzaGAgb3IgYGhpc3RvcnkucmVwbGFjZWAuIFRoaXMgbWF5IGJlIGVpdGhlciBhIFVSTCBvciB0aGUgcGllY2VzXG4gKiBvZiBhIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBUbyA9IHN0cmluZyB8IFBhcnRpYWw8UGF0aD47XG5cbi8qKlxuICogQSBoaXN0b3J5IGlzIGFuIGludGVyZmFjZSB0byB0aGUgbmF2aWdhdGlvbiBzdGFjay4gVGhlIGhpc3Rvcnkgc2VydmVzIGFzIHRoZVxuICogc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbiwgYXMgd2VsbCBhcyBwcm92aWRlcyBhIHNldCBvZlxuICogbWV0aG9kcyB0aGF0IG1heSBiZSB1c2VkIHRvIGNoYW5nZSBpdC5cbiAqXG4gKiBJdCBpcyBzaW1pbGFyIHRvIHRoZSBET00ncyBgd2luZG93Lmhpc3RvcnlgIG9iamVjdCwgYnV0IHdpdGggYSBzbWFsbGVyLCBtb3JlXG4gKiBmb2N1c2VkIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IGFjdGlvbiB0aGF0IG1vZGlmaWVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBUaGlzIHdpbGwgYWx3YXlzIGJlXG4gICAqIEFjdGlvbi5Qb3Agd2hlbiBhIGhpc3RvcnkgaW5zdGFuY2UgaXMgZmlyc3QgY3JlYXRlZC4gVGhpcyB2YWx1ZSBpcyBtdXRhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGxvY2F0aW9uLiBUaGlzIHZhbHVlIGlzIG11dGFibGUuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWxpZCBocmVmIGZvciB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSB0aGF0IG1heSBiZSB1c2VkIGFzXG4gICAqIHRoZSB2YWx1ZSBvZiBhbiA8YSBocmVmPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAgICovXG4gIGNyZWF0ZUhyZWYodG86IFRvKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgVVJMIGZvciB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gICAqL1xuICBjcmVhdGVVUkwodG86IFRvKTogVVJMO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBsb2NhdGlvbiB0aGUgc2FtZSB3YXkgd2luZG93Lmhpc3Rvcnkgd291bGQgZG8gKG5vLW9wIGZvciBtZW1vcnlcbiAgICogaGlzdG9yeSkgc28gd2UgZW5zdXJlIG91ciBQVVNIL1JFUExBQ0UgbmF2aWdhdGlvbnMgZm9yIGRhdGEgcm91dGVyc1xuICAgKiBiZWhhdmUgdGhlIHNhbWUgYXMgUE9QXG4gICAqXG4gICAqIEBwYXJhbSB0byBVbmVuY29kZWQgcGF0aFxuICAgKi9cbiAgZW5jb2RlTG9jYXRpb24odG86IFRvKTogUGF0aDtcblxuICAvKipcbiAgICogUHVzaGVzIGEgbmV3IGxvY2F0aW9uIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2ssIGluY3JlYXNpbmcgaXRzIGxlbmd0aCBieSBvbmUuXG4gICAqIElmIHRoZXJlIHdlcmUgYW55IGVudHJpZXMgaW4gdGhlIHN0YWNrIGFmdGVyIHRoZSBjdXJyZW50IG9uZSwgdGhleSBhcmVcbiAgICogbG9zdC5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIG5ldyBVUkxcbiAgICogQHBhcmFtIHN0YXRlIC0gRGF0YSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbmV3IGxvY2F0aW9uXG4gICAqL1xuICBwdXNoKHRvOiBUbywgc3RhdGU/OiBhbnkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgaGlzdG9yeSBzdGFjayB3aXRoIGEgbmV3IG9uZS4gIFRoZVxuICAgKiBsb2NhdGlvbiB0aGF0IHdhcyByZXBsYWNlZCB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBuZXcgVVJMXG4gICAqIEBwYXJhbSBzdGF0ZSAtIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG5ldyBsb2NhdGlvblxuICAgKi9cbiAgcmVwbGFjZSh0bzogVG8sIHN0YXRlPzogYW55KTogdm9pZDtcblxuICAvKipcbiAgICogTmF2aWdhdGVzIGBuYCBlbnRyaWVzIGJhY2t3YXJkL2ZvcndhcmQgaW4gdGhlIGhpc3Rvcnkgc3RhY2sgcmVsYXRpdmUgdG8gdGhlXG4gICAqIGN1cnJlbnQgaW5kZXguIEZvciBleGFtcGxlLCBhIFwiYmFja1wiIG5hdmlnYXRpb24gd291bGQgdXNlIGdvKC0xKS5cbiAgICpcbiAgICogQHBhcmFtIGRlbHRhIC0gVGhlIGRlbHRhIGluIHRoZSBzdGFjayBpbmRleFxuICAgKi9cbiAgZ28oZGVsdGE6IG51bWJlcik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAqIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzXG4gICAqIEByZXR1cm5zIHVubGlzdGVuIC0gQSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHN0b3AgbGlzdGVuaW5nXG4gICAqL1xuICBsaXN0ZW4obGlzdGVuZXI6IExpc3RlbmVyKTogKCkgPT4gdm9pZDtcbn1cblxudHlwZSBIaXN0b3J5U3RhdGUgPSB7XG4gIHVzcjogYW55O1xuICBrZXk/OiBzdHJpbmc7XG4gIGlkeDogbnVtYmVyO1xufTtcblxuY29uc3QgUG9wU3RhdGVFdmVudFR5cGUgPSBcInBvcHN0YXRlXCI7XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBNZW1vcnkgSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIHVzZXItc3VwcGxpZWQgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbG9jYXRpb24uIFVzZWQgd2hlbiBwcm92aWRpbmdcbiAqIGVudHJpZXMgdG8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgIHZpYSBpdHMgYGluaXRpYWxFbnRyaWVzYCBvcHRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEluaXRpYWxFbnRyeSA9IHN0cmluZyB8IFBhcnRpYWw8TG9jYXRpb24+O1xuXG5leHBvcnQgdHlwZSBNZW1vcnlIaXN0b3J5T3B0aW9ucyA9IHtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xuICB2NUNvbXBhdD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIEEgbWVtb3J5IGhpc3Rvcnkgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuIFRoaXMgaXMgdXNlZnVsIGluIHN0YXRlZnVsXG4gKiBlbnZpcm9ubWVudHMgd2hlcmUgdGhlcmUgaXMgbm8gd2ViIGJyb3dzZXIsIHN1Y2ggYXMgbm9kZSB0ZXN0cyBvciBSZWFjdFxuICogTmF0aXZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeUhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNZW1vcnkgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gbWVtb3J5LiBJdCBpcyBkZXNpZ25lZCBmb3IgdXNlXG4gKiBpbiBzdGF0ZWZ1bCBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cyBhbmQgUmVhY3QgTmF0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShcbiAgb3B0aW9uczogTWVtb3J5SGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogTWVtb3J5SGlzdG9yeSB7XG4gIGxldCB7IGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSwgaW5pdGlhbEluZGV4LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllczogTG9jYXRpb25bXTsgLy8gRGVjbGFyZSBzbyB3ZSBjYW4gYWNjZXNzIGZyb20gY3JlYXRlTWVtb3J5TG9jYXRpb25cbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcCgoZW50cnksIGluZGV4KSA9PlxuICAgIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKFxuICAgICAgZW50cnksXG4gICAgICB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsXG4gICAgICBpbmRleCA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdW5kZWZpbmVkXG4gICAgKVxuICApO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KFxuICAgIGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4XG4gICk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXI6IExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCAwKSwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKTogTG9jYXRpb24ge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICB0bzogVG8sXG4gICAgc3RhdGU6IGFueSA9IG51bGwsXG4gICAga2V5Pzogc3RyaW5nXG4gICk6IExvY2F0aW9uIHtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcbiAgICAgIGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLFxuICAgICAgdG8sXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX1gXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvOiBUbykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IE1lbW9yeUhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvOiBUbykge1xuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgICAgIGhhc2g6IHBhdGguaGFzaCB8fCBcIlwiLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2godG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgICAgbGV0IG5leHRJbmRleCA9IGNsYW1wSW5kZXgoaW5kZXggKyBkZWx0YSk7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdGVuKGZuOiBMaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEJyb3dzZXIgSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzIGluIGEgd2ViXG4gKiBicm93c2VyIGVudmlyb25tZW50LiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3IgbW9zdCB3ZWIgYXBwcyBhbmQgcHJvdmlkZXMgdGhlXG4gKiBjbGVhbmVzdCBVUkxzIHRoZSBicm93c2VyJ3MgYWRkcmVzcyBiYXIuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNicm93c2VyaGlzdG9yeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJIaXN0b3J5IGV4dGVuZHMgVXJsSGlzdG9yeSB7fVxuXG5leHBvcnQgdHlwZSBCcm93c2VySGlzdG9yeU9wdGlvbnMgPSBVcmxIaXN0b3J5T3B0aW9ucztcblxuLyoqXG4gKiBCcm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvclxuICogbW9zdCB3ZWIgYXBwcywgYnV0IGl0IHJlcXVpcmVzIHNvbWUgY29uZmlndXJhdGlvbiBvbiB0aGUgc2VydmVyIHRvIGVuc3VyZSB5b3VcbiAqIHNlcnZlIHRoZSBzYW1lIGFwcCBhdCBtdWx0aXBsZSBVUkxzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlYnJvd3Nlcmhpc3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KFxuICBvcHRpb25zOiBCcm93c2VySGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogQnJvd3Nlckhpc3Rvcnkge1xuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24oXG4gICAgd2luZG93OiBXaW5kb3csXG4gICAgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXVxuICApIHtcbiAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzcikgfHwgbnVsbCxcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3c6IFdpbmRvdywgdG86IFRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cblxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbixcbiAgICBjcmVhdGVCcm93c2VySHJlZixcbiAgICBudWxsLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhhc2ggSGlzdG9yeVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgcG9ydGlvblxuICogb2YgdGhlIFVSTCBpbiBhIHdlYiBicm93c2VyIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgaXMgaWRlYWwgZm9yIGFwcHMgdGhhdCBkbyBub3QgY29udHJvbCB0aGUgc2VydmVyIGZvciBzb21lIHJlYXNvblxuICogKGJlY2F1c2UgdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgaXMgbmV2ZXIgc2VudCB0byB0aGUgc2VydmVyKSwgaW5jbHVkaW5nIHNvbWVcbiAqIHNoYXJlZCBob3N0aW5nIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBwcm92aWRlIGZpbmUtZ3JhaW5lZCBjb250cm9scyBvdmVyXG4gKiB3aGljaCBwYWdlcyBhcmUgc2VydmVkIGF0IHdoaWNoIFVSTHMuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNoYXNoaGlzdG9yeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hIaXN0b3J5IGV4dGVuZHMgVXJsSGlzdG9yeSB7fVxuXG5leHBvcnQgdHlwZSBIYXNoSGlzdG9yeU9wdGlvbnMgPSBVcmxIaXN0b3J5T3B0aW9ucztcblxuLyoqXG4gKiBIYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB3aW5kb3cubG9jYXRpb24uaGFzaC4gVGhpcyBtYWtlcyBpdCBpZGVhbFxuICogZm9yIHNpdHVhdGlvbnMgd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgbG9jYXRpb24gdG8gdGhlIHNlcnZlciBmb3JcbiAqIHNvbWUgcmVhc29uLCBlaXRoZXIgYmVjYXVzZSB5b3UgZG8gY2Fubm90IGNvbmZpZ3VyZSBpdCBvciB0aGUgVVJMIHNwYWNlIGlzXG4gKiByZXNlcnZlZCBmb3Igc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVoYXNoaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoXG4gIG9wdGlvbnM6IEhhc2hIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBIYXNoSGlzdG9yeSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbihcbiAgICB3aW5kb3c6IFdpbmRvdyxcbiAgICBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdXG4gICkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgICAgc2VhcmNoID0gXCJcIixcbiAgICAgIGhhc2ggPSBcIlwiLFxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcblxuICAgIC8vIEhhc2ggVVJMIHNob3VsZCBhbHdheXMgaGF2ZSBhIGxlYWRpbmcgLyBqdXN0IGxpa2Ugd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgLy8gZG9lcywgc28gaWYgYW4gYXBwIGVuZHMgdXAgYXQgYSByb3V0ZSBsaWtlIC8jc29tZXRoaW5nIHRoZW4gd2UgYWRkIGFcbiAgICAvLyBsZWFkaW5nIHNsYXNoIHNvIGFsbCBvZiBvdXIgcGF0aC1tYXRjaGluZyBiZWhhdmVzIHRoZSBzYW1lIGFzIGlmIGl0IHdvdWxkXG4gICAgLy8gaW4gYSBicm93c2VyIHJvdXRlci4gIFRoaXMgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudCB3aGVuIHRoZXJlIGV4aXN0cyBhXG4gICAgLy8gcm9vdCBzcGxhdCByb3V0ZSAoPFJvdXRlIHBhdGg9XCIqXCI+KSBzaW5jZSB0aGF0IG1hdGNoZXMgaW50ZXJuYWxseSBhZ2FpbnN0XG4gICAgLy8gXCIvKlwiIGFuZCB3ZSdkIGV4cGVjdCAvI3NvbWV0aGluZyB0byA0MDQgaW4gYSBoYXNoIHJvdXRlciBhcHAuXG4gICAgaWYgKCFwYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSAmJiAhcGF0aG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyKSB8fCBudWxsLFxuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkpIHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hIcmVmKHdpbmRvdzogV2luZG93LCB0bzogVG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKTtcbiAgICBsZXQgaHJlZiA9IFwiXCI7XG5cbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmICsgXCIjXCIgKyAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbjogTG9jYXRpb24sIHRvOiBUbykge1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaCgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX0pYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUhhc2hMb2NhdGlvbixcbiAgICBjcmVhdGVIYXNoSHJlZixcbiAgICB2YWxpZGF0ZUhhc2hMb2NhdGlvbixcbiAgICBvcHRpb25zXG4gICk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlOiBib29sZWFuLCBtZXNzYWdlPzogc3RyaW5nKTogYXNzZXJ0cyB2YWx1ZTtcbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQ8VD4oXG4gIHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgbWVzc2FnZT86IHN0cmluZ1xuKTogYXNzZXJ0cyB2YWx1ZSBpcyBUO1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZTogYW55LCBtZXNzYWdlPzogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlLCBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuXG4vKipcbiAqIEZvciBicm93c2VyLWJhc2VkIGhpc3Rvcmllcywgd2UgY29tYmluZSB0aGUgc3RhdGUgYW5kIGtleSBpbnRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb246IExvY2F0aW9uLCBpbmRleDogbnVtYmVyKTogSGlzdG9yeVN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXgsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvY2F0aW9uIG9iamVjdCB3aXRoIGEgdW5pcXVlIGtleSBmcm9tIHRoZSBnaXZlbiBQYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihcbiAgY3VycmVudDogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHRvOiBUbyxcbiAgc3RhdGU6IGFueSA9IG51bGwsXG4gIGtleT86IHN0cmluZ1xuKTogUmVhZG9ubHk8TG9jYXRpb24+IHtcbiAgbGV0IGxvY2F0aW9uOiBSZWFkb25seTxMb2NhdGlvbj4gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4uKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0byksXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogKHRvICYmICh0byBhcyBMb2NhdGlvbikua2V5KSB8fCBrZXkgfHwgY3JlYXRlS2V5KCksXG4gIH07XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIFVSTCBwYXRoIGZyb20gdGhlIGdpdmVuIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCIsXG59OiBQYXJ0aWFsPFBhdGg+KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKTogUGFydGlhbDxQYXRoPiB7XG4gIGxldCBwYXJzZWRQYXRoOiBQYXJ0aWFsPFBhdGg+ID0ge307XG5cbiAgaWYgKHBhdGgpIHtcbiAgICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVybEhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIFVybEhpc3RvcnlPcHRpb25zID0ge1xuICB3aW5kb3c/OiBXaW5kb3c7XG4gIHY1Q29tcGF0PzogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShcbiAgZ2V0TG9jYXRpb246ICh3aW5kb3c6IFdpbmRvdywgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXSkgPT4gTG9jYXRpb24sXG4gIGNyZWF0ZUhyZWY6ICh3aW5kb3c6IFdpbmRvdywgdG86IFRvKSA9PiBzdHJpbmcsXG4gIHZhbGlkYXRlTG9jYXRpb246ICgobG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pID0+IHZvaWQpIHwgbnVsbCxcbiAgb3B0aW9uczogVXJsSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogVXJsSGlzdG9yeSB7XG4gIGxldCB7IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ISwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lcjogTGlzdGVuZXIgfCBudWxsID0gbnVsbDtcblxuICBsZXQgaW5kZXggPSBnZXRJbmRleCgpITtcbiAgLy8gSW5kZXggc2hvdWxkIG9ubHkgYmUgbnVsbCB3aGVuIHdlIGluaXRpYWxpemUuIElmIG5vdCwgaXQncyBiZWNhdXNlIHRoZVxuICAvLyB1c2VyIGNhbGxlZCBoaXN0b3J5LnB1c2hTdGF0ZSBvciBoaXN0b3J5LnJlcGxhY2VTdGF0ZSBkaXJlY3RseSwgaW4gd2hpY2hcbiAgLy8gY2FzZSB3ZSBzaG91bGQgbG9nIGEgd2FybmluZyBhcyBpdCB3aWxsIHJlc3VsdCBpbiBidWdzLlxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IC4uLmdsb2JhbEhpc3Rvcnkuc3RhdGUsIGlkeDogaW5kZXggfSwgXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbmRleCgpOiBudW1iZXIge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwgeyBpZHg6IG51bGwgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG86IFRvLCBzdGF0ZT86IGFueSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcblxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgZXhjZXB0aW9uIGlzIGJlY2F1c2UgYHN0YXRlYCBjYW4ndCBiZSBzZXJpYWxpemVkLCBsZXQgdGhhdCB0aHJvd1xuICAgICAgLy8gb3V0d2FyZHMganVzdCBsaWtlIGEgcmVwbGFjZSBjYWxsIHdvdWxkIHNvIHRoZSBkZXYga25vd3MgdGhlIGNhdXNlXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9uYXYtaGlzdG9yeS1hcGlzLmh0bWwjc2hhcmVkLWhpc3RvcnktcHVzaC9yZXBsYWNlLXN0YXRlLXN0ZXBzXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zdHJ1Y3R1cmVkLWRhdGEuaHRtbCNzdHJ1Y3R1cmVkc2VyaWFsaXplaW50ZXJuYWxcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnkpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG5cbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG86IFRvKTogVVJMIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPVxuICAgICAgd2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCJcbiAgICAgICAgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgIDogd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgaW52YXJpYW50KFxuICAgICAgYmFzZSxcbiAgICAgIGBObyB3aW5kb3cubG9jYXRpb24uKG9yaWdpbnxocmVmKSBhdmFpbGFibGUgdG8gY3JlYXRlIFVSTCBmb3IgaHJlZjogJHtocmVmfWBcbiAgICApO1xuICAgIHJldHVybiBuZXcgVVJMKGhyZWYsIGJhc2UpO1xuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IEhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaCxcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2UsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuLy8jZW5kcmVnaW9uXG4iLCJpbXBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7IGludmFyaWFudCwgcGFyc2VQYXRoLCB3YXJuaW5nIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuXG4vKipcbiAqIE1hcCBvZiByb3V0ZUlkIC0+IGRhdGEgcmV0dXJuZWQgZnJvbSBhIGxvYWRlci9hY3Rpb24vZXJyb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZURhdGEge1xuICBbcm91dGVJZDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgZW51bSBSZXN1bHRUeXBlIHtcbiAgZGF0YSA9IFwiZGF0YVwiLFxuICBkZWZlcnJlZCA9IFwiZGVmZXJyZWRcIixcbiAgcmVkaXJlY3QgPSBcInJlZGlyZWN0XCIsXG4gIGVycm9yID0gXCJlcnJvclwiLFxufVxuXG4vKipcbiAqIFN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3VjY2Vzc1Jlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGF0YTtcbiAgZGF0YTogYW55O1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBTdWNjZXNzZnVsIGRlZmVyKCkgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVmZXJyZWRSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkO1xuICBkZWZlcnJlZERhdGE6IERlZmVycmVkRGF0YTtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVkaXJlY3QgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVkaXJlY3RSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLnJlZGlyZWN0O1xuICBzdGF0dXM6IG51bWJlcjtcbiAgbG9jYXRpb246IHN0cmluZztcbiAgcmV2YWxpZGF0ZTogYm9vbGVhbjtcbiAgcmVsb2FkRG9jdW1lbnQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFVuc3VjY2Vzc2Z1bCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFcnJvclJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3I7XG4gIGVycm9yOiBhbnk7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvbiAtIHBvdGVudGlhbGx5IHN1Y2Nlc3NmdWwgb3IgdW5zdWNjZXNzZnVsXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFSZXN1bHQgPVxuICB8IFN1Y2Nlc3NSZXN1bHRcbiAgfCBEZWZlcnJlZFJlc3VsdFxuICB8IFJlZGlyZWN0UmVzdWx0XG4gIHwgRXJyb3JSZXN1bHQ7XG5cbnR5cGUgTG93ZXJDYXNlRm9ybU1ldGhvZCA9IFwiZ2V0XCIgfCBcInBvc3RcIiB8IFwicHV0XCIgfCBcInBhdGNoXCIgfCBcImRlbGV0ZVwiO1xudHlwZSBVcHBlckNhc2VGb3JtTWV0aG9kID0gVXBwZXJjYXNlPExvd2VyQ2FzZUZvcm1NZXRob2Q+O1xuXG4vKipcbiAqIFVzZXJzIGNhbiBzcGVjaWZ5IGVpdGhlciBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlIGZvcm0gbWV0aG9kcyBvbiA8Rm9ybT4sXG4gKiB1c2VTdWJtaXQoKSwgPGZldGNoZXIuRm9ybT4sIGV0Yy5cbiAqL1xuZXhwb3J0IHR5cGUgSFRNTEZvcm1NZXRob2QgPSBMb3dlckNhc2VGb3JtTWV0aG9kIHwgVXBwZXJDYXNlRm9ybU1ldGhvZDtcblxuLyoqXG4gKiBBY3RpdmUgbmF2aWdhdGlvbi9mZXRjaGVyIGZvcm0gbWV0aG9kcyBhcmUgZXhwb3NlZCBpbiBsb3dlcmNhc2Ugb24gdGhlXG4gKiBSb3V0ZXJTdGF0ZVxuICovXG5leHBvcnQgdHlwZSBGb3JtTWV0aG9kID0gTG93ZXJDYXNlRm9ybU1ldGhvZDtcbmV4cG9ydCB0eXBlIE11dGF0aW9uRm9ybU1ldGhvZCA9IEV4Y2x1ZGU8Rm9ybU1ldGhvZCwgXCJnZXRcIj47XG5cbi8qKlxuICogSW4gdjcsIGFjdGl2ZSBuYXZpZ2F0aW9uL2ZldGNoZXIgZm9ybSBtZXRob2RzIGFyZSBleHBvc2VkIGluIHVwcGVyY2FzZSBvbiB0aGVcbiAqIFJvdXRlclN0YXRlLiAgVGhpcyBpcyB0byBhbGlnbiB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGRvbmUgdmlhIGZldGNoKCkuXG4gKi9cbmV4cG9ydCB0eXBlIFY3X0Zvcm1NZXRob2QgPSBVcHBlckNhc2VGb3JtTWV0aG9kO1xuZXhwb3J0IHR5cGUgVjdfTXV0YXRpb25Gb3JtTWV0aG9kID0gRXhjbHVkZTxWN19Gb3JtTWV0aG9kLCBcIkdFVFwiPjtcblxuZXhwb3J0IHR5cGUgRm9ybUVuY1R5cGUgPVxuICB8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgfCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICB8IFwiYXBwbGljYXRpb24vanNvblwiXG4gIHwgXCJ0ZXh0L3BsYWluXCI7XG5cbi8vIFRoYW5rcyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3R5cGUtZmVzdCFcbnR5cGUgSnNvbk9iamVjdCA9IHsgW0tleSBpbiBzdHJpbmddOiBKc29uVmFsdWUgfSAmIHtcbiAgW0tleSBpbiBzdHJpbmddPzogSnNvblZhbHVlIHwgdW5kZWZpbmVkO1xufTtcbnR5cGUgSnNvbkFycmF5ID0gSnNvblZhbHVlW10gfCByZWFkb25seSBKc29uVmFsdWVbXTtcbnR5cGUgSnNvblByaW1pdGl2ZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsO1xudHlwZSBKc29uVmFsdWUgPSBKc29uUHJpbWl0aXZlIHwgSnNvbk9iamVjdCB8IEpzb25BcnJheTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHBhc3MgYXJvdW5kIGZvciBhY3Rpb24gc3VibWlzc2lvbnMsIG5vdCBpbnRlbmRlZCBmb3JcbiAqIGV4dGVybmFsIGNvbnN1bXB0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFN1Ym1pc3Npb24gPVxuICB8IHtcbiAgICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgICAgZm9ybURhdGE6IEZvcm1EYXRhO1xuICAgICAganNvbjogdW5kZWZpbmVkO1xuICAgICAgdGV4dDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfCB7XG4gICAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kIHwgVjdfRm9ybU1ldGhvZDtcbiAgICAgIGZvcm1BY3Rpb246IHN0cmluZztcbiAgICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAgICBqc29uOiBKc29uVmFsdWU7XG4gICAgICB0ZXh0OiB1bmRlZmluZWQ7XG4gICAgfVxuICB8IHtcbiAgICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgICAgIGpzb246IHVuZGVmaW5lZDtcbiAgICAgIHRleHQ6IHN0cmluZztcbiAgICB9O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIHJvdXRlIGxvYWRlci9hY3Rpb24gZnVuY3Rpb25zLiAgU2FtZSBmb3Igbm93IGJ1dCB3ZSBrZWVwXG4gKiB0aGlzIGFzIGEgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgaW4gY2FzZSB0aGV5IGRpdmVyZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuaW50ZXJmYWNlIERhdGFGdW5jdGlvbkFyZ3M8Q29udGV4dD4ge1xuICByZXF1ZXN0OiBSZXF1ZXN0O1xuICBwYXJhbXM6IFBhcmFtcztcbiAgY29udGV4dD86IENvbnRleHQ7XG59XG5cbi8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSBkZWZhdWx0cyBmcm9tIGFueSB0byB1bmtub3duIGluIGFuZCByZW1vdmUgUmVtaXggd3JhcHBlcnM6XG4vLyAgIEFjdGlvbkZ1bmN0aW9uLCBBY3Rpb25GdW5jdGlvbkFyZ3MsIExvYWRlckZ1bmN0aW9uLCBMb2FkZXJGdW5jdGlvbkFyZ3Ncbi8vICAgQWxzbywgbWFrZSB0aGVtIGEgdHlwZSBhbGlhcyBpbnN0ZWFkIG9mIGFuIGludGVyZmFjZVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gbG9hZGVyIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckZ1bmN0aW9uQXJnczxDb250ZXh0ID0gYW55PlxuICBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3M8Q29udGV4dD4ge31cblxuLyoqXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIGFjdGlvbiBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25GdW5jdGlvbkFyZ3M8Q29udGV4dCA9IGFueT5cbiAgZXh0ZW5kcyBEYXRhRnVuY3Rpb25BcmdzPENvbnRleHQ+IHt9XG5cbi8qKlxuICogTG9hZGVycyBhbmQgYWN0aW9ucyBjYW4gcmV0dXJuIGFueXRoaW5nIGV4Y2VwdCBgdW5kZWZpbmVkYCAoYG51bGxgIGlzIGFcbiAqIHZhbGlkIHJldHVybiB2YWx1ZSBpZiB0aGVyZSBpcyBubyBkYXRhIHRvIHJldHVybikuICBSZXNwb25zZXMgYXJlIHByZWZlcnJlZFxuICogYW5kIHdpbGwgZWFzZSBhbnkgZnV0dXJlIG1pZ3JhdGlvbiB0byBSZW1peFxuICovXG50eXBlIERhdGFGdW5jdGlvblZhbHVlID0gUmVzcG9uc2UgfCBOb25OdWxsYWJsZTx1bmtub3duPiB8IG51bGw7XG5cbi8qKlxuICogUm91dGUgbG9hZGVyIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckZ1bmN0aW9uPENvbnRleHQgPSBhbnk+IHtcbiAgKGFyZ3M6IExvYWRlckZ1bmN0aW9uQXJnczxDb250ZXh0Pik6XG4gICAgfCBQcm9taXNlPERhdGFGdW5jdGlvblZhbHVlPlxuICAgIHwgRGF0YUZ1bmN0aW9uVmFsdWU7XG59XG5cbi8qKlxuICogUm91dGUgYWN0aW9uIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkZ1bmN0aW9uPENvbnRleHQgPSBhbnk+IHtcbiAgKGFyZ3M6IEFjdGlvbkZ1bmN0aW9uQXJnczxDb250ZXh0Pik6XG4gICAgfCBQcm9taXNlPERhdGFGdW5jdGlvblZhbHVlPlxuICAgIHwgRGF0YUZ1bmN0aW9uVmFsdWU7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyB7XG4gIGN1cnJlbnRVcmw6IFVSTDtcbiAgY3VycmVudFBhcmFtczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtcInBhcmFtc1wiXTtcbiAgbmV4dFVybDogVVJMO1xuICBuZXh0UGFyYW1zOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBmb3JtTWV0aG9kPzogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl07XG4gIGZvcm1BY3Rpb24/OiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgZm9ybUVuY1R5cGU/OiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl07XG4gIHRleHQ/OiBTdWJtaXNzaW9uW1widGV4dFwiXTtcbiAgZm9ybURhdGE/OiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gIGpzb24/OiBTdWJtaXNzaW9uW1wianNvblwiXTtcbiAgYWN0aW9uUmVzdWx0PzogYW55O1xuICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBSb3V0ZSBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uIHNpZ25hdHVyZS4gIFRoaXMgcnVucyBhZnRlciBhbnkgc3VibWlzc2lvblxuICogKG5hdmlnYXRpb24gb3IgZmV0Y2hlciksIHNvIHdlIGZsYXR0ZW4gdGhlIG5hdmlnYXRpb24vZmV0Y2hlciBzdWJtaXNzaW9uXG4gKiBvbnRvIHRoZSBhcmd1bWVudHMuICBJdCBzaG91bGRuJ3QgbWF0dGVyIHdoZXRoZXIgaXQgY2FtZSBmcm9tIGEgbmF2aWdhdGlvblxuICogb3IgYSBmZXRjaGVyLCB3aGF0IHJlYWxseSBtYXR0ZXJzIGlzIHRoZSBVUkxzIGFuZCB0aGUgZm9ybURhdGEgc2luY2UgbG9hZGVyc1xuICogaGF2ZSB0byByZS1ydW4gYmFzZWQgb24gdGhlIGRhdGEgbW9kZWxzIHRoYXQgd2VyZSBwb3RlbnRpYWxseSBtdXRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbiB7XG4gIChhcmdzOiBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzKTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgZnJhbWV3b3JrLWF3YXJlIGxheWVycyB0byBzZXQgYGhhc0Vycm9yQm91bmRhcnlgXG4gKiBmcm9tIHRoZSBmcmFtZXdvcmstYXdhcmUgYGVycm9yRWxlbWVudGAgcHJvcFxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgbWFwUm91dGVQcm9wZXJ0aWVzYCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uIHtcbiAgKHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0KTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgZnJhbWV3b3JrLWF3YXJlIGxheWVycyB0byBzZXQgYW55IGZyYW1ld29yay1zcGVjaWZpY1xuICogcHJvcGVydGllcyBmcm9tIGZyYW1ld29yay1hZ25vc3RpYyBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24ge1xuICAocm91dGU6IEFnbm9zdGljUm91dGVPYmplY3QpOiB7XG4gICAgaGFzRXJyb3JCb3VuZGFyeTogYm9vbGVhbjtcbiAgfSAmIFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbi8qKlxuICogS2V5cyB3ZSBjYW5ub3QgY2hhbmdlIGZyb20gd2l0aGluIGEgbGF6eSgpIGZ1bmN0aW9uLiBXZSBzcHJlYWQgYWxsIG90aGVyIGtleXNcbiAqIG9udG8gdGhlIHJvdXRlLiBFaXRoZXIgdGhleSdyZSBtZWFuaW5nZnVsIHRvIHRoZSByb3V0ZXIsIG9yIHRoZXknbGwgZ2V0XG4gKiBpZ25vcmVkLlxuICovXG5leHBvcnQgdHlwZSBJbW11dGFibGVSb3V0ZUtleSA9XG4gIHwgXCJsYXp5XCJcbiAgfCBcImNhc2VTZW5zaXRpdmVcIlxuICB8IFwicGF0aFwiXG4gIHwgXCJpZFwiXG4gIHwgXCJpbmRleFwiXG4gIHwgXCJjaGlsZHJlblwiO1xuXG5leHBvcnQgY29uc3QgaW1tdXRhYmxlUm91dGVLZXlzID0gbmV3IFNldDxJbW11dGFibGVSb3V0ZUtleT4oW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJjaGlsZHJlblwiLFxuXSk7XG5cbnR5cGUgUmVxdWlyZU9uZTxULCBLZXkgPSBrZXlvZiBUPiA9IEV4Y2x1ZGU8XG4gIHtcbiAgICBbSyBpbiBrZXlvZiBUXTogSyBleHRlbmRzIEtleSA/IE9taXQ8VCwgSz4gJiBSZXF1aXJlZDxQaWNrPFQsIEs+PiA6IG5ldmVyO1xuICB9W2tleW9mIFRdLFxuICB1bmRlZmluZWRcbj47XG5cbi8qKlxuICogbGF6eSgpIGZ1bmN0aW9uIHRvIGxvYWQgYSByb3V0ZSBkZWZpbml0aW9uLCB3aGljaCBjYW4gYWRkIG5vbi1tYXRjaGluZ1xuICogcmVsYXRlZCBwcm9wZXJ0aWVzIHRvIGEgcm91dGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMYXp5Um91dGVGdW5jdGlvbjxSIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdD4ge1xuICAoKTogUHJvbWlzZTxSZXF1aXJlT25lPE9taXQ8UiwgSW1tdXRhYmxlUm91dGVLZXk+Pj47XG59XG5cbi8qKlxuICogQmFzZSBSb3V0ZU9iamVjdCB3aXRoIGNvbW1vbiBwcm9wcyBzaGFyZWQgYnkgYWxsIHR5cGVzIG9mIHJvdXRlc1xuICovXG50eXBlIEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ID0ge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG4gIGxvYWRlcj86IExvYWRlckZ1bmN0aW9uO1xuICBhY3Rpb24/OiBBY3Rpb25GdW5jdGlvbjtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IGJvb2xlYW47XG4gIHNob3VsZFJldmFsaWRhdGU/OiBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb247XG4gIGhhbmRsZT86IGFueTtcbiAgbGF6eT86IExhenlSb3V0ZUZ1bmN0aW9uPEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0Pjtcbn07XG5cbi8qKlxuICogSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogdW5kZWZpbmVkO1xuICBpbmRleDogdHJ1ZTtcbn07XG5cbi8qKlxuICogTm9uLWluZGV4IHJvdXRlcyBtYXkgaGF2ZSBjaGlsZHJlbiwgYnV0IGNhbm5vdCBoYXZlIGluZGV4XG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IEFnbm9zdGljUm91dGVPYmplY3RbXTtcbiAgaW5kZXg/OiBmYWxzZTtcbn07XG5cbi8qKlxuICogQSByb3V0ZSBvYmplY3QgcmVwcmVzZW50cyBhIGxvZ2ljYWwgcm91dGUsIHdpdGggKG9wdGlvbmFsbHkpIGl0cyBjaGlsZFxuICogcm91dGVzIG9yZ2FuaXplZCBpbiBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdDtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgaWQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgaWQ6IHN0cmluZztcbn07XG5cbi8qKlxuICogQSBkYXRhIHJvdXRlIG9iamVjdCwgd2hpY2ggaXMganVzdCBhIFJvdXRlT2JqZWN0IHdpdGggYSByZXF1aXJlZCB1bmlxdWUgSURcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3RcbiAgfCBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBSb3V0ZU1hbmlmZXN0ID0gUmVjb3JkPHN0cmluZywgQWdub3N0aWNEYXRhUm91dGVPYmplY3QgfCB1bmRlZmluZWQ+O1xuXG4vLyBSZWN1cnNpdmUgaGVscGVyIGZvciBmaW5kaW5nIHBhdGggcGFyYW1ldGVycyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbnR5cGUgX1BhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIHNwbGl0IHBhdGggaW50byBpbmRpdmlkdWFsIHBhdGggc2VnbWVudHNcbiAgUGF0aCBleHRlbmRzIGAke2luZmVyIEx9LyR7aW5mZXIgUn1gXG4gICAgPyBfUGF0aFBhcmFtPEw+IHwgX1BhdGhQYXJhbTxSPlxuICAgIDogLy8gZmluZCBwYXJhbXMgYWZ0ZXIgYDpgXG4gICAgUGF0aCBleHRlbmRzIGA6JHtpbmZlciBQYXJhbX1gXG4gICAgPyBQYXJhbSBleHRlbmRzIGAke2luZmVyIE9wdGlvbmFsfT9gXG4gICAgICA/IE9wdGlvbmFsXG4gICAgICA6IFBhcmFtXG4gICAgOiAvLyBvdGhlcndpc2UsIHRoZXJlIGFyZW4ndCBhbnkgcGFyYW1zIHByZXNlbnRcbiAgICAgIG5ldmVyO1xuXG4vKipcbiAqIEV4YW1wbGVzOlxuICogXCIvYS9iLypcIiAtPiBcIipcIlxuICogXCI6YVwiIC0+IFwiYVwiXG4gKiBcIi9hLzpiXCIgLT4gXCJiXCJcbiAqIFwiL2EvYmxhaGJsYWhibGFoOmJcIiAtPiBcImJcIlxuICogXCIvOmEvOmJcIiAtPiBcImFcIiB8IFwiYlwiXG4gKiBcIi86YS9iLzpjLypcIiAtPiBcImFcIiB8IFwiY1wiIHwgXCIqXCJcbiAqL1xudHlwZSBQYXRoUGFyYW08UGF0aCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBjaGVjayBpZiBwYXRoIGlzIGp1c3QgYSB3aWxkY2FyZFxuICBQYXRoIGV4dGVuZHMgXCIqXCIgfCBcIi8qXCJcbiAgICA/IFwiKlwiXG4gICAgOiAvLyBsb29rIGZvciB3aWxkY2FyZCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoXG4gICAgUGF0aCBleHRlbmRzIGAke2luZmVyIFJlc3R9LypgXG4gICAgPyBcIipcIiB8IF9QYXRoUGFyYW08UmVzdD5cbiAgICA6IC8vIGxvb2sgZm9yIHBhcmFtcyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbiAgICAgIF9QYXRoUGFyYW08UGF0aD47XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIHVuaW9uIG9mIHRoZVxuLy8gcGFyc2VkIHN0cmluZyBsaXRlcmFscyB0aGF0IHdlcmUgcmVmZXJlbmNlZCBhcyBkeW5hbWljIHNlZ21lbnRzIGluIHRoZSByb3V0ZS5cbmV4cG9ydCB0eXBlIFBhcmFtUGFyc2VLZXk8U2VnbWVudCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBpZiB5b3UgY291bGQgbm90IGZpbmQgcGF0aCBwYXJhbXMsIGZhbGxiYWNrIHRvIGBzdHJpbmdgXG4gIFtQYXRoUGFyYW08U2VnbWVudD5dIGV4dGVuZHMgW25ldmVyXSA/IHN0cmluZyA6IFBhdGhQYXJhbTxTZWdtZW50PjtcblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFyc2VkIGZyb20gdGhlIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXM8S2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW2tleSBpbiBLZXldOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNSb3V0ZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByb3V0ZSBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaDxzdHJpbmcsIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0PiB7fVxuXG5mdW5jdGlvbiBpc0luZGV4Um91dGUoXG4gIHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0XG4pOiByb3V0ZSBpcyBBZ25vc3RpY0luZGV4Um91dGVPYmplY3Qge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG5cbi8vIFdhbGsgdGhlIHJvdXRlIHRyZWUgZ2VuZXJhdGluZyB1bmlxdWUgSURzIHdoZXJlIG5lY2Vzc2FyeSwgc28gd2UgYXJlIHdvcmtpbmdcbi8vIHNvbGVseSB3aXRoIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0J3Mgd2l0aGluIHRoZSBSb3V0ZXJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgcGFyZW50UGF0aDogbnVtYmVyW10gPSBbXSxcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QgPSB7fVxuKTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGxldCBpZCA9IHR5cGVvZiByb3V0ZS5pZCA9PT0gXCJzdHJpbmdcIiA/IHJvdXRlLmlkIDogdHJlZVBhdGguam9pbihcIi1cIik7XG4gICAgaW52YXJpYW50KFxuICAgICAgcm91dGUuaW5kZXggIT09IHRydWUgfHwgIXJvdXRlLmNoaWxkcmVuLFxuICAgICAgYENhbm5vdCBzcGVjaWZ5IGNoaWxkcmVuIG9uIGFuIGluZGV4IHJvdXRlYFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIW1hbmlmZXN0W2lkXSxcbiAgICAgIGBGb3VuZCBhIHJvdXRlIGlkIGNvbGxpc2lvbiBvbiBpZCBcIiR7aWR9XCIuICBSb3V0ZSBgICtcbiAgICAgICAgXCJpZCdzIG11c3QgYmUgZ2xvYmFsbHkgdW5pcXVlIHdpdGhpbiBEYXRhIFJvdXRlciB1c2FnZXNcIlxuICAgICk7XG5cbiAgICBpZiAoaXNJbmRleFJvdXRlKHJvdXRlKSkge1xuICAgICAgbGV0IGluZGV4Um91dGU6IEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3QgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMocm91dGUpLFxuICAgICAgICBpZCxcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZTogQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IHBhdGhPckxheW91dFJvdXRlO1xuXG4gICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgICAgICB0cmVlUGF0aCxcbiAgICAgICAgICBtYW5pZmVzdFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXJvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSb3V0ZXM8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+KFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0VHlwZVtdLFxuICBsb2NhdGlvbkFyZzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmcsXG4gIGJhc2VuYW1lID0gXCIvXCJcbik6IEFnbm9zdGljUm91dGVNYXRjaDxzdHJpbmcsIFJvdXRlT2JqZWN0VHlwZT5bXSB8IG51bGwge1xuICBsZXQgbG9jYXRpb24gPVxuICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG5cbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuXG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaDxzdHJpbmcsIFJvdXRlT2JqZWN0VHlwZT4oXG4gICAgICBicmFuY2hlc1tpXSxcbiAgICAgIC8vIEluY29taW5nIHBhdGhuYW1lcyBhcmUgZ2VuZXJhbGx5IGVuY29kZWQgZnJvbSBlaXRoZXIgd2luZG93LmxvY2F0aW9uXG4gICAgICAvLyBvciBmcm9tIHJvdXRlci5uYXZpZ2F0ZSwgYnV0IHdlIHdhbnQgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgdW5lbmNvZGVkXG4gICAgICAvLyBwYXRocyBpbiB0aGUgcm91dGUgZGVmaW5pdGlvbnMuICBNZW1vcnkgcm91dGVyIGxvY2F0aW9ucyB3b24ndCBiZVxuICAgICAgLy8gZW5jb2RlZCBoZXJlIGJ1dCB0aGVyZSBhbHNvIHNob3VsZG4ndCBiZSBhbnl0aGluZyB0byBkZWNvZGUgc28gdGhpc1xuICAgICAgLy8gc2hvdWxkIGJlIGEgc2FmZSBvcGVyYXRpb24uICBUaGlzIGF2b2lkcyBuZWVkaW5nIG1hdGNoUm91dGVzIHRvIGJlXG4gICAgICAvLyBoaXN0b3J5LWF3YXJlLlxuICAgICAgc2FmZWx5RGVjb2RlVVJJKHBhdGhuYW1lKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVSU1hdGNoPERhdGEgPSB1bmtub3duLCBIYW5kbGUgPSB1bmtub3duPiB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIHBhcmFtczogQWdub3N0aWNSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBkYXRhOiBEYXRhO1xuICBoYW5kbGU6IEhhbmRsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhXG4pOiBVSU1hdGNoIHtcbiAgbGV0IHsgcm91dGUsIHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gIH07XG59XG5cbmludGVyZmFjZSBSb3V0ZU1ldGE8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIGNhc2VTZW5zaXRpdmU6IGJvb2xlYW47XG4gIGNoaWxkcmVuSW5kZXg6IG51bWJlcjtcbiAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZTtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQnJhbmNoPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91dGVzTWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT5bXTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGJyYW5jaGVzOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50c01ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50UGF0aCA9IFwiXCJcbik6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT5bXSB7XG4gIGxldCBmbGF0dGVuUm91dGUgPSAoXG4gICAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZSxcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIHJlbGF0aXZlUGF0aD86IHN0cmluZ1xuICApID0+IHtcbiAgICBsZXQgbWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT4gPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6XG4gICAgICAgIHJlbGF0aXZlUGF0aCA9PT0gdW5kZWZpbmVkID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGUsXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSwgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgLy8gT3VyIHR5cGVzIGtub3cgYmV0dGVyLCBidXQgcnVudGltZSBKUyBtYXkgbm90IVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLFxuICAgICAgICBgSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIGAgK1xuICAgICAgICAgIGBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuXG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyYW5jaGVzLnB1c2goe1xuICAgICAgcGF0aCxcbiAgICAgIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLFxuICAgICAgcm91dGVzTWV0YSxcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIC8vIGNvYXJzZS1ncmFpbiBjaGVjayBmb3Igb3B0aW9uYWwgcGFyYW1zXG4gICAgaWYgKHJvdXRlLnBhdGggPT09IFwiXCIgfHwgIXJvdXRlLnBhdGg/LmluY2x1ZGVzKFwiP1wiKSkge1xuICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGV4cGxvZGVkIG9mIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgsIGV4cGxvZGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbGwgY29tYmluYXRpb25zIG9mIG9wdGlvbmFsIHBhdGggc2VnbWVudHMgZm9yIGEgZ2l2ZW4gcGF0aCxcbiAqIGV4Y2x1ZGluZyBjb21iaW5hdGlvbnMgdGhhdCBhcmUgYW1iaWd1b3VzIGFuZCBvZiBsb3dlciBwcmlvcml0eS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYC9vbmUvOnR3bz8vdGhyZWUvOmZvdXI/LzpmaXZlP2AgZXhwbG9kZXMgdG86XG4gKiAtIGAvb25lL3RocmVlYFxuICogLSBgL29uZS86dHdvL3RocmVlYFxuICogLSBgL29uZS90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyLzpmaXZlYFxuICovXG5mdW5jdGlvbiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhwYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcblxuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG5cbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSW50ZXByZXQgZW1wdHkgc3RyaW5nIGFzIG9taXR0aW5nIGFuIG9wdGlvbmFsIHNlZ21lbnRcbiAgICAvLyBgW1wib25lXCIsIFwiXCIsIFwidGhyZWVcIl1gIGNvcnJlc3BvbmRzIHRvIG9taXR0aW5nIGA6dHdvYCBmcm9tIGAvb25lLzp0d28/L3RocmVlYCAtPiBgL29uZS90aHJlZWBcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG5cbiAgbGV0IHJlc3RFeHBsb2RlZCA9IGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJlc3Quam9pbihcIi9cIikpO1xuXG4gIGxldCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiwgc28gd2UgZ2V0IGNvbnNpc3RlbnQgb3JkZXJpbmcgd2hlcmUgdGhlXG4gIC8vIHBhcmVudCBvcHRpb25hbCBhc3BlY3QgaXMgcHJlZmVycmVkIGFzIHJlcXVpcmVkLiAgT3RoZXJ3aXNlLCB3ZSBjYW4gZ2V0XG4gIC8vIGNoaWxkIHNlY3Rpb25zIGludGVyc3BlcnNlZCB3aGVyZSBkZWVwZXIgb3B0aW9uYWwgc2VnbWVudHMgYXJlIGhpZ2hlciB0aGFuXG4gIC8vIHBhcmVudCBvcHRpb25hbCBzZWdtZW50cywgd2hlcmUgZm9yIGV4YW1wbGUsIC86dHdvIHdvdWxkIGV4cGxvZGUgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKFxuICAgIC4uLnJlc3RFeHBsb2RlZC5tYXAoKHN1YnBhdGgpID0+XG4gICAgICBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpXG4gICAgKVxuICApO1xuXG4gIC8vIFRoZW4sIGlmIHRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIGFkZCBhbGwgY2hpbGQgdmVyc2lvbnMgd2l0aG91dFxuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cblxuICAvLyBmb3IgYWJzb2x1dGUgcGF0aHMsIGVuc3VyZSBgL2AgaW5zdGVhZCBvZiBlbXB0eSBzZWdtZW50XG4gIHJldHVybiByZXN1bHQubWFwKChleHBsb2RlZCkgPT5cbiAgICBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZFxuICApO1xufVxuXG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlczogUm91dGVCcmFuY2hbXSk6IHZvaWQge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PlxuICAgIGEuc2NvcmUgIT09IGIuc2NvcmVcbiAgICAgID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gICAgICA6IGNvbXBhcmVJbmRleGVzKFxuICAgICAgICAgIGEucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleCksXG4gICAgICAgICAgYi5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KVxuICAgICAgICApXG4gICk7XG59XG5cbmNvbnN0IHBhcmFtUmUgPSAvXjpcXHcrJC87XG5jb25zdCBkeW5hbWljU2VnbWVudFZhbHVlID0gMztcbmNvbnN0IGluZGV4Um91dGVWYWx1ZSA9IDI7XG5jb25zdCBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG5jb25zdCBzdGF0aWNTZWdtZW50VmFsdWUgPSAxMDtcbmNvbnN0IHNwbGF0UGVuYWx0eSA9IC0yO1xuY29uc3QgaXNTcGxhdCA9IChzOiBzdHJpbmcpID0+IHMgPT09IFwiKlwiO1xuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aDogc3RyaW5nLCBpbmRleDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cblxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzXG4gICAgLmZpbHRlcigocykgPT4gIWlzU3BsYXQocykpXG4gICAgLnJlZHVjZShcbiAgICAgIChzY29yZSwgc2VnbWVudCkgPT5cbiAgICAgICAgc2NvcmUgK1xuICAgICAgICAocGFyYW1SZS50ZXN0KHNlZ21lbnQpXG4gICAgICAgICAgPyBkeW5hbWljU2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzZWdtZW50ID09PSBcIlwiXG4gICAgICAgICAgPyBlbXB0eVNlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc3RhdGljU2VnbWVudFZhbHVlKSxcbiAgICAgIGluaXRpYWxTY29yZVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGxldCBzaWJsaW5ncyA9XG4gICAgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcblxuICByZXR1cm4gc2libGluZ3NcbiAgICA/IC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgICAgIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAgICAgLy8gYmVoYXZpb3IgYnkgc2ltcGx5IHB1dHRpbmcgcm91dGVzIHdpdGggaWRlbnRpY2FsIHBhdGhzIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gICAgICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV1cbiAgICA6IC8vIE90aGVyd2lzZSwgaXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSB0byByYW5rIG5vbi1zaWJsaW5ncyBieSBpbmRleCxcbiAgICAgIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAgICAgMDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+KFxuICBicmFuY2g6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT4sXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPltdIHwgbnVsbCB7XG4gIGxldCB7IHJvdXRlc01ldGEgfSA9IGJyYW5jaDtcblxuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzOiBBZ25vc3RpY1JvdXRlTWF0Y2g8UGFyYW1LZXksIFJvdXRlT2JqZWN0VHlwZT5bXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlc01ldGEubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWV0YSA9IHJvdXRlc01ldGFbaV07XG4gICAgbGV0IGVuZCA9IGkgPT09IHJvdXRlc01ldGEubGVuZ3RoIC0gMTtcbiAgICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPVxuICAgICAgbWF0Y2hlZFBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICA/IHBhdGhuYW1lXG4gICAgICAgIDogcGF0aG5hbWUuc2xpY2UobWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKFxuICAgICAgeyBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCwgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLCBlbmQgfSxcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgKTtcblxuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuXG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcblxuICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAvLyBUT0RPOiBDYW4gdGhpcyBhcyBiZSBhdm9pZGVkP1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zIGFzIFBhcmFtczxQYXJhbUtleT4sXG4gICAgICBwYXRobmFtZTogam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICBwYXRobmFtZUJhc2U6IG5vcm1hbGl6ZVBhdGhuYW1lKFxuICAgICAgICBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgICAgICksXG4gICAgICByb3V0ZSxcbiAgICB9KTtcblxuICAgIGlmIChtYXRjaC5wYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPSBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGggd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvZ2VuZXJhdGUtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXRoPFBhdGggZXh0ZW5kcyBzdHJpbmc+KFxuICBvcmlnaW5hbFBhdGg6IFBhdGgsXG4gIHBhcmFtczoge1xuICAgIFtrZXkgaW4gUGF0aFBhcmFtPFBhdGg+XTogc3RyaW5nIHwgbnVsbDtcbiAgfSA9IHt9IGFzIGFueVxuKTogc3RyaW5nIHtcbiAgbGV0IHBhdGg6IHN0cmluZyA9IG9yaWdpbmFsUGF0aDtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICAgIGBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIGAgK1xuICAgICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICAgKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSBhcyBQYXRoO1xuICB9XG5cbiAgLy8gZW5zdXJlIGAvYCBpcyBhZGRlZCBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlXG4gIGNvbnN0IHByZWZpeCA9IHBhdGguc3RhcnRzV2l0aChcIi9cIikgPyBcIi9cIiA6IFwiXCI7XG5cbiAgY29uc3Qgc3RyaW5naWZ5ID0gKHA6IGFueSkgPT5cbiAgICBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aFxuICAgIC5zcGxpdCgvXFwvKy8pXG4gICAgLm1hcCgoc2VnbWVudCwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIG9ubHkgYXBwbHkgdGhlIHNwbGF0IGlmIGl0J3MgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgaWYgKGlzTGFzdFNlZ21lbnQgJiYgc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhciA9IFwiKlwiIGFzIFBhdGhQYXJhbTxQYXRoPjtcbiAgICAgICAgLy8gQXBwbHkgdGhlIHNwbGF0XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkocGFyYW1zW3N0YXJdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5TWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihcXHcrKShcXD8/KSQvKTtcbiAgICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgICBsZXQgcGFyYW0gPSBwYXJhbXNba2V5IGFzIFBhdGhQYXJhbTxQYXRoPl07XG4gICAgICAgIGludmFyaWFudChvcHRpb25hbCA9PT0gXCI/XCIgfHwgcGFyYW0gIT0gbnVsbCwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgICAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvXFw/JC9nLCBcIlwiKTtcbiAgICB9KVxuICAgIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHNlZ21lbnQpID0+ICEhc2VnbWVudCk7XG5cbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuXG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFBhdHRlcm48UGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBhIFVSTCBwYXRobmFtZS4gTWF5IGNvbnRhaW4gYDppZGAtc3R5bGUgc2VnbWVudHNcbiAgICogdG8gaW5kaWNhdGUgcGxhY2Vob2xkZXJzIGZvciBkeW5hbWljIHBhcmFtZXRlcnMuIE1heSBhbHNvIGVuZCB3aXRoIGAvKmAgdG9cbiAgICogaW5kaWNhdGUgbWF0Y2hpbmcgdGhlIHJlc3Qgb2YgdGhlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIHBhdGg6IFBhdGg7XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBzdGF0aWMgcG9ydGlvbnMgb2YgdGhlIGBwYXRoYCBzaG91bGQgYmUgbWF0Y2hlZCBpblxuICAgKiB0aGUgc2FtZSBjYXNlLlxuICAgKi9cbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoaXMgcGF0dGVybiBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBlbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgUGF0aE1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgUGF0aFBhdHRlcm4gbWF0Y2hlZCBvbiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcGF0dGVybjogUGF0aFBhdHRlcm47XG59XG5cbnR5cGUgTXV0YWJsZTxUPiA9IHtcbiAgLXJlYWRvbmx5IFtQIGluIGtleW9mIFRdOiBUW1BdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFBhdGg8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihcbiAgcGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuXG4gIGxldCBbbWF0Y2hlciwgcGFyYW1OYW1lc10gPSBjb21waWxlUGF0aChcbiAgICBwYXR0ZXJuLnBhdGgsXG4gICAgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLFxuICAgIHBhdHRlcm4uZW5kXG4gICk7XG5cbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXM6IFBhcmFtcyA9IHBhcmFtTmFtZXMucmVkdWNlPE11dGFibGU8UGFyYW1zPj4oXG4gICAgKG1lbW8sIHBhcmFtTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJhbXNbXCIqXCJdIGxhdGVyIGJlY2F1c2UgaXQgd2lsbCBiZSBkZWNvZGVkIHRoZW5cbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lXG4gICAgICAgICAgLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aClcbiAgICAgICAgICAucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuXG4gICAgICBtZW1vW3BhcmFtTmFtZV0gPSBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCIsXG4gICAgICAgIHBhcmFtTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21waWxlUGF0aChcbiAgcGF0aDogc3RyaW5nLFxuICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gIGVuZCA9IHRydWVcbik6IFtSZWdFeHAsIHN0cmluZ1tdXSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgIGBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGAgK1xuICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG5cbiAgbGV0IHBhcmFtTmFtZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPVxuICAgIFwiXlwiICtcbiAgICBwYXRoXG4gICAgICAucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcbiAgICAgIC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKSAvLyBNYWtlIHN1cmUgaXQgaGFzIGEgbGVhZGluZyAvXG4gICAgICAucmVwbGFjZSgvW1xcXFwuKiteJD97fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gICAgICAucmVwbGFjZSgvXFwvOihcXHcrKS9nLCAoXzogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgcmV0dXJuIFwiLyhbXlxcXFwvXSspXCI7XG4gICAgICB9KTtcblxuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbU5hbWVzLnB1c2goXCIqXCIpO1xuICAgIHJlZ2V4cFNvdXJjZSArPVxuICAgICAgcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiXG4gICAgICAgID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgICAgIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjsgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgLyBpbiBwYXJhbXNbXCIqXCJdXG4gIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIlxcXFwvKiRcIjtcbiAgfSBlbHNlIGlmIChwYXRoICE9PSBcIlwiICYmIHBhdGggIT09IFwiL1wiKSB7XG4gICAgLy8gSWYgb3VyIHBhdGggaXMgbm9uLWVtcHR5IGFuZCBjb250YWlucyBhbnl0aGluZyBiZXlvbmQgYW4gaW5pdGlhbCBzbGFzaCxcbiAgICAvLyB0aGVuIHdlIGhhdmUgX3NvbWVfIGZvcm0gb2YgcGF0aCBpbiBvdXIgcmVnZXgsIHNvIHdlIHNob3VsZCBleHBlY3QgdG9cbiAgICAvLyBtYXRjaCBvbmx5IGlmIHdlIGZpbmQgdGhlIGVuZCBvZiB0aGlzIHBhdGggc2VnbWVudC4gIExvb2sgZm9yIGFuIG9wdGlvbmFsXG4gICAgLy8gbm9uLWNhcHR1cmVkIHRyYWlsaW5nIHNsYXNoICh0byBtYXRjaCBhIHBvcnRpb24gb2YgdGhlIFVSTCkgb3IgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBwYXRoIChpZiB3ZSd2ZSBtYXRjaGVkIHRvIHRoZSBlbmQpLiAgV2UgdXNlZCB0byBkbyB0aGlzIHdpdGggYVxuICAgIC8vIHdvcmQgYm91bmRhcnkgYnV0IHRoYXQgZ2l2ZXMgZmFsc2UgcG9zaXRpdmVzIG9uIHJvdXRlcyBsaWtlXG4gICAgLy8gL3VzZXItcHJlZmVyZW5jZXMgc2luY2UgYC1gIGNvdW50cyBhcyBhIHdvcmQgYm91bmRhcnkuXG4gICAgcmVnZXhwU291cmNlICs9IFwiKD86KD89XFxcXC98JCkpXCI7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm90aGluZyB0byBtYXRjaCBmb3IgXCJcIiBvciBcIi9cIlxuICB9XG5cbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcblxuICByZXR1cm4gW21hdGNoZXIsIHBhcmFtTmFtZXNdO1xufVxuXG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUkkodmFsdWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUkkodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgVVJMIHBhdGggXCIke3ZhbHVlfVwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgaXMgYSBgICtcbiAgICAgICAgYG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBgICtcbiAgICAgICAgYGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcIiR7cGFyYW1OYW1lfVwiIHdpbGwgbm90IGJlIGRlY29kZWQgYmVjYXVzZWAgK1xuICAgICAgICBgIHRoZSBzdHJpbmcgXCIke3ZhbHVlfVwiIGlzIGEgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5YCArXG4gICAgICAgIGAgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBiYXNlbmFtZTogc3RyaW5nXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuXG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIGxlYXZlIHRyYWlsaW5nIHNsYXNoIGJlaGF2aW9yIGluIHRoZSB1c2VyJ3MgY29udHJvbCwgc28gaWYgdGhleVxuICAvLyBzcGVjaWZ5IGEgYmFzZW5hbWUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLCB3ZSBzaG91bGQgc3VwcG9ydCBpdFxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKVxuICAgID8gYmFzZW5hbWUubGVuZ3RoIC0gMVxuICAgIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZXNvbHZlZCBwYXRoIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9yZXNvbHZlLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvOiBUbywgZnJvbVBhdGhuYW1lID0gXCIvXCIpOiBQYXRoIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuXG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWVcbiAgICA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgID8gdG9QYXRobmFtZVxuICAgICAgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKVxuICAgIDogZnJvbVBhdGhuYW1lO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpLFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZyb21QYXRobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG5cbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgLy8gS2VlcCB0aGUgcm9vdCBcIlwiIHNlZ21lbnQgc28gdGhlIHBhdGhuYW1lIHN0YXJ0cyBhdCAvXG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cblxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihcbiAgY2hhcjogc3RyaW5nLFxuICBmaWVsZDogc3RyaW5nLFxuICBkZXN0OiBzdHJpbmcsXG4gIHBhdGg6IFBhcnRpYWw8UGF0aD5cbikge1xuICByZXR1cm4gKFxuICAgIGBDYW5ub3QgaW5jbHVkZSBhICcke2NoYXJ9JyBjaGFyYWN0ZXIgaW4gYSBtYW51YWxseSBzcGVjaWZpZWQgYCArXG4gICAgYFxcYHRvLiR7ZmllbGR9XFxgIGZpZWxkIFske0pTT04uc3RyaW5naWZ5KFxuICAgICAgcGF0aFxuICAgICl9XS4gIFBsZWFzZSBzZXBhcmF0ZSBpdCBvdXQgdG8gdGhlIGAgK1xuICAgIGBcXGB0by4ke2Rlc3R9XFxgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIGAgK1xuICAgIGBhIHN0cmluZyBpbiA8TGluayB0bz1cIi4uLlwiPiBhbmQgdGhlIHJvdXRlciB3aWxsIHBhcnNlIGl0IGZvciB5b3UuYFxuICApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogV2hlbiBwcm9jZXNzaW5nIHJlbGF0aXZlIG5hdmlnYXRpb24gd2Ugd2FudCB0byBpZ25vcmUgYW5jZXN0b3Igcm91dGVzIHRoYXRcbiAqIGRvIG5vdCBjb250cmlidXRlIHRvIHRoZSBwYXRoLCBzdWNoIHRoYXQgaW5kZXgvcGF0aGxlc3MgbGF5b3V0IHJvdXRlcyBkb24ndFxuICogaW50ZXJmZXJlLlxuICpcbiAqIEZvciBleGFtcGxlLCB3aGVuIG1vdmluZyBhIHJvdXRlIGVsZW1lbnQgaW50byBhbiBpbmRleCByb3V0ZSBhbmQvb3IgYVxuICogcGF0aGxlc3MgbGF5b3V0IHJvdXRlLCByZWxhdGl2ZSBsaW5rIGJlaGF2aW9yIGNvbnRhaW5lZCB3aXRoaW4gc2hvdWxkIHN0YXlcbiAqIHRoZSBzYW1lLiAgQm90aCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIHNob3VsZCBsaW5rIGJhY2sgdG8gdGhlIHJvb3Q6XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cbiAqICAgICA8Um91dGUgcGF0aD1cImFjY291bnRzXCIgZWxlbWVudD17PExpbmsgdG89XCIuLlwifT5cbiAqICAgPC9Sb3V0ZT5cbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIj5cbiAqICAgICAgIDxSb3V0ZSBlbGVtZW50PXs8QWNjb3VudHNMYXlvdXQgLz59PiAgICAgICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgICA8Um91dGUgaW5kZXggZWxlbWVudD17PExpbmsgdG89XCIuLlwifSAvPiAgLy8gPC0tIERvZXMgbm90IGNvbnRyaWJ1dGVcbiAqICAgICAgIDwvUm91dGVcbiAqICAgICA8L1JvdXRlPlxuICogICA8L1JvdXRlPlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXM8XG4gIFQgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlTWF0Y2ggPSBBZ25vc3RpY1JvdXRlTWF0Y2hcbj4obWF0Y2hlczogVFtdKSB7XG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcihcbiAgICAobWF0Y2gsIGluZGV4KSA9PlxuICAgICAgaW5kZXggPT09IDAgfHwgKG1hdGNoLnJvdXRlLnBhdGggJiYgbWF0Y2gucm91dGUucGF0aC5sZW5ndGggPiAwKVxuICApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVG8oXG4gIHRvQXJnOiBUbyxcbiAgcm91dGVQYXRobmFtZXM6IHN0cmluZ1tdLFxuICBsb2NhdGlvblBhdGhuYW1lOiBzdHJpbmcsXG4gIGlzUGF0aFJlbGF0aXZlID0gZmFsc2Vcbik6IFBhdGgge1xuICBsZXQgdG86IFBhcnRpYWw8UGF0aD47XG4gIGlmICh0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdG8gPSB7IC4uLnRvQXJnIH07XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiP1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCI/XCIsIFwicGF0aG5hbWVcIiwgXCJzZWFyY2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiI1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwicGF0aG5hbWVcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnNlYXJjaCB8fCAhdG8uc2VhcmNoLmluY2x1ZGVzKFwiI1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICB9XG5cbiAgbGV0IGlzRW1wdHlQYXRoID0gdG9BcmcgPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCI7XG4gIGxldCB0b1BhdGhuYW1lID0gaXNFbXB0eVBhdGggPyBcIi9cIiA6IHRvLnBhdGhuYW1lO1xuXG4gIGxldCBmcm9tOiBzdHJpbmc7XG5cbiAgLy8gUm91dGluZyBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwYXRobmFtZSBpZiBleHBsaWNpdGx5IHJlcXVlc3RlZC5cbiAgLy9cbiAgLy8gSWYgYSBwYXRobmFtZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIGB0b2AsIGl0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGVcbiAgLy8gcm91dGUgY29udGV4dC4gVGhpcyBpcyBleHBsYWluZWQgaW4gYE5vdGUgb24gYDxMaW5rIHRvPmAgdmFsdWVzYCBpbiBvdXJcbiAgLy8gbWlncmF0aW9uIGd1aWRlIGZyb20gdjUgYXMgYSBtZWFucyBvZiBkaXNhbWJpZ3VhdGlvbiBiZXR3ZWVuIGB0b2AgdmFsdWVzXG4gIC8vIHRoYXQgYmVnaW4gd2l0aCBgL2AgYW5kIHRob3NlIHRoYXQgZG8gbm90LiBIb3dldmVyLCB0aGlzIGlzIHByb2JsZW1hdGljIGZvclxuICAvLyBgdG9gIHZhbHVlcyB0aGF0IGRvIG5vdCBwcm92aWRlIGEgcGF0aG5hbWUuIGB0b2AgY2FuIHNpbXBseSBiZSBhIHNlYXJjaCBvclxuICAvLyBoYXNoIHN0cmluZywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgYXNzdW1lIHRoYXQgdGhlIG5hdmlnYXRpb24gaXMgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24ncyBwYXRobmFtZSBhbmQgKm5vdCogdGhlIHJvdXRlIHBhdGhuYW1lLlxuICBpZiAoaXNQYXRoUmVsYXRpdmUgfHwgdG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG5cbiAgICAgIC8vIEVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZVxuICAgICAgLy8gVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXkgZGlmZmVyZW5jZSBmcm9tIGhvdyA8YSBocmVmPiB3b3JrcyBhbmQgYVxuICAgICAgLy8gbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG4gICAgICB3aGlsZSAodG9TZWdtZW50c1swXSA9PT0gXCIuLlwiKSB7XG4gICAgICAgIHRvU2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgcm91dGVQYXRobmFtZUluZGV4IC09IDE7XG4gICAgICB9XG5cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBcIi4uXCIgc2VnbWVudHMgdGhhbiBwYXJlbnQgcm91dGVzLCByZXNvbHZlIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHJvb3QgLyBVUkwuXG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG5cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG5cbiAgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgXCJ0b1wiIGhhZCBvbmVcbiAgbGV0IGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCA9XG4gICAgdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgLy8gT3IgaWYgdGhpcyB3YXMgYSBsaW5rIHRvIHRoZSBjdXJyZW50IHBhdGggd2hpY2ggaGFzIGEgdHJhaWxpbmcgc2xhc2hcbiAgbGV0IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoID1cbiAgICAoaXNFbXB0eVBhdGggfHwgdG9QYXRobmFtZSA9PT0gXCIuXCIpICYmIGxvY2F0aW9uUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBpZiAoXG4gICAgIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmXG4gICAgKGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCB8fCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaClcbiAgKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvOiBUbyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgLyBwYXRoc1xuICByZXR1cm4gdG8gPT09IFwiXCIgfHwgKHRvIGFzIFBhdGgpLnBhdGhuYW1lID09PSBcIlwiXG4gICAgPyBcIi9cIlxuICAgIDogdHlwZW9mIHRvID09PSBcInN0cmluZ1wiXG4gICAgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lXG4gICAgOiB0by5wYXRobmFtZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgam9pblBhdGhzID0gKHBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyA9PlxuICBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aG5hbWUgPSAocGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiXG4gICAgPyBcIlwiXG4gICAgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIilcbiAgICA/IHNlYXJjaFxuICAgIDogXCI/XCIgKyBzZWFyY2g7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUhhc2ggPSAoaGFzaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuXG5leHBvcnQgdHlwZSBKc29uRnVuY3Rpb24gPSA8RGF0YT4oXG4gIGRhdGE6IERhdGEsXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gUmVzcG9uc2U7XG5cbi8qKlxuICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBjcmVhdGluZyBgYXBwbGljYXRpb24vanNvbmAgcmVzcG9uc2VzLiBDb252ZXJ0cyBgZGF0YWBcbiAqIHRvIEpTT04gYW5kIHNldHMgdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGpzb246IEpzb25GdW5jdGlvbiA9IChkYXRhLCBpbml0ID0ge30pID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8geyBzdGF0dXM6IGluaXQgfSA6IGluaXQ7XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnMsXG4gIH0pO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFja2VkUHJvbWlzZSBleHRlbmRzIFByb21pc2U8YW55PiB7XG4gIF90cmFja2VkPzogYm9vbGVhbjtcbiAgX2RhdGE/OiBhbnk7XG4gIF9lcnJvcj86IGFueTtcbn1cblxuZXhwb3J0IGNsYXNzIEFib3J0ZWREZWZlcnJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IGNsYXNzIERlZmVycmVkRGF0YSB7XG4gIHByaXZhdGUgcGVuZGluZ0tleXNTZXQ6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHByaXZhdGUgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xuICBwcml2YXRlIGFib3J0UHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbiAgcHJpdmF0ZSB1bmxpc3RlbkFib3J0U2lnbmFsOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIHN1YnNjcmliZXJzOiBTZXQ8KGFib3J0ZWQ6IGJvb2xlYW4sIHNldHRsZWRLZXk/OiBzdHJpbmcpID0+IHZvaWQ+ID1cbiAgICBuZXcgU2V0KCk7XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICBpbml0PzogUmVzcG9uc2VJbml0O1xuICBkZWZlcnJlZEtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHJlc3BvbnNlSW5pdD86IFJlc3BvbnNlSW5pdCkge1xuICAgIGludmFyaWFudChcbiAgICAgIGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSksXG4gICAgICBcImRlZmVyKCkgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHNcIlxuICAgICk7XG5cbiAgICAvLyBTZXQgdXAgYW4gQWJvcnRDb250cm9sbGVyICsgUHJvbWlzZSB3ZSBjYW4gcmFjZSBhZ2FpbnN0IHRvIGV4aXQgZWFybHlcbiAgICAvLyBjYW5jZWxsYXRpb25cbiAgICBsZXQgcmVqZWN0OiAoZTogQWJvcnRlZERlZmVycmVkRXJyb3IpID0+IHZvaWQ7XG4gICAgdGhpcy5hYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gKHJlamVjdCA9IHIpKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG9uQWJvcnQgPSAoKSA9PlxuICAgICAgcmVqZWN0KG5ldyBBYm9ydGVkRGVmZXJyZWRFcnJvcihcIkRlZmVycmVkIGRhdGEgYWJvcnRlZFwiKSk7XG4gICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsID0gKCkgPT5cbiAgICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuXG4gICAgdGhpcy5kYXRhID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB0aGlzLnRyYWNrUHJvbWlzZShrZXksIHZhbHVlKSxcbiAgICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBBbGwgaW5jb21pbmcgdmFsdWVzIHdlcmUgcmVzb2x2ZWRcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdCA9IHJlc3BvbnNlSW5pdDtcbiAgfVxuXG4gIHByaXZhdGUgdHJhY2tQcm9taXNlKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHZhbHVlOiBQcm9taXNlPHVua25vd24+IHwgdW5rbm93blxuICApOiBUcmFja2VkUHJvbWlzZSB8IHVua25vd24ge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZmVycmVkS2V5cy5wdXNoKGtleSk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5hZGQoa2V5KTtcblxuICAgIC8vIFdlIHN0b3JlIGEgbGl0dGxlIHdyYXBwZXIgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aFxuICAgIC8vIF9kYXRhL19lcnJvciBwcm9wcyB1cG9uIHJlc29sdmUvcmVqZWN0XG4gICAgbGV0IHByb21pc2U6IFRyYWNrZWRQcm9taXNlID0gUHJvbWlzZS5yYWNlKFt2YWx1ZSwgdGhpcy5hYm9ydFByb21pc2VdKS50aGVuKFxuICAgICAgKGRhdGEpID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCB1bmRlZmluZWQsIGRhdGEgYXMgdW5rbm93biksXG4gICAgICAoZXJyb3IpID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvciBhcyB1bmtub3duKVxuICAgICk7XG5cbiAgICAvLyBSZWdpc3RlciByZWplY3Rpb24gbGlzdGVuZXJzIHRvIGF2b2lkIHVuY2F1Z2h0IHByb21pc2UgcmVqZWN0aW9ucyBvblxuICAgIC8vIGVycm9ycyBvciBhYm9ydGVkIGRlZmVycmVkIHZhbHVlc1xuICAgIHByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIG9uU2V0dGxlKFxuICAgIHByb21pc2U6IFRyYWNrZWRQcm9taXNlLFxuICAgIGtleTogc3RyaW5nLFxuICAgIGVycm9yOiB1bmtub3duLFxuICAgIGRhdGE/OiB1bmtub3duXG4gICk6IHVua25vd24ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvclxuICAgICkge1xuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGFib3J0IVxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkL3JlamVjdGVkIHdpdGggdW5kZWZpbmVkLCB3ZSdsbCB0aHJvdyBhbiBlcnJvciBhcyB5b3VcbiAgICAvLyBzaG91bGQgYWx3YXlzIHJlc29sdmUgd2l0aCBhIHZhbHVlIG9yIG51bGxcbiAgICBpZiAoZXJyb3IgPT09IHVuZGVmaW5lZCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB1bmRlZmluZWRFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYERlZmVycmVkIGRhdGEgZm9yIGtleSBcIiR7a2V5fVwiIHJlc29sdmVkL3JlamVjdGVkIHdpdGggXFxgdW5kZWZpbmVkXFxgLCBgICtcbiAgICAgICAgICBgeW91IG11c3QgcmVzb2x2ZS9yZWplY3Qgd2l0aCBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYFxuICAgICAgKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gdW5kZWZpbmVkRXJyb3IgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodW5kZWZpbmVkRXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiBkYXRhIH0pO1xuICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKGFib3J0ZWQsIHNldHRsZWRLZXkpKTtcbiAgfVxuXG4gIHN1YnNjcmliZShmbjogKGFib3J0ZWQ6IGJvb2xlYW4sIHNldHRsZWRLZXk/OiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmZvckVhY2goKHYsIGspID0+IHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGspKTtcbiAgICB0aGlzLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBhc3luYyByZXNvbHZlRGF0YShzaWduYWw6IEFib3J0U2lnbmFsKSB7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgbGV0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIGFib3J0ZWQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cblxuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nS2V5c1NldC5zaXplID09PSAwO1xuICB9XG5cbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSxcbiAgICAgIFwiQ2FuIG9ubHkgdW53cmFwIGRhdGEgb24gaW5pdGlhbGl6ZWQgYW5kIHNldHRsZWQgZGVmZXJyZWRzXCJcbiAgICApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgZ2V0IHBlbmRpbmdLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ0tleXNTZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIFRyYWNrZWRQcm9taXNlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgKHZhbHVlIGFzIFRyYWNrZWRQcm9taXNlKS5fdHJhY2tlZCA9PT0gdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZTogYW55KSB7XG4gIGlmICghaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cblxuZXhwb3J0IHR5cGUgRGVmZXJGdW5jdGlvbiA9IChcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gRGVmZXJyZWREYXRhO1xuXG5leHBvcnQgY29uc3QgZGVmZXI6IERlZmVyRnVuY3Rpb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuXG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuXG5leHBvcnQgdHlwZSBSZWRpcmVjdEZ1bmN0aW9uID0gKFxuICB1cmw6IHN0cmluZyxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZGlyZWN0OiBSZWRpcmVjdEZ1bmN0aW9uID0gKHVybCwgaW5pdCA9IDMwMikgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7IHN0YXR1czogcmVzcG9uc2VJbml0IH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UgdGhhdCB3aWxsIGZvcmNlIGEgZG9jdW1lbnQgcmVsb2FkIHRvIHRoZSBuZXcgbG9jYXRpb24uXG4gKiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZGlyZWN0RG9jdW1lbnQ6IFJlZGlyZWN0RnVuY3Rpb24gPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvclJlc3BvbnNlSW1wbCB7XG4gIHN0YXR1czogbnVtYmVyO1xuICBzdGF0dXNUZXh0OiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbiAgcHJpdmF0ZSBlcnJvcj86IEVycm9yO1xuICBwcml2YXRlIGludGVybmFsOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0YXR1czogbnVtYmVyLFxuICAgIHN0YXR1c1RleHQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBkYXRhOiBhbnksXG4gICAgaW50ZXJuYWwgPSBmYWxzZVxuICApIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxufVxuXG4vLyBXZSBkb24ndCB3YW50IHRoZSBjbGFzcyBleHBvcnRlZCBzaW5jZSB1c2FnZSBvZiBpdCBhdCBydW50aW1lIGlzIGFuXG4vLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGJ1dCB3ZSBkbyB3YW50IHRvIGV4cG9ydCB0aGUgc2hhcGUgc28gZm9sa3MgY2FuXG4vLyBidWlsZCB0aGVpciBvd24gYWJzdHJhY3Rpb25zIGFyb3VuZCBpbnN0YW5jZXMgdmlhIGlzUm91dGVFcnJvclJlc3BvbnNlKClcbmV4cG9ydCB0eXBlIEVycm9yUmVzcG9uc2UgPSBJbnN0YW5jZVR5cGU8dHlwZW9mIEVycm9yUmVzcG9uc2VJbXBsPjtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gRXJyb3JSZXNwb25zZSBnZW5lcmF0ZWQgZnJvbSBhIDR4eC81eHhcbiAqIFJlc3BvbnNlIHRocm93biBmcm9tIGFuIGFjdGlvbi9sb2FkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yOiBhbnkpOiBlcnJvciBpcyBFcnJvclJlc3BvbnNlIHtcbiAgcmV0dXJuIChcbiAgICBlcnJvciAhPSBudWxsICYmXG4gICAgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJlxuICAgIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmXG4gICAgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJlxuICAgIFwiZGF0YVwiIGluIGVycm9yXG4gICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IEhpc3RvcnksIExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7XG4gIEFjdGlvbiBhcyBIaXN0b3J5QWN0aW9uLFxuICBjcmVhdGVMb2NhdGlvbixcbiAgY3JlYXRlUGF0aCxcbiAgaW52YXJpYW50LFxuICBwYXJzZVBhdGgsXG4gIHdhcm5pbmcsXG59IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB0eXBlIHtcbiAgQWN0aW9uRnVuY3Rpb24sXG4gIEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0LFxuICBBZ25vc3RpY1JvdXRlT2JqZWN0LFxuICBEYXRhUmVzdWx0LFxuICBEZWZlcnJlZERhdGEsXG4gIERlZmVycmVkUmVzdWx0LFxuICBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb24sXG4gIEVycm9yUmVzdWx0LFxuICBGb3JtRW5jVHlwZSxcbiAgRm9ybU1ldGhvZCxcbiAgSFRNTEZvcm1NZXRob2QsXG4gIEltbXV0YWJsZVJvdXRlS2V5LFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24sXG4gIE11dGF0aW9uRm9ybU1ldGhvZCxcbiAgUmVkaXJlY3RSZXN1bHQsXG4gIFJvdXRlRGF0YSxcbiAgUm91dGVNYW5pZmVzdCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyxcbiAgU3VibWlzc2lvbixcbiAgU3VjY2Vzc1Jlc3VsdCxcbiAgVUlNYXRjaCxcbiAgVjdfRm9ybU1ldGhvZCxcbiAgVjdfTXV0YXRpb25Gb3JtTWV0aG9kLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHtcbiAgRXJyb3JSZXNwb25zZUltcGwsXG4gIFJlc3VsdFR5cGUsXG4gIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoLFxuICBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzLFxuICBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyxcbiAgaW1tdXRhYmxlUm91dGVLZXlzLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgam9pblBhdGhzLFxuICBtYXRjaFJvdXRlcyxcbiAgcmVzb2x2ZVRvLFxuICBzdHJpcEJhc2VuYW1lLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFR5cGVzIGFuZCBDb25zdGFudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBSb3V0ZXIgaW5zdGFuY2UgbWFuYWdlcyBhbGwgbmF2aWdhdGlvbiBhbmQgZGF0YSBsb2FkaW5nL211dGF0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlciB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSBiYXNlbmFtZSBmb3IgdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IGJhc2VuYW1lKCk6IFJvdXRlckluaXRbXCJiYXNlbmFtZVwiXTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcm91dGVyXG4gICAqL1xuICBnZXQgc3RhdGUoKTogUm91dGVyU3RhdGU7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIHJvdXRlcyBmb3IgdGhpcyByb3V0ZXIgaW5zdGFuY2VcbiAgICovXG4gIGdldCByb3V0ZXMoKTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEluaXRpYWxpemUgdGhlIHJvdXRlciwgaW5jbHVkaW5nIGFkZGluZyBoaXN0b3J5IGxpc3RlbmVycyBhbmQga2lja2luZyBvZmZcbiAgICogaW5pdGlhbCBkYXRhIGZldGNoZXMuICBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gY2xlYW51cCBsaXN0ZW5lcnMgYW5kIGFib3J0XG4gICAqIGFueSBpbi1wcm9ncmVzcyBsb2Fkc1xuICAgKi9cbiAgaW5pdGlhbGl6ZSgpOiBSb3V0ZXI7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBTdWJzY3JpYmUgdG8gcm91dGVyLnN0YXRlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIGZuIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCB0aGUgbmV3IHN0YXRlXG4gICAqL1xuICBzdWJzY3JpYmUoZm46IFJvdXRlclN1YnNjcmliZXIpOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRW5hYmxlIHNjcm9sbCByZXN0b3JhdGlvbiBiZWhhdmlvciBpbiB0aGUgcm91dGVyXG4gICAqXG4gICAqIEBwYXJhbSBzYXZlZFNjcm9sbFBvc2l0aW9ucyBPYmplY3QgdGhhdCB3aWxsIG1hbmFnZSBwb3NpdGlvbnMsIGluIGNhc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0J3MgYmVpbmcgcmVzdG9yZWQgZnJvbSBzZXNzaW9uU3RvcmFnZVxuICAgKiBAcGFyYW0gZ2V0U2Nyb2xsUG9zaXRpb24gICAgRnVuY3Rpb24gdG8gZ2V0IHRoZSBhY3RpdmUgWSBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIGdldEtleSAgICAgICAgICAgICAgIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IHRvIHVzZSBmb3IgcmVzdG9yYXRpb25cbiAgICovXG4gIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgIGdldFNjcm9sbFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uLFxuICAgIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb25cbiAgKTogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIE5hdmlnYXRlIGZvcndhcmQvYmFja3dhcmQgaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogQHBhcmFtIHRvIERlbHRhIHRvIG1vdmUgaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIG5hdmlnYXRlKHRvOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgZ2l2ZW4gcGF0aFxuICAgKiBAcGFyYW0gdG8gUGF0aCB0byBuYXZpZ2F0ZSB0b1xuICAgKiBAcGFyYW0gb3B0cyBOYXZpZ2F0aW9uIG9wdGlvbnMgKG1ldGhvZCwgc3VibWlzc2lvbiwgZXRjLilcbiAgICovXG4gIG5hdmlnYXRlKHRvOiBUbyB8IG51bGwsIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgICAgIEZldGNoZXIga2V5XG4gICAqIEBwYXJhbSByb3V0ZUlkIFJvdXRlIHRoYXQgb3ducyB0aGUgZmV0Y2hlclxuICAgKiBAcGFyYW0gaHJlZiAgICBocmVmIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRzICAgIEZldGNoZXIgb3B0aW9ucywgKG1ldGhvZCwgc3VibWlzc2lvbiwgZXRjLilcbiAgICovXG4gIGZldGNoKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBocmVmOiBzdHJpbmcgfCBudWxsLFxuICAgIG9wdHM/OiBSb3V0ZXJGZXRjaE9wdGlvbnNcbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFRyaWdnZXIgYSByZXZhbGlkYXRpb24gb2YgYWxsIGN1cnJlbnQgcm91dGUgbG9hZGVycyBhbmQgZmV0Y2hlciBsb2Fkc1xuICAgKi9cbiAgcmV2YWxpZGF0ZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaHJlZiBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uXG4gICAqIEBwYXJhbSBsb2NhdGlvblxuICAgKi9cbiAgY3JlYXRlSHJlZihsb2NhdGlvbjogTG9jYXRpb24gfCBVUkwpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIFVSTCBlbmNvZGUgYSBkZXN0aW5hdGlvbiBwYXRoIGFjY29yZGluZyB0byB0aGUgaW50ZXJuYWxcbiAgICogaGlzdG9yeSBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0gdG9cbiAgICovXG4gIGVuY29kZUxvY2F0aW9uKHRvOiBUbyk6IFBhdGg7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBHZXQvY3JlYXRlIGEgZmV0Y2hlciBmb3IgdGhlIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBnZXRGZXRjaGVyPFREYXRhID0gYW55PihrZXk/OiBzdHJpbmcpOiBGZXRjaGVyPFREYXRhPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIERlbGV0ZSB0aGUgZmV0Y2hlciBmb3IgYSBnaXZlbiBrZXlcbiAgICogQHBhcmFtIGtleVxuICAgKi9cbiAgZGVsZXRlRmV0Y2hlcihrZXk/OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogQ2xlYW51cCBsaXN0ZW5lcnMgYW5kIGFib3J0IGFueSBpbi1wcm9ncmVzcyBsb2Fkc1xuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogR2V0IGEgbmF2aWdhdGlvbiBibG9ja2VyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2VyXG4gICAqIEBwYXJhbSBmbiBUaGUgYmxvY2tlciBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZ2V0QmxvY2tlcihrZXk6IHN0cmluZywgZm46IEJsb2NrZXJGdW5jdGlvbik6IEJsb2NrZXI7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBEZWxldGUgYSBuYXZpZ2F0aW9uIGJsb2NrZXJcbiAgICogQHBhcmFtIGtleSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrZXJcbiAgICovXG4gIGRlbGV0ZUJsb2NrZXIoa2V5OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSE1SIG5lZWRzIHRvIHBhc3MgaW4tZmxpZ2h0IHJvdXRlIHVwZGF0ZXMgdG8gUmVhY3QgUm91dGVyXG4gICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGdyYW51bGFyIHJvdXRlIHVwZGF0ZSBBUElzIChhZGRSb3V0ZSwgdXBkYXRlUm91dGUsIGRlbGV0ZVJvdXRlKVxuICAgKi9cbiAgX2ludGVybmFsU2V0Um91dGVzKHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIGZldGNoIEFib3J0Q29udHJvbGxlcnMgYWNjZXNzZWQgYnkgdW5pdCB0ZXN0c1xuICAgKi9cbiAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIHBlbmRpbmcgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBhY2Nlc3NlZCBieSB1bml0IHRlc3RzXG4gICAqL1xuICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT47XG59XG5cbi8qKlxuICogU3RhdGUgbWFpbnRhaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSByb3V0ZXIuICBEdXJpbmcgYSBuYXZpZ2F0aW9uLCBhbGwgc3RhdGVzXG4gKiByZWZsZWN0IHRoZSB0aGUgXCJvbGRcIiBsb2NhdGlvbiB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gb2YgdGhlIG1vc3QgcmVjZW50IG5hdmlnYXRpb25cbiAgICovXG4gIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGxvY2F0aW9uIHJlZmxlY3RlZCBieSB0aGUgcm91dGVyXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNldCBvZiByb3V0ZSBtYXRjaGVzXG4gICAqL1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIHdlJ3ZlIGNvbXBsZXRlZCBvdXIgaW5pdGlhbCBkYXRhIGxvYWRcbiAgICovXG4gIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB3ZSBzaG91bGQgc3RhcnQgYXQgZm9yIGEgbmV3IHZpZXdcbiAgICogIC0gbnVtYmVyIC0+IHNjcm9sbCBwb3NpdGlvbiB0byByZXN0b3JlIHRvXG4gICAqICAtIGZhbHNlIC0+IGRvIG5vdCByZXN0b3JlIHNjcm9sbCBhdCBhbGwgKHVzZWQgZHVyaW5nIHN1Ym1pc3Npb25zKVxuICAgKiAgLSBudWxsIC0+IGRvbid0IGhhdmUgYSBzYXZlZCBwb3NpdGlvbiwgc2Nyb2xsIHRvIGhhc2ggb3IgdG9wIG9mIHBhZ2VcbiAgICovXG4gIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVtYmVyIHwgZmFsc2UgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgbmF2aWdhdGlvbiBzaG91bGQgc2tpcCByZXNldHRpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKiBpZiB3ZSBhcmUgdW5hYmxlIHRvIHJlc3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKi9cbiAgcHJldmVudFNjcm9sbFJlc2V0OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IG5hdmlnYXRpb25cbiAgICovXG4gIG5hdmlnYXRpb246IE5hdmlnYXRpb247XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBhbnkgaW4tcHJvZ3Jlc3MgcmV2YWxpZGF0aW9uc1xuICAgKi9cbiAgcmV2YWxpZGF0aW9uOiBSZXZhbGlkYXRpb25TdGF0ZTtcblxuICAvKipcbiAgICogRGF0YSBmcm9tIHRoZSBsb2FkZXJzIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBsb2FkZXJEYXRhOiBSb3V0ZURhdGE7XG5cbiAgLyoqXG4gICAqIERhdGEgZnJvbSB0aGUgYWN0aW9uIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBhY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBFcnJvcnMgY2F1Z2h0IGZyb20gbG9hZGVycyBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgZXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBmZXRjaGVyc1xuICAgKi9cbiAgZmV0Y2hlcnM6IE1hcDxzdHJpbmcsIEZldGNoZXI+O1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBibG9ja2Vyc1xuICAgKi9cbiAgYmxvY2tlcnM6IE1hcDxzdHJpbmcsIEJsb2NrZXI+O1xufVxuXG4vKipcbiAqIERhdGEgdGhhdCBjYW4gYmUgcGFzc2VkIGludG8gaHlkcmF0ZSBhIFJvdXRlciBmcm9tIFNTUlxuICovXG5leHBvcnQgdHlwZSBIeWRyYXRpb25TdGF0ZSA9IFBhcnRpYWw8XG4gIFBpY2s8Um91dGVyU3RhdGUsIFwibG9hZGVyRGF0YVwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImVycm9yc1wiPlxuPjtcblxuLyoqXG4gKiBGdXR1cmUgZmxhZ3MgdG8gdG9nZ2xlIG5ldyBmZWF0dXJlIGJlaGF2aW9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnV0dXJlQ29uZmlnIHtcbiAgdjdfbm9ybWFsaXplRm9ybU1ldGhvZDogYm9vbGVhbjtcbiAgdjdfcHJlcGVuZEJhc2VuYW1lOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemF0aW9uIG9wdGlvbnMgZm9yIGNyZWF0ZVJvdXRlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckluaXQge1xuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXTtcbiAgaGlzdG9yeTogSGlzdG9yeTtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG1hcFJvdXRlUHJvcGVydGllc2AgaW5zdGVhZFxuICAgKi9cbiAgZGV0ZWN0RXJyb3JCb3VuZGFyeT86IERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbjtcbiAgbWFwUm91dGVQcm9wZXJ0aWVzPzogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb247XG4gIGZ1dHVyZT86IFBhcnRpYWw8RnV0dXJlQ29uZmlnPjtcbiAgaHlkcmF0aW9uRGF0YT86IEh5ZHJhdGlvblN0YXRlO1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogU3RhdGUgcmV0dXJuZWQgZnJvbSBhIHNlcnZlci1zaWRlIHF1ZXJ5KCkgY2FsbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0hhbmRsZXJDb250ZXh0IHtcbiAgYmFzZW5hbWU6IFJvdXRlcltcImJhc2VuYW1lXCJdO1xuICBsb2NhdGlvbjogUm91dGVyU3RhdGVbXCJsb2NhdGlvblwiXTtcbiAgbWF0Y2hlczogUm91dGVyU3RhdGVbXCJtYXRjaGVzXCJdO1xuICBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIGFjdGlvbkRhdGE6IFJvdXRlclN0YXRlW1wiYWN0aW9uRGF0YVwiXTtcbiAgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aW9uSGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz47XG4gIGFjdGl2ZURlZmVycmVkczogUmVjb3JkPHN0cmluZywgRGVmZXJyZWREYXRhPiB8IG51bGw7XG4gIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBBIFN0YXRpY0hhbmRsZXIgaW5zdGFuY2UgbWFuYWdlcyBhIHNpbmd1bGFyIFNTUiBuYXZpZ2F0aW9uL2ZldGNoIGV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlciB7XG4gIGRhdGFSb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W107XG4gIHF1ZXJ5KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgb3B0cz86IHsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH1cbiAgKTogUHJvbWlzZTxTdGF0aWNIYW5kbGVyQ29udGV4dCB8IFJlc3BvbnNlPjtcbiAgcXVlcnlSb3V0ZShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIG9wdHM/OiB7IHJvdXRlSWQ/OiBzdHJpbmc7IHJlcXVlc3RDb250ZXh0PzogdW5rbm93biB9XG4gICk6IFByb21pc2U8YW55Pjtcbn1cblxuLyoqXG4gKiBTdWJzY3JpYmVyIGZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgY2hhbmdlcyB0byByb3V0ZXIgc3RhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJTdWJzY3JpYmVyIHtcbiAgKHN0YXRlOiBSb3V0ZXJTdGF0ZSk6IHZvaWQ7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc2lnbmF0dXJlIGZvciBkZXRlcm1pbmluZyB0aGUga2V5IHRvIGJlIHVzZWQgaW4gc2Nyb2xsIHJlc3RvcmF0aW9uXG4gKiBmb3IgYSBnaXZlbiBsb2NhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24ge1xuICAobG9jYXRpb246IExvY2F0aW9uLCBtYXRjaGVzOiBVSU1hdGNoW10pOiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgZGV0ZXJtaW5pbmcgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbiB7XG4gICgpOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFJlbGF0aXZlUm91dGluZ1R5cGUgPSBcInJvdXRlXCIgfCBcInBhdGhcIjtcblxuLy8gQWxsb3dlZCBmb3IgYW55IG5hdmlnYXRpb24gb3IgZmV0Y2hcbnR5cGUgQmFzZU5hdmlnYXRlT3JGZXRjaE9wdGlvbnMgPSB7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbn07XG5cbi8vIE9ubHkgYWxsb3dlZCBmb3IgbmF2aWdhdGlvbnNcbnR5cGUgQmFzZU5hdmlnYXRlT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zICYge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIGZyb21Sb3V0ZUlkPzogc3RyaW5nO1xufTtcblxuLy8gT25seSBhbGxvd2VkIGZvciBzdWJtaXNzaW9uIG5hdmlnYXRpb25zXG50eXBlIEJhc2VTdWJtaXNzaW9uT3B0aW9ucyA9IHtcbiAgZm9ybU1ldGhvZD86IEhUTUxGb3JtTWV0aG9kO1xuICBmb3JtRW5jVHlwZT86IEZvcm1FbmNUeXBlO1xufSAmIChcbiAgfCB7IGZvcm1EYXRhOiBGb3JtRGF0YTsgYm9keT86IHVuZGVmaW5lZCB9XG4gIHwgeyBmb3JtRGF0YT86IHVuZGVmaW5lZDsgYm9keTogYW55IH1cbik7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBuYXZpZ2F0ZSgpIGNhbGwgZm9yIGEgbm9ybWFsIChub24tc3VibWlzc2lvbikgbmF2aWdhdGlvblxuICovXG50eXBlIExpbmtOYXZpZ2F0ZU9wdGlvbnMgPSBCYXNlTmF2aWdhdGVPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgbmF2aWdhdGUoKSBjYWxsIGZvciBhIHN1Ym1pc3Npb24gbmF2aWdhdGlvblxuICovXG50eXBlIFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMgPSBCYXNlTmF2aWdhdGVPcHRpb25zICYgQmFzZVN1Ym1pc3Npb25PcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBuYXZpZ2F0ZSgpIGZvciBhIG5hdmlnYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyTmF2aWdhdGVPcHRpb25zID1cbiAgfCBMaW5rTmF2aWdhdGVPcHRpb25zXG4gIHwgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIGZldGNoKCkgbG9hZFxuICovXG50eXBlIExvYWRGZXRjaE9wdGlvbnMgPSBCYXNlTmF2aWdhdGVPckZldGNoT3B0aW9ucztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIGZldGNoKCkgc3VibWlzc2lvblxuICovXG50eXBlIFN1Ym1pdEZldGNoT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zICYgQmFzZVN1Ym1pc3Npb25PcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBmZXRjaCgpXG4gKi9cbmV4cG9ydCB0eXBlIFJvdXRlckZldGNoT3B0aW9ucyA9IExvYWRGZXRjaE9wdGlvbnMgfCBTdWJtaXRGZXRjaE9wdGlvbnM7XG5cbi8qKlxuICogUG90ZW50aWFsIHN0YXRlcyBmb3Igc3RhdGUubmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uU3RhdGVzID0ge1xuICBJZGxlOiB7XG4gICAgc3RhdGU6IFwiaWRsZVwiO1xuICAgIGxvY2F0aW9uOiB1bmRlZmluZWQ7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAganNvbjogdW5kZWZpbmVkO1xuICAgIHRleHQ6IHVuZGVmaW5lZDtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBsb2NhdGlvbjogTG9jYXRpb247XG4gICAgZm9ybU1ldGhvZDogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl0gfCB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogU3VibWlzc2lvbltcImZvcm1BY3Rpb25cIl0gfCB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogU3VibWlzc2lvbltcImZvcm1EYXRhXCJdIHwgdW5kZWZpbmVkO1xuICAgIGpzb246IFN1Ym1pc3Npb25bXCJqc29uXCJdIHwgdW5kZWZpbmVkO1xuICAgIHRleHQ6IFN1Ym1pc3Npb25bXCJ0ZXh0XCJdIHwgdW5kZWZpbmVkO1xuICB9O1xuICBTdWJtaXR0aW5nOiB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiO1xuICAgIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXTtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl07XG4gICAgdGV4dDogU3VibWlzc2lvbltcInRleHRcIl07XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uID0gTmF2aWdhdGlvblN0YXRlc1trZXlvZiBOYXZpZ2F0aW9uU3RhdGVzXTtcblxuZXhwb3J0IHR5cGUgUmV2YWxpZGF0aW9uU3RhdGUgPSBcImlkbGVcIiB8IFwibG9hZGluZ1wiO1xuXG4vKipcbiAqIFBvdGVudGlhbCBzdGF0ZXMgZm9yIGZldGNoZXJzXG4gKi9cbnR5cGUgRmV0Y2hlclN0YXRlczxURGF0YSA9IGFueT4gPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkO1xuICAgIHRleHQ6IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkO1xuICAgIGpzb246IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdIHwgdW5kZWZpbmVkO1xuICAgIHRleHQ6IFN1Ym1pc3Npb25bXCJ0ZXh0XCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl0gfCB1bmRlZmluZWQ7XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl0gfCB1bmRlZmluZWQ7XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgZm9ybU1ldGhvZDogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl07XG4gICAgZm9ybUFjdGlvbjogU3VibWlzc2lvbltcImZvcm1BY3Rpb25cIl07XG4gICAgZm9ybUVuY1R5cGU6IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXTtcbiAgICB0ZXh0OiBTdWJtaXNzaW9uW1widGV4dFwiXTtcbiAgICBmb3JtRGF0YTogU3VibWlzc2lvbltcImZvcm1EYXRhXCJdO1xuICAgIGpzb246IFN1Ym1pc3Npb25bXCJqc29uXCJdO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlcjxURGF0YSA9IGFueT4gPVxuICBGZXRjaGVyU3RhdGVzPFREYXRhPltrZXlvZiBGZXRjaGVyU3RhdGVzPFREYXRhPl07XG5cbmludGVyZmFjZSBCbG9ja2VyQmxvY2tlZCB7XG4gIHN0YXRlOiBcImJsb2NrZWRcIjtcbiAgcmVzZXQoKTogdm9pZDtcbiAgcHJvY2VlZCgpOiB2b2lkO1xuICBsb2NhdGlvbjogTG9jYXRpb247XG59XG5cbmludGVyZmFjZSBCbG9ja2VyVW5ibG9ja2VkIHtcbiAgc3RhdGU6IFwidW5ibG9ja2VkXCI7XG4gIHJlc2V0OiB1bmRlZmluZWQ7XG4gIHByb2NlZWQ6IHVuZGVmaW5lZDtcbiAgbG9jYXRpb246IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEJsb2NrZXJQcm9jZWVkaW5nIHtcbiAgc3RhdGU6IFwicHJvY2VlZGluZ1wiO1xuICByZXNldDogdW5kZWZpbmVkO1xuICBwcm9jZWVkOiB1bmRlZmluZWQ7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgQmxvY2tlciA9IEJsb2NrZXJVbmJsb2NrZWQgfCBCbG9ja2VyQmxvY2tlZCB8IEJsb2NrZXJQcm9jZWVkaW5nO1xuXG5leHBvcnQgdHlwZSBCbG9ja2VyRnVuY3Rpb24gPSAoYXJnczoge1xuICBjdXJyZW50TG9jYXRpb246IExvY2F0aW9uO1xuICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xufSkgPT4gYm9vbGVhbjtcblxuaW50ZXJmYWNlIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogc3RhcnROYXZpZ2F0aW9uIGRvZXMgbm90IG5lZWQgdG8gY29tcGxldGUgdGhlIG5hdmlnYXRpb24gYmVjYXVzZSB3ZVxuICAgKiByZWRpcmVjdGVkIG9yIGdvdCBpbnRlcnJ1cHRlZFxuICAgKi9cbiAgc2hvcnRDaXJjdWl0ZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSGFuZGxlQWN0aW9uUmVzdWx0IGV4dGVuZHMgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBFcnJvciB0aHJvd24gZnJvbSB0aGUgY3VycmVudCBhY3Rpb24sIGtleWVkIGJ5IHRoZSByb3V0ZSBjb250YWluaW5nIHRoZVxuICAgKiBlcnJvciBib3VuZGFyeSB0byByZW5kZXIgdGhlIGVycm9yLiAgVG8gYmUgY29tbWl0dGVkIHRvIHRoZSBzdGF0ZSBhZnRlclxuICAgKiBsb2FkZXJzIGhhdmUgY29tcGxldGVkXG4gICAqL1xuICBwZW5kaW5nQWN0aW9uRXJyb3I/OiBSb3V0ZURhdGE7XG4gIC8qKlxuICAgKiBEYXRhIHJldHVybmVkIGZyb20gdGhlIGN1cnJlbnQgYWN0aW9uLCBrZXllZCBieSB0aGUgcm91dGUgb3duaW5nIHRoZSBhY3Rpb24uXG4gICAqIFRvIGJlIGNvbW1pdHRlZCB0byB0aGUgc3RhdGUgYWZ0ZXIgbG9hZGVycyBoYXZlIGNvbXBsZXRlZFxuICAgKi9cbiAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGE7XG59XG5cbmludGVyZmFjZSBIYW5kbGVMb2FkZXJzUmVzdWx0IGV4dGVuZHMgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBsb2FkZXJEYXRhIHJldHVybmVkIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGxvYWRlcnNcbiAgICovXG4gIGxvYWRlckRhdGE/OiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIC8qKlxuICAgKiBlcnJvcnMgdGhyb3duIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGxvYWRlcnNcbiAgICovXG4gIGVycm9ycz86IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xufVxuXG4vKipcbiAqIENhY2hlZCBpbmZvIGZvciBhY3RpdmUgZmV0Y2hlci5sb2FkKCkgaW5zdGFuY2VzIHNvIHRoZXkgY2FuIHBhcnRpY2lwYXRlXG4gKiBpbiByZXZhbGlkYXRpb25cbiAqL1xuaW50ZXJmYWNlIEZldGNoTG9hZE1hdGNoIHtcbiAgcm91dGVJZDogc3RyaW5nO1xuICBwYXRoOiBzdHJpbmc7XG59XG5cbi8qKlxuICogSWRlbnRpZmllZCBmZXRjaGVyLmxvYWQoKSBjYWxscyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAqL1xuaW50ZXJmYWNlIFJldmFsaWRhdGluZ0ZldGNoZXIgZXh0ZW5kcyBGZXRjaExvYWRNYXRjaCB7XG4gIGtleTogc3RyaW5nO1xuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCB8IG51bGw7XG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSB8IG51bGw7XG4gIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG59XG5cbi8qKlxuICogV3JhcHBlciBvYmplY3QgdG8gYWxsb3cgdXMgdG8gdGhyb3cgYW55IHJlc3BvbnNlIG91dCBmcm9tIGNhbGxMb2FkZXJPckFjdGlvblxuICogZm9yIHF1ZXJ5Um91dGVyIHdoaWxlIHByZXNlcnZpbmcgd2hldGhlciBvciBub3QgaXQgd2FzIHRocm93biBvciByZXR1cm5lZFxuICogZnJvbSB0aGUgbG9hZGVyL2FjdGlvblxuICovXG5pbnRlcmZhY2UgUXVlcnlSb3V0ZVJlc3BvbnNlIHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kYXRhIHwgUmVzdWx0VHlwZS5lcnJvcjtcbiAgcmVzcG9uc2U6IFJlc3BvbnNlO1xufVxuXG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kc0FycjogTXV0YXRpb25Gb3JtTWV0aG9kW10gPSBbXG4gIFwicG9zdFwiLFxuICBcInB1dFwiLFxuICBcInBhdGNoXCIsXG4gIFwiZGVsZXRlXCIsXG5dO1xuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0PE11dGF0aW9uRm9ybU1ldGhvZD4oXG4gIHZhbGlkTXV0YXRpb25NZXRob2RzQXJyXG4pO1xuXG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzQXJyOiBGb3JtTWV0aG9kW10gPSBbXG4gIFwiZ2V0XCIsXG4gIC4uLnZhbGlkTXV0YXRpb25NZXRob2RzQXJyLFxuXTtcbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHMgPSBuZXcgU2V0PEZvcm1NZXRob2Q+KHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIpO1xuXG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmNvbnN0IHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwNywgMzA4XSk7XG5cbmV4cG9ydCBjb25zdCBJRExFX05BVklHQVRJT046IE5hdmlnYXRpb25TdGF0ZXNbXCJJZGxlXCJdID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICBqc29uOiB1bmRlZmluZWQsXG4gIHRleHQ6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBjb25zdCBJRExFX0ZFVENIRVI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gIGpzb246IHVuZGVmaW5lZCxcbiAgdGV4dDogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGNvbnN0IElETEVfQkxPQ0tFUjogQmxvY2tlclVuYmxvY2tlZCA9IHtcbiAgc3RhdGU6IFwidW5ibG9ja2VkXCIsXG4gIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IHVuZGVmaW5lZCxcbn07XG5cbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcblxuY29uc3QgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllczogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24gPSAocm91dGUpID0+ICh7XG4gIGhhc0Vycm9yQm91bmRhcnk6IEJvb2xlYW4ocm91dGUuaGFzRXJyb3JCb3VuZGFyeSksXG59KTtcblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlUm91dGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZSBhIHJvdXRlciBhbmQgbGlzdGVuIHRvIGhpc3RvcnkgUE9QIG5hdmlnYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdDogUm91dGVySW5pdCk6IFJvdXRlciB7XG4gIGNvbnN0IHJvdXRlcldpbmRvdyA9IGluaXQud2luZG93XG4gICAgPyBpbml0LndpbmRvd1xuICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gd2luZG93XG4gICAgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzQnJvd3NlciA9XG4gICAgdHlwZW9mIHJvdXRlcldpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IGlzU2VydmVyID0gIWlzQnJvd3NlcjtcblxuICBpbnZhcmlhbnQoXG4gICAgaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiXG4gICk7XG5cbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb247XG4gIGlmIChpbml0Lm1hcFJvdXRlUHJvcGVydGllcykge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGluaXQubWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9IGVsc2UgaWYgKGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IChyb3V0ZSkgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cblxuICAvLyBSb3V0ZXMga2V5ZWQgYnkgSURcbiAgbGV0IG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0ID0ge307XG4gIC8vIFJvdXRlcyBpbiB0cmVlIGZvcm1hdCBmb3IgbWF0Y2hpbmdcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIGluaXQucm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICB1bmRlZmluZWQsXG4gICAgbWFuaWZlc3RcbiAgKTtcbiAgbGV0IGluRmxpZ2h0RGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSB8IHVuZGVmaW5lZDtcbiAgbGV0IGJhc2VuYW1lID0gaW5pdC5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlOiBGdXR1cmVDb25maWcgPSB7XG4gICAgdjdfbm9ybWFsaXplRm9ybU1ldGhvZDogZmFsc2UsXG4gICAgdjdfcHJlcGVuZEJhc2VuYW1lOiBmYWxzZSxcbiAgICAuLi5pbml0LmZ1dHVyZSxcbiAgfTtcbiAgLy8gQ2xlYW51cCBmdW5jdGlvbiBmb3IgaGlzdG9yeVxuICBsZXQgdW5saXN0ZW5IaXN0b3J5OiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbnMgdG8gY2FsbCBvbiBhbGwgc3RhdGUgY2hhbmdlc1xuICBsZXQgc3Vic2NyaWJlcnMgPSBuZXcgU2V0PFJvdXRlclN1YnNjcmliZXI+KCk7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgb2JqZWN0IHRvIGhvbGQgc2Nyb2xsIHJlc3RvcmF0aW9uIGxvY2F0aW9ucyBkdXJpbmcgcm91dGluZ1xuICBsZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgc2Nyb2xsIHJlc3RvcmF0aW9uIGtleXNcbiAgbGV0IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuICAvLyBPbmUtdGltZSBmbGFnIHRvIGNvbnRyb2wgdGhlIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbi4gIEJlY2F1c2VcbiAgLy8gd2UgZG9uJ3QgZ2V0IHRoZSBzYXZlZCBwb3NpdGlvbnMgZnJvbSA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gdW50aWwgX2FmdGVyX1xuICAvLyB0aGUgaW5pdGlhbCByZW5kZXIsIHdlIG5lZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBhIHNlcGFyYXRlIHVwZGF0ZVN0YXRlIHRvXG4gIC8vIHNlbmQgYWxvbmcgdGhlIHJlc3RvcmVTY3JvbGxQb3NpdGlvblxuICAvLyBTZXQgdG8gdHJ1ZSBpZiB3ZSBoYXZlIGBoeWRyYXRpb25EYXRhYCBzaW5jZSB3ZSBhc3N1bWUgd2Ugd2VyZSBTU1InZCBhbmQgdGhhdFxuICAvLyBTU1IgZGlkIHRoZSBpbml0aWFsIHNjcm9sbCByZXN0b3JhdGlvbi5cbiAgbGV0IGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuXG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xuICBsZXQgaW5pdGlhbEVycm9yczogUm91dGVEYXRhIHwgbnVsbCA9IG51bGw7XG5cbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBhbGxvdyB0aGUgZXJyb3IgYm91bmRhcnkgdG8gdGFrZSBvdmVyXG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgfSk7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7IFtyb3V0ZS5pZF06IGVycm9yIH07XG4gIH1cblxuICBsZXQgaW5pdGlhbGl6ZWQgPVxuICAgIC8vIEFsbCBpbml0aWFsTWF0Y2hlcyBuZWVkIHRvIGJlIGxvYWRlZCBiZWZvcmUgd2UncmUgcmVhZHkuICBJZiB3ZSBoYXZlIGxhenlcbiAgICAvLyBmdW5jdGlvbnMgYXJvdW5kIHN0aWxsIHRoZW4gd2UnbGwgbmVlZCB0byBydW4gdGhlbSBpbiBpbml0aWFsaXplKClcbiAgICAhaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sYXp5KSAmJlxuICAgIC8vIEFuZCB3ZSBoYXZlIHRvIGVpdGhlciBoYXZlIG5vIGxvYWRlcnMgb3IgaGF2ZSBiZWVuIHByb3ZpZGVkIGh5ZHJhdGlvbkRhdGFcbiAgICAoIWluaXRpYWxNYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUubG9hZGVyKSB8fCBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCk7XG5cbiAgbGV0IHJvdXRlcjogUm91dGVyO1xuICBsZXQgc3RhdGU6IFJvdXRlclN0YXRlID0ge1xuICAgIGhpc3RvcnlBY3Rpb246IGluaXQuaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBtYXRjaGVzOiBpbml0aWFsTWF0Y2hlcyxcbiAgICBpbml0aWFsaXplZCxcbiAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgLy8gRG9uJ3QgcmVzdG9yZSBvbiBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgaWYgd2Ugd2VyZSBTU1InZFxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwgPyBmYWxzZSA6IG51bGwsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgIGxvYWRlckRhdGE6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEpIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmFjdGlvbkRhdGEpIHx8IG51bGwsXG4gICAgZXJyb3JzOiAoaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMpIHx8IGluaXRpYWxFcnJvcnMsXG4gICAgZmV0Y2hlcnM6IG5ldyBNYXAoKSxcbiAgICBibG9ja2VyczogbmV3IE1hcCgpLFxuICB9O1xuXG4gIC8vIC0tIFN0YXRlZnVsIGludGVybmFsIHZhcmlhYmxlcyB0byBtYW5hZ2UgbmF2aWdhdGlvbnMgLS1cbiAgLy8gQ3VycmVudCBuYXZpZ2F0aW9uIGluIHByb2dyZXNzICh0byBiZSBjb21taXR0ZWQgaW4gY29tcGxldGVOYXZpZ2F0aW9uKVxuICBsZXQgcGVuZGluZ0FjdGlvbjogSGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUG9wO1xuXG4gIC8vIFNob3VsZCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHByZXZlbnQgdGhlIHNjcm9sbCByZXNldCBpZiBzY3JvbGwgY2Fubm90XG4gIC8vIGJlIHJlc3RvcmVkP1xuICBsZXQgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuXG4gIC8vIEFib3J0Q29udHJvbGxlciBmb3IgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG5cbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxuICAvLyByZXZhbGlkYXRpb24gaXMgZW50aXJlbHkgdW5pbnRlcnJ1cHRlZFxuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgZmxhZyB0byBmb3JjZSByZXZhbGlkYXRpb24gb2YgYWxsIGxvYWRlcnM6XG4gIC8vICAtIHN1Ym1pc3Npb25zIChjb21wbGV0ZWQgb3IgaW50ZXJydXB0ZWQpXG4gIC8vICAtIHVzZVJldmFsaWRhdG9yKClcbiAgLy8gIC0gWC1SZW1peC1SZXZhbGlkYXRlIChmcm9tIHJlZGlyZWN0KVxuICBsZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuXG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgcm91dGVzIHRoYXQgcmVxdWlyZSByZXZhbGlkYXRpb24gZHVlXG4gIC8vIHRvIGEgY2FuY2VsbGVkIGRlZmVycmVkIG9uIGFjdGlvbiBzdWJtaXNzaW9uXG4gIGxldCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIGZldGNoZXIgbG9hZHMgdGhhdCB3ZXJlIGNhbmNlbGxlZCBieSBhblxuICAvLyBhY3Rpb24gbmF2aWdhdGlvbiBhbmQgcmVxdWlyZSByZXZhbGlkYXRpb25cbiAgbGV0IGNhbmNlbGxlZEZldGNoZXJMb2Fkczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBBYm9ydENvbnRyb2xsZXJzIGZvciBhbnkgaW4tZmxpZ2h0IGZldGNoZXJzXG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gbmV3IE1hcDxzdHJpbmcsIEFib3J0Q29udHJvbGxlcj4oKTtcblxuICAvLyBUcmFjayBsb2FkcyBiYXNlZCBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBzdGFydGVkXG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuXG4gIC8vIFRyYWNrIHRoZSBvdXRzdGFuZGluZyBwZW5kaW5nIG5hdmlnYXRpb24gZGF0YSBsb2FkIHRvIGJlIGNvbXBhcmVkIGFnYWluc3RcbiAgLy8gdGhlIGdsb2JhbGx5IGluY3JlbWVudGluZyBsb2FkIHdoZW4gYSBmZXRjaGVyIGxvYWQgbGFuZHMgYWZ0ZXIgYSBjb21wbGV0ZWRcbiAgLy8gbmF2aWdhdGlvblxuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcblxuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCBkYXRhIHJlbG9hZHMgYXMgYSByZXN1bHQgb2YgdGhlaXIgYWN0aW9uc1xuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIC8vIEZldGNoZXJzIHRoYXQgdHJpZ2dlcmVkIHJlZGlyZWN0IG5hdmlnYXRpb25zXG4gIGxldCBmZXRjaFJlZGlyZWN0SWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLy8gTW9zdCByZWNlbnQgaHJlZi9tYXRjaCBmb3IgZmV0Y2hlci5sb2FkIGNhbGxzIGZvciBmZXRjaGVyc1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IG5ldyBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD4oKTtcblxuICAvLyBTdG9yZSBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGZvciBhY3RpdmUgcm91dGUgbWF0Y2hlcy4gIFdoZW4gYVxuICAvLyByb3V0ZSBsb2FkZXIgcmV0dXJucyBkZWZlcigpIHdlIHN0aWNrIG9uZSBpbiBoZXJlLiAgVGhlbiwgd2hlbiBhIG5lc3RlZFxuICAvLyBwcm9taXNlIHJlc29sdmVzIHdlIHVwZGF0ZSBsb2FkZXJEYXRhLiAgSWYgYSBuZXcgbmF2aWdhdGlvbiBzdGFydHMgd2VcbiAgLy8gY2FuY2VsIGFjdGl2ZSBkZWZlcnJlZHMgZm9yIGVsaW1pbmF0ZWQgcm91dGVzLlxuICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT4oKTtcblxuICAvLyBTdG9yZSBibG9ja2VyIGZ1bmN0aW9ucyBpbiBhIHNlcGFyYXRlIE1hcCBvdXRzaWRlIG9mIHJvdXRlciBzdGF0ZSBzaW5jZVxuICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBVSSBzdGF0ZSBpZiB0aGV5IGNoYW5nZVxuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBCbG9ja2VyRnVuY3Rpb24+KCk7XG5cbiAgLy8gRmxhZyB0byBpZ25vcmUgdGhlIG5leHQgaGlzdG9yeSB1cGRhdGUsIHNvIHdlIGNhbiByZXZlcnQgdGhlIFVSTCBjaGFuZ2Ugb25cbiAgLy8gYSBQT1AgbmF2aWdhdGlvbiB0aGF0IHdhcyBibG9ja2VkIGJ5IHRoZSB1c2VyIHdpdGhvdXQgdG91Y2hpbmcgcm91dGVyIHN0YXRlXG4gIGxldCBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHJvdXRlciwgYWxsIHNpZGUgZWZmZWN0cyBzaG91bGQgYmUga2lja2VkIG9mZiBmcm9tIGhlcmUuXG4gIC8vIEltcGxlbWVudGVkIGFzIGEgRmx1ZW50IEFQSSBmb3IgZWFzZSBvZjpcbiAgLy8gICBsZXQgcm91dGVyID0gY3JlYXRlUm91dGVyKGluaXQpLmluaXRpYWxpemUoKTtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBJZiBoaXN0b3J5IGluZm9ybXMgdXMgb2YgYSBQT1AgbmF2aWdhdGlvbiwgc3RhcnQgdGhlIG5hdmlnYXRpb24gYnV0IGRvIG5vdCB1cGRhdGVcbiAgICAvLyBzdGF0ZS4gIFdlJ2xsIHVwZGF0ZSBvdXIgb3duIHN0YXRlIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihcbiAgICAgICh7IGFjdGlvbjogaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIGRlbHRhIH0pID0+IHtcbiAgICAgICAgLy8gSWdub3JlIHRoaXMgZXZlbnQgaWYgaXQgd2FzIGp1c3QgdXMgcmVzZXR0aW5nIHRoZSBVUkwgZnJvbSBhXG4gICAgICAgIC8vIGJsb2NrZWQgUE9QIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlKSB7XG4gICAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCB8fCBkZWx0YSAhPSBudWxsLFxuICAgICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgYmxvY2tlciBvbiBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gXCIgK1xuICAgICAgICAgICAgXCJ0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgK1xuICAgICAgICAgICAgXCJwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciBcIiArXG4gICAgICAgICAgICBcInZpYSBgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYC9gd2luZG93LmxvY2F0aW9uLmhhc2hgIGluc3RlYWQgb2YgdXNpbmcgXCIgK1xuICAgICAgICAgICAgXCJyb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBcIiArXG4gICAgICAgICAgICBcImNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIlxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaGlzdG9yeUFjdGlvbixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJsb2NrZXJLZXkgJiYgZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIFVSTCB0byBtYXRjaCB0aGUgY3VycmVudCBVSSwgYnV0IGRvbid0IHVwZGF0ZSByb3V0ZXIgc3RhdGVcbiAgICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuXG4gICAgICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSEsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBSZS1kbyB0aGUgc2FtZSBQT1AgbmF2aWdhdGlvbiB3ZSBqdXN0IGJsb2NrZWRcbiAgICAgICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5ISwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIEtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZC4gIFVzZSBQb3AgdG8gYXZvaWQgbW9kaWZ5aW5nIGhpc3RvcnlcbiAgICAvLyBOb3RlIHdlIGRvbid0IGRvIGFueSBoYW5kbGluZyBvZiBsYXp5IGhlcmUuICBGb3IgU1BBJ3MgaXQnbGwgZ2V0IGhhbmRsZWRcbiAgICAvLyBpbiB0aGUgbm9ybWFsIG5hdmlnYXRpb24gZmxvdy4gIEZvciBTU1IgaXQncyBleHBlY3RlZCB0aGF0IGxhenkgbW9kdWxlcyBhcmVcbiAgICAvLyByZXNvbHZlZCBwcmlvciB0byByb3V0ZXIgY3JlYXRpb24gc2luY2Ugd2UgY2FuJ3QgZ28gaW50byBhIGZhbGxiYWNrRWxlbWVudFxuICAgIC8vIFVJIGZvciBTU1InZCBhcHBzXG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKEhpc3RvcnlBY3Rpb24uUG9wLCBzdGF0ZS5sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGEgcm91dGVyIGFuZCBpdCdzIHNpZGUgZWZmZWN0c1xuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcbiAgICAgIHVubGlzdGVuSGlzdG9yeSgpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgc3RhdGUuYmxvY2tlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVCbG9ja2VyKGtleSkpO1xuICB9XG5cbiAgLy8gU3Vic2NyaWJlIHRvIHN0YXRlIHVwZGF0ZXMgZm9yIHRoZSByb3V0ZXJcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZuOiBSb3V0ZXJTdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBvdXIgc3RhdGUgYW5kIG5vdGlmeSB0aGUgY2FsbGluZyBjb250ZXh0IG9mIHRoZSBjaGFuZ2VcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUobmV3U3RhdGU6IFBhcnRpYWw8Um91dGVyU3RhdGU+KTogdm9pZCB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm5ld1N0YXRlLFxuICAgIH07XG4gICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihzdGF0ZSkpO1xuICB9XG5cbiAgLy8gQ29tcGxldGUgYSBuYXZpZ2F0aW9uIHJldHVybmluZyB0aGUgc3RhdGUubmF2aWdhdGlvbiBiYWNrIHRvIHRoZSBJRExFX05BVklHQVRJT05cbiAgLy8gYW5kIHNldHRpbmcgc3RhdGUuW2hpc3RvcnlBY3Rpb24vbG9jYXRpb24vbWF0Y2hlc10gdG8gdGhlIG5ldyByb3V0ZS5cbiAgLy8gLSBMb2NhdGlvbiBpcyBhIHJlcXVpcmVkIHBhcmFtXG4gIC8vIC0gTmF2aWdhdGlvbiB3aWxsIGFsd2F5cyBiZSBzZXQgdG8gSURMRV9OQVZJR0FUSU9OXG4gIC8vIC0gQ2FuIHBhc3MgYW55IG90aGVyIHN0YXRlIGluIG5ld1N0YXRlXG4gIGZ1bmN0aW9uIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbmV3U3RhdGU6IFBhcnRpYWw8T21pdDxSb3V0ZXJTdGF0ZSwgXCJhY3Rpb25cIiB8IFwibG9jYXRpb25cIiB8IFwibmF2aWdhdGlvblwiPj5cbiAgKTogdm9pZCB7XG4gICAgLy8gRGVkdWNlIGlmIHdlJ3JlIGluIGEgbG9hZGluZy9hY3Rpb25SZWxvYWQgc3RhdGU6XG4gICAgLy8gLSBXZSBoYXZlIGNvbW1pdHRlZCBhY3Rpb25EYXRhIGluIHRoZSBzdG9yZVxuICAgIC8vIC0gVGhlIGN1cnJlbnQgbmF2aWdhdGlvbiB3YXMgYSBtdXRhdGlvbiBzdWJtaXNzaW9uXG4gICAgLy8gLSBXZSdyZSBwYXN0IHRoZSBzdWJtaXR0aW5nIHN0YXRlIGFuZCBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlXG4gICAgLy8gLSBUaGUgbG9jYXRpb24gYmVpbmcgbG9hZGVkIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3RcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPVxuICAgICAgc3RhdGUuYWN0aW9uRGF0YSAhPSBudWxsICYmXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJlxuICAgICAgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlO1xuXG4gICAgbGV0IGFjdGlvbkRhdGE6IFJvdXRlRGF0YSB8IG51bGw7XG4gICAgaWYgKG5ld1N0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW1wdHkgYWN0aW9uRGF0YSAtPiBjbGVhciBwcmlvciBhY3Rpb25EYXRhIGR1ZSB0byBhbiBhY3Rpb24gZXJyb3JcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FjdGlvblJlbG9hZCkge1xuICAgICAgLy8gS2VlcCB0aGUgY3VycmVudCBkYXRhIGlmIHdlJ3JlIHdyYXBwaW5nIHVwIHRoZSBhY3Rpb24gcmVsb2FkXG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXIgYWN0aW9uRGF0YSBvbiBhbnkgb3RoZXIgY29tcGxldGVkIG5hdmlnYXRpb25zXG4gICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgcHJlc2VydmUgYW55IGV4aXN0aW5nIGxvYWRlckRhdGEgZnJvbSByZS11c2VkIHJvdXRlc1xuICAgIGxldCBsb2FkZXJEYXRhID0gbmV3U3RhdGUubG9hZGVyRGF0YVxuICAgICAgPyBtZXJnZUxvYWRlckRhdGEoXG4gICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBuZXdTdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIG5ld1N0YXRlLm1hdGNoZXMgfHwgW10sXG4gICAgICAgICAgbmV3U3RhdGUuZXJyb3JzXG4gICAgICAgIClcbiAgICAgIDogc3RhdGUubG9hZGVyRGF0YTtcblxuICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uIHdlIGNhbiBhc3N1bWUgd2UgZ290IHRocm91Z2ggYWxsIGJsb2NrZXJzXG4gICAgLy8gc28gd2UgY2FuIHN0YXJ0IGZyZXNoXG4gICAgbGV0IGJsb2NrZXJzID0gc3RhdGUuYmxvY2tlcnM7XG4gICAgaWYgKGJsb2NrZXJzLnNpemUgPiAwKSB7XG4gICAgICBibG9ja2VycyA9IG5ldyBNYXAoYmxvY2tlcnMpO1xuICAgICAgYmxvY2tlcnMuZm9yRWFjaCgoXywgaykgPT4gYmxvY2tlcnMuc2V0KGssIElETEVfQkxPQ0tFUikpO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyByZXNwZWN0IHRoZSB1c2VyIGZsYWcuICBPdGhlcndpc2UgZG9uJ3QgcmVzZXQgb24gbXV0YXRpb25cbiAgICAvLyBzdWJtaXNzaW9uIG5hdmlnYXRpb25zIHVubGVzcyB0aGV5IHJlZGlyZWN0XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9XG4gICAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8XG4gICAgICAoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiZcbiAgICAgICAgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmXG4gICAgICAgIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZSk7XG5cbiAgICBpZiAoaW5GbGlnaHREYXRhUm91dGVzKSB7XG4gICAgICBkYXRhUm91dGVzID0gaW5GbGlnaHREYXRhUm91dGVzO1xuICAgICAgaW5GbGlnaHREYXRhUm91dGVzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGFuIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9uIHRoZW4gZG8gbm90IHRvdWNoIGhpc3RvcnlcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUG9wKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGZvciBQT1AgLSBVUkwgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBIaXN0b3J5QWN0aW9uLlB1c2gpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBIaXN0b3J5QWN0aW9uLlJlcGxhY2UpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgLi4ubmV3U3RhdGUsIC8vIG1hdGNoZXMsIGVycm9ycywgZmV0Y2hlcnMgZ28gdGhyb3VnaCBhcy1pc1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXNcbiAgICAgICksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2VycyxcbiAgICB9KTtcblxuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlBvcDtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cblxuICAvLyBUcmlnZ2VyIGEgbmF2aWdhdGlvbiBldmVudCwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIG51bWVyaWNhbCBQT1Agb3IgYSBQVVNIXG4gIC8vIHJlcGxhY2Ugd2l0aCBhbiBvcHRpb25hbCBzdWJtaXNzaW9uXG4gIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKFxuICAgIHRvOiBudW1iZXIgfCBUbyB8IG51bGwsXG4gICAgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9uc1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpbml0Lmhpc3RvcnkuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBmdXR1cmUudjdfcHJlcGVuZEJhc2VuYW1lLFxuICAgICAgdG8sXG4gICAgICBvcHRzPy5mcm9tUm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uLCBlcnJvciB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICAgICAgZnV0dXJlLnY3X25vcm1hbGl6ZUZvcm1NZXRob2QsXG4gICAgICBmYWxzZSxcbiAgICAgIG5vcm1hbGl6ZWRQYXRoLFxuICAgICAgb3B0c1xuICAgICk7XG5cbiAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhdGUubG9jYXRpb247XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBwYXRoLCBvcHRzICYmIG9wdHMuc3RhdGUpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0ge1xuICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgLi4uaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbiksXG4gICAgfTtcblxuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUHVzaDtcblxuICAgIGlmICh1c2VyUmVwbGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkge1xuICAgICAgLy8gbm8tb3BcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc3VibWlzc2lvbiAhPSBudWxsICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2hcbiAgICApIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XG4gICAgICAvLyB1c2VycyBkb24ndCBoYXZlIHRvIGRvdWJsZS1jbGljayB0aGUgYmFjayBidXR0b24gdG8gZ2V0IHRvIHRoZSBwcmlvclxuICAgICAgLy8gbG9jYXRpb24uICBJZiB0aGUgdXNlciByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gZnJvbSB0aGVcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUmVwbGFjZTtcbiAgICB9XG5cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIG9wdHMgJiYgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiBpbiBvcHRzXG4gICAgICAgID8gb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uLFxuICAgIH0pO1xuXG4gICAgaWYgKGJsb2NrZXJLZXkpIHtcbiAgICAgIC8vIFB1dCB0aGUgYmxvY2tlciBpbnRvIGEgYmxvY2tlZCBzdGF0ZVxuICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXkhLCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTZW5kIHRoZSBzYW1lIG5hdmlnYXRpb24gdGhyb3VnaFxuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXkhLCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIG5leHRMb2NhdGlvbiwge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIC8vIFNlbmQgdGhyb3VnaCB0aGUgZm9ybURhdGEgc2VyaWFsaXphdGlvbiBlcnJvciBpZiB3ZSBoYXZlIG9uZSBzbyB3ZSBjYW5cbiAgICAgIC8vIHJlbmRlciBhdCB0aGUgcmlnaHQgZXJyb3IgYm91bmRhcnkgYWZ0ZXIgd2UgbWF0Y2ggcm91dGVzXG4gICAgICBwZW5kaW5nRXJyb3I6IGVycm9yLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVwbGFjZTogb3B0cyAmJiBvcHRzLnJlcGxhY2UsXG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXZhbGlkYXRlIGFsbCBjdXJyZW50IGxvYWRlcnMuICBJZiBhIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3Mgb3IgaWYgdGhpc1xuICAvLyBpcyBpbnRlcnJ1cHRlZCBieSBhIG5hdmlnYXRpb24sIGFsbG93IHRoaXMgdG8gXCJzdWNjZWVkXCIgYnkgY2FsbGluZyBhbGxcbiAgLy8gbG9hZGVycyBkdXJpbmcgdGhlIG5leHQgbG9hZGVyIHJvdW5kXG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7IHJldmFsaWRhdGlvbjogXCJsb2FkaW5nXCIgfSk7XG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgc3VibWl0dGluZyBhbiBhY3Rpb24sIHdlIGRvbid0IG5lZWQgdG8gc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uLCB3ZSdsbCBqdXN0IGxldCB0aGUgZm9sbG93IHVwIGxvYWRlciBleGVjdXRpb24gY2FsbCBhbGwgbG9hZGVyc1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcInN1Ym1pdHRpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbiBhbiBpZGxlIHN0YXRlLCBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uIGZvciB0aGUgY3VycmVudFxuICAgIC8vIGFjdGlvbi9sb2NhdGlvbiBhbmQgbWFyayBpdCBhcyB1bmludGVycnVwdGVkLCB3aGljaCB3aWxsIHNraXAgdGhlIGhpc3RvcnlcbiAgICAvLyB1cGRhdGUgaW4gY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oc3RhdGUuaGlzdG9yeUFjdGlvbiwgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSBjdXJyZW50bHkgaW4gYSBsb2FkaW5nIHN0YXRlLCBqdXN0IHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiB0byB0aGUgbmF2aWdhdGlvbi5sb2NhdGlvbiBidXQgZG8gbm90IHRyaWdnZXIgYW4gdW5pbnRlcnJ1cHRlZFxuICAgIC8vIHJldmFsaWRhdGlvbiBzbyB0aGF0IGhpc3RvcnkgY29ycmVjdGx5IHVwZGF0ZXMgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICBzdGFydE5hdmlnYXRpb24oXG4gICAgICBwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLFxuICAgICAgeyBvdmVycmlkZU5hdmlnYXRpb246IHN0YXRlLm5hdmlnYXRpb24gfVxuICAgICk7XG4gIH1cblxuICAvLyBTdGFydCBhIG5hdmlnYXRpb24gdG8gdGhlIGdpdmVuIGFjdGlvbi9sb2NhdGlvbi4gIENhbiBvcHRpb25hbGx5IHByb3ZpZGUgYVxuICAvLyBvdmVycmlkZU5hdmlnYXRpb24gd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgbm9ybWFsTG9hZCBpbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0XG4gIC8vIG5hdmlnYXRpb25cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnROYXZpZ2F0aW9uKFxuICAgIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb24sXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG9wdHM/OiB7XG4gICAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIGZldGNoZXJTdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbj86IE5hdmlnYXRpb247XG4gICAgICBwZW5kaW5nRXJyb3I/OiBFcnJvclJlc3BvbnNlSW1wbDtcbiAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbj86IGJvb2xlYW47XG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICAgICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgfVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9XG4gICAgICAob3B0cyAmJiBvcHRzLnN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgPT09IHRydWU7XG5cbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuXG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3B0cyAmJiBvcHRzLm92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCB3aXRoIGEgNDA0IG9uIHRoZSByb290IGVycm9yIGJvdW5kYXJ5IGlmIHdlIG1hdGNoIG5vdGhpbmdcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzVG9Vc2UpO1xuICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIGRlZmVycmVkIG9uIDQwNHMgc2luY2Ugd2UgZG9uJ3Qga2VlcCBhbnkgcm91dGVzXG4gICAgICBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgaXQncyBvbmx5IGEgaGFzaCBjaGFuZ2UgYW5kIG5vdCBhIHJldmFsaWRhdGlvbiBvclxuICAgIC8vIG11dGF0aW9uIHN1Ym1pc3Npb24uXG4gICAgLy9cbiAgICAvLyBJZ25vcmUgb24gaW5pdGlhbCBwYWdlIGxvYWRzIGJlY2F1c2Ugc2luY2UgdGhlIGluaXRpYWwgbG9hZCB3aWxsIGFsd2F5c1xuICAgIC8vIGJlIFwic2FtZSBoYXNoXCIuICBGb3IgZXhhbXBsZSwgb24gL3BhZ2UjaGFzaCBhbmQgc3VibWl0IGEgPEZvcm0gbWV0aG9kPVwicG9zdFwiPlxuICAgIC8vIHdoaWNoIHdpbGwgZGVmYXVsdCB0byBhIG5hdmlnYXRpb24gdG8gL3BhZ2VcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5pbml0aWFsaXplZCAmJlxuICAgICAgIWlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgJiZcbiAgICAgIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJlxuICAgICAgIShvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSlcbiAgICApIHtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgeyBtYXRjaGVzIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNvbnRyb2xsZXIvUmVxdWVzdCBmb3IgdGhpcyBuYXZpZ2F0aW9uXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCByZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwsXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvblxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nRXJyb3IsIGl0IG1lYW5zIHRoZSB1c2VyIGF0dGVtcHRlZCBhIEdFVCBzdWJtaXNzaW9uXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxuICAgICAgLy8gd2F5IHdlIGhhbmRsZSBjYWxsaW5nIGxvYWRlcnMgYWJvdmUgdGhlIGJvdW5kYXJ5IGV0Yy4gIEl0J3Mgbm90IHJlYWxseVxuICAgICAgLy8gZGlmZmVyZW50IGZyb20gYW4gYWN0aW9uRXJyb3IgaW4gdGhhdCBzZW5zZS5cbiAgICAgIHBlbmRpbmdFcnJvciA9IHtcbiAgICAgICAgW2ZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWRdOiBvcHRzLnBlbmRpbmdFcnJvcixcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9wdHMgJiZcbiAgICAgIG9wdHMuc3VibWlzc2lvbiAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZClcbiAgICApIHtcbiAgICAgIC8vIENhbGwgYWN0aW9uIGlmIHdlIHJlY2VpdmVkIGFuIGFjdGlvbiBzdWJtaXNzaW9uXG4gICAgICBsZXQgYWN0aW9uT3V0cHV0ID0gYXdhaXQgaGFuZGxlQWN0aW9uKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgb3B0cy5zdWJtaXNzaW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICB7IHJlcGxhY2U6IG9wdHMucmVwbGFjZSB9XG4gICAgICApO1xuXG4gICAgICBpZiAoYWN0aW9uT3V0cHV0LnNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHsgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCB9KTtcbiAgICB9XG5cbiAgICAvLyBDYWxsIGxvYWRlcnNcbiAgICBsZXQgeyBzaG9ydENpcmN1aXRlZCwgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIHBlbmRpbmdBY3Rpb25EYXRhLFxuICAgICAgcGVuZGluZ0Vycm9yXG4gICAgKTtcblxuICAgIGlmIChzaG9ydENpcmN1aXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG5vdyB0aGF0IHRoZSBhY3Rpb24vbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmXG4gICAgLy8gd2Ugc2hvcnQgY2lyY3VpdGVkIGJlY2F1c2UgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIHdpbGwgaGF2ZSBhbHJlYWR5XG4gICAgLy8gYmVlbiBhc3NpZ25lZCB0byBhIG5ldyBjb250cm9sbGVyIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIC4uLihwZW5kaW5nQWN0aW9uRGF0YSA/IHsgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGEgfSA6IHt9KSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBhY3Rpb24gbWF0Y2hlZCBieSB0aGUgbGVhZiByb3V0ZSBmb3IgdGhpcyBuYXZpZ2F0aW9uIGFuZCBoYW5kbGVcbiAgLy8gcmVkaXJlY3RzL2Vycm9yc1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24oXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgc3VibWlzc2lvbjogU3VibWlzc2lvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3B0czogeyByZXBsYWNlPzogYm9vbGVhbiB9ID0ge31cbiAgKTogUHJvbWlzZTxIYW5kbGVBY3Rpb25SZXN1bHQ+IHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuXG4gICAgLy8gUHV0IHVzIGluIGEgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBuYXZpZ2F0aW9uID0gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIHVwZGF0ZVN0YXRlKHsgbmF2aWdhdGlvbiB9KTtcblxuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcblxuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYWN0aW9uTWF0Y2gsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgICAgIGJhc2VuYW1lXG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZXBsYWNlOiBib29sZWFuO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZSA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRpZG4ndCBleHBsaWNpdHkgaW5kaWNhdGUgcmVwbGFjZSBiZWhhdmlvciwgcmVwbGFjZSBpZlxuICAgICAgICAvLyB3ZSByZWRpcmVjdGVkIHRvIHRoZSBleGFjdCBzYW1lIGxvY2F0aW9uIHdlJ3JlIGN1cnJlbnRseSBhdCB0byBhdm9pZFxuICAgICAgICAvLyBkb3VibGUgYmFjay1idXR0b25zXG4gICAgICAgIHJlcGxhY2UgPVxuICAgICAgICAgIHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7IHN1Ym1pc3Npb24sIHJlcGxhY2UgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcblxuICAgICAgLy8gQnkgZGVmYXVsdCwgYWxsIHN1Ym1pc3Npb25zIGFyZSBSRVBMQUNFIG5hdmlnYXRpb25zLCBidXQgaWYgdGhlXG4gICAgICAvLyBhY3Rpb24gdGhyZXcgYW4gZXJyb3IgdGhhdCdsbCBiZSByZW5kZXJlZCBpbiBhbiBlcnJvckVsZW1lbnQsIHdlIGZhbGxcbiAgICAgIC8vIGJhY2sgdG8gUFVTSCBzbyB0aGF0IHRoZSB1c2VyIGNhbiB1c2UgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCBiYWNrIHRvXG4gICAgICAvLyB0aGUgcHJlLXN1Ym1pc3Npb24gZm9ybSBsb2NhdGlvbiB0byB0cnkgYWdhaW5cbiAgICAgIGlmICgob3B0cyAmJiBvcHRzLnJlcGxhY2UpICE9PSB0cnVlKSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlB1c2g7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFNlbmQgYmFjayBhbiBlbXB0eSBvYmplY3Qgd2UgY2FuIHVzZSB0byBjbGVhciBvdXQgYW55IHByaW9yIGFjdGlvbkRhdGFcbiAgICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHt9LFxuICAgICAgICBwZW5kaW5nQWN0aW9uRXJyb3I6IHsgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbixcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgICBmZXRjaGVyU3VibWlzc2lvbj86IFN1Ym1pc3Npb24sXG4gICAgcmVwbGFjZT86IGJvb2xlYW4sXG4gICAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGEsXG4gICAgcGVuZGluZ0Vycm9yPzogUm91dGVEYXRhXG4gICk6IFByb21pc2U8SGFuZGxlTG9hZGVyc1Jlc3VsdD4ge1xuICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHJpZ2h0IG5hdmlnYXRpb24gd2Ugd2FudCB0byB1c2UgZm9yIGRhdGEgbG9hZGluZ1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9XG4gICAgICBvdmVycmlkZU5hdmlnYXRpb24gfHwgZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuXG4gICAgLy8gSWYgdGhpcyB3YXMgYSByZWRpcmVjdCBmcm9tIGFuIGFjdGlvbiB3ZSBkb24ndCBoYXZlIGEgXCJzdWJtaXNzaW9uXCIgYnV0XG4gICAgLy8gd2UgaGF2ZSBpdCBvbiB0aGUgbG9hZGluZyBuYXZpZ2F0aW9uIHNvIHVzZSB0aGF0IGlmIGF2YWlsYWJsZVxuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID1cbiAgICAgIHN1Ym1pc3Npb24gfHxcbiAgICAgIGZldGNoZXJTdWJtaXNzaW9uIHx8XG4gICAgICBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obG9hZGluZ05hdmlnYXRpb24pO1xuXG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlU3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEsXG4gICAgICBwZW5kaW5nRXJyb3JcbiAgICApO1xuXG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhcbiAgICAgIChyb3V0ZUlkKSA9PlxuICAgICAgICAhKG1hdGNoZXMgJiYgbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHxcbiAgICAgICAgKG1hdGNoZXNUb0xvYWQgJiYgbWF0Y2hlc1RvTG9hZC5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSlcbiAgICApO1xuXG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1blxuICAgIGlmIChtYXRjaGVzVG9Mb2FkLmxlbmd0aCA9PT0gMCAmJiByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nRXJyb3IgfHwgbnVsbCxcbiAgICAgICAgLi4uKHBlbmRpbmdBY3Rpb25EYXRhID8geyBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB9IDoge30pLFxuICAgICAgICAuLi4odXBkYXRlZEZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9KSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9uLCB3ZSByZW1haW4gaW4gb3VyIGN1cnJlbnQgaWRsZVxuICAgIC8vIHN0YXRlLiAgSWYgbm90LCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBvdXIgbG9hZGluZyBzdGF0ZSBhbmQgbG9hZCBkYXRhLFxuICAgIC8vIHByZXNlcnZpbmcgYW55IG5ldyBhY3Rpb24gZGF0YSBvciBleGlzdGluZyBhY3Rpb24gZGF0YSAoaW4gdGhlIGNhc2Ugb2ZcbiAgICAvLyBhIHJldmFsaWRhdGlvbiBpbnRlcnJ1cHRpbmcgYW4gYWN0aW9uUmVsb2FkKVxuICAgIGlmICghaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChyZi5rZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBmZXRjaGVyID8gZmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgfSk7XG4gICAgICBsZXQgYWN0aW9uRGF0YSA9IHBlbmRpbmdBY3Rpb25EYXRhIHx8IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICAuLi4oYWN0aW9uRGF0YVxuICAgICAgICAgID8gT2JqZWN0LmtleXMoYWN0aW9uRGF0YSkubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IHsgYWN0aW9uRGF0YTogbnVsbCB9XG4gICAgICAgICAgICA6IHsgYWN0aW9uRGF0YSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihyZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwXG4gICAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHJmLmtleSkpIHtcbiAgICAgICAgYWJvcnRGZXRjaGVyKHJmLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAvLyBGZXRjaGVycyB1c2UgYW4gaW5kZXBlbmRlbnQgQWJvcnRDb250cm9sbGVyIHNvIHRoYXQgYWJvcnRpbmcgYSBmZXRjaGVyXG4gICAgICAgIC8vICh2aWEgZGVsZXRlRmV0Y2hlcikgZG9lcyBub3QgYWJvcnQgdGhlIHRyaWdnZXJpbmcgbmF2aWdhdGlvbiB0aGF0XG4gICAgICAgIC8vIHRyaWdnZXJlZCB0aGUgcmV2YWxpZGF0aW9uXG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQcm94eSBuYXZpZ2F0aW9uIGFib3J0IHRocm91Z2ggdG8gcmV2YWxpZGF0aW9uIGZldGNoZXJzXG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChmKSA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB7IHJlc3VsdHMsIGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPVxuICAgICAgYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgKTtcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIF9hZnRlcl8gbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmIHdlIHNob3J0XG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcbiAgICAvLyByZWFzc2lnbmVkIHRvIG5ldyBjb250cm9sbGVycyBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcblxuICAgIC8vIElmIGFueSBsb2FkZXJzIHJldHVybmVkIGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGlmIChyZWRpcmVjdC5pZHggPj0gbWF0Y2hlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZWRpcmVjdCBjYW1lIGZyb20gYSBmZXRjaGVyIG1ha2Ugc3VyZSB3ZSBtYXJrIGl0IGluXG4gICAgICAgIC8vIGZldGNoUmVkaXJlY3RJZHMgc28gaXQgZG9lc24ndCBnZXQgcmV2YWxpZGF0ZWQgb24gdGhlIG5leHQgc2V0IG9mXG4gICAgICAgIC8vIGxvYWRlciBleGVjdXRpb25zXG4gICAgICAgIGxldCBmZXRjaGVyS2V5ID1cbiAgICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdC5yZXN1bHQsIHsgcmVwbGFjZSB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBwZW5kaW5nRXJyb3IsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIC8vIFdpcmUgdXAgc3Vic2NyaWJlcnMgdG8gdXBkYXRlIGxvYWRlckRhdGEgYXMgcHJvbWlzZXMgc2V0dGxlXG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRlZmVycmVkRGF0YSwgcm91dGVJZCkgPT4ge1xuICAgICAgZGVmZXJyZWREYXRhLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAvLyBOb3RlOiBObyBuZWVkIHRvIHVwZGF0ZVN0YXRlIGhlcmUgc2luY2UgdGhlIFRyYWNrZWRQcm9taXNlIG9uXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBpbnN0YW5jZSBpZiB3ZSB3ZXJlIGFib3J0ZWQgb3IgaWYgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkXG4gICAgICAgIGlmIChhYm9ydGVkIHx8IGRlZmVycmVkRGF0YS5kb25lKSB7XG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG4gICAgbGV0IHNob3VsZFVwZGF0ZUZldGNoZXJzID1cbiAgICAgIHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgLi4uKHNob3VsZFVwZGF0ZUZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9KSxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcjxURGF0YSA9IGFueT4oa2V5OiBzdHJpbmcpOiBGZXRjaGVyPFREYXRhPiB7XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuXG4gIC8vIFRyaWdnZXIgYSBmZXRjaGVyIGxvYWQvc3VibWl0IGZvciB0aGUgZ2l2ZW4gZmV0Y2hlciBrZXlcbiAgZnVuY3Rpb24gZmV0Y2goXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIGhyZWY6IHN0cmluZyB8IG51bGwsXG4gICAgb3B0cz86IFJvdXRlckZldGNoT3B0aW9uc1xuICApIHtcbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJyb3V0ZXIuZmV0Y2goKSB3YXMgY2FsbGVkIGR1cmluZyB0aGUgc2VydmVyIHJlbmRlciwgYnV0IGl0IHNob3VsZG4ndCBiZS4gXCIgK1xuICAgICAgICAgIFwiWW91IGFyZSBsaWtlbHkgY2FsbGluZyBhIHVzZUZldGNoZXIoKSBtZXRob2QgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICtcbiAgICAgICAgICBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG5cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhcbiAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSxcbiAgICAgIGhyZWYsXG4gICAgICByb3V0ZUlkLFxuICAgICAgb3B0cz8ucmVsYXRpdmVcbiAgICApO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoLCBiYXNlbmFtZSk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbm9ybWFsaXplZFBhdGggfSlcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgICAgIGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLFxuICAgICAgdHJ1ZSxcbiAgICAgIG5vcm1hbGl6ZWRQYXRoLFxuICAgICAgb3B0c1xuICAgICk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBwYXRoKTtcblxuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG5cbiAgICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgb2ZmIHRoZSBtYXRjaCBzbyB3ZSBjYW4gY2FsbCBpdCdzIHNob3VsZFJldmFsaWRhdGUgb24gc3Vic2VxdWVudFxuICAgIC8vIHJldmFsaWRhdGlvbnNcbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIHsgcm91dGVJZCwgcGF0aCB9KTtcbiAgICBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgbWF0Y2hlZCBmZXRjaGVyLnN1Ym1pdCgpLCBhbmQgdGhlbiBoYW5kbGUgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGFuZCByZXZhbGlkYXRpb25cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckFjdGlvbihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHJlcXVlc3RNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgc3VibWlzc2lvbjogU3VibWlzc2lvblxuICApIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAoIW1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhbWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZUlkLFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3Mgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlciA9IGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlcik7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBmZXRjaGVyXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBwYXRoLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICApO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcblxuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgcmVxdWVzdE1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgIGJhc2VuYW1lXG4gICAgKTtcblxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdSBvdXIgb3duIGZldGNoZXJcbiAgICAgIC8vIHJlLXN1Ym1pdCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgLy8gQSBuZXcgbmF2aWdhdGlvbiB3YXMga2lja2VkIG9mZiBhZnRlciBvdXIgYWN0aW9uIHN0YXJ0ZWQsIHNvIHRoYXRcbiAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvbi4gIFdlIGFscmVhZHlcbiAgICAgICAgLy8gc2V0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgc28gYWxsIGxvYWRlcnMgZm9yIHRoZSBuZXcgcm91dGUgc2hvdWxkXG4gICAgICAgIC8vIGZpcmUgdW5sZXNzIG9wdGVkIG91dCB2aWEgc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICBsZXQgbG9hZGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZGluZ0ZldGNoZXIpO1xuICAgICAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIGFjdGlvblJlc3VsdCwge1xuICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFueSBub24tcmVkaXJlY3QgZXJyb3JzIHRocm93blxuICAgIGlmIChpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGF0YSBsb2FkIGZvciBjdXJyZW50IG1hdGNoZXMsIG9yIHRoZSBuZXh0IGxvY2F0aW9uIGlmIHdlJ3JlXG4gICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhIG5hdmlnYXRpb25cbiAgICBsZXQgbmV4dExvY2F0aW9uID0gc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiB8fCBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgcmV2YWxpZGF0aW9uUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICk7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG1hdGNoZXMgPVxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCJcbiAgICAgICAgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpXG4gICAgICAgIDogc3RhdGUubWF0Y2hlcztcblxuICAgIGludmFyaWFudChtYXRjaGVzLCBcIkRpZG4ndCBmaW5kIGFueSBtYXRjaGVzIGFmdGVyIGZldGNoZXIgYWN0aW9uXCIpO1xuXG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG5cbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuXG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHsgW21hdGNoLnJvdXRlLmlkXTogYWN0aW9uUmVzdWx0LmRhdGEgfSxcbiAgICAgIHVuZGVmaW5lZCAvLyBObyBuZWVkIHRvIHNlbmQgdGhyb3VnaCBlcnJvcnMgc2luY2Ugd2Ugc2hvcnQgY2lyY3VpdCBhYm92ZVxuICAgICk7XG5cbiAgICAvLyBQdXQgYWxsIHJldmFsaWRhdGluZyBmZXRjaGVycyBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlLCBleGNlcHQgZm9yIHRoZVxuICAgIC8vIGN1cnJlbnQgZmV0Y2hlciB3aGljaCB3ZSB3YW50IHRvIGtlZXAgaW4gaXQncyBjdXJyZW50IGxvYWRpbmcgc3RhdGUgd2hpY2hcbiAgICAvLyBjb250YWlucyBpdCdzIGFjdGlvbiBzdWJtaXNzaW9uIGluZm8gKyBhY3Rpb24gZGF0YVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzXG4gICAgICAuZmlsdGVyKChyZikgPT4gcmYua2V5ICE9PSBrZXkpXG4gICAgICAuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgICAgbGV0IHN0YWxlS2V5ID0gcmYua2V5O1xuICAgICAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHN0YWxlS2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHN0YWxlS2V5KSkge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihzdGFsZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT5cbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBhYm9ydEZldGNoZXIocmYua2V5KSk7XG5cbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImFib3J0XCIsXG4gICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICApO1xuXG4gICAgbGV0IHsgcmVzdWx0cywgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9XG4gICAgICBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0XG4gICAgICApO1xuXG4gICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG5cbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHIpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHIua2V5KSk7XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBpZiAocmVkaXJlY3QuaWR4ID49IG1hdGNoZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxuICAgICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxuICAgICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xuICAgICAgICBsZXQgZmV0Y2hlcktleSA9XG4gICAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnNbcmVkaXJlY3QuaWR4IC0gbWF0Y2hlc1RvTG9hZC5sZW5ndGhdLmtleTtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoZmV0Y2hlcktleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlZGlyZWN0LnJlc3VsdCk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIC8vIFNpbmNlIHdlIGxldCByZXZhbGlkYXRpb25zIGNvbXBsZXRlIGV2ZW4gaWYgdGhlIHN1Ym1pdHRpbmcgZmV0Y2hlciB3YXNcbiAgICAvLyBkZWxldGVkLCBvbmx5IHB1dCBpdCBiYWNrIHRvIGlkbGUgaWYgaXQgaGFzbid0IGJlZW4gZGVsZXRlZFxuICAgIGlmIChzdGF0ZS5mZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIoYWN0aW9uUmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cblxuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuXG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbiBhIG5hdmlnYXRpb24gbG9hZGluZyBzdGF0ZSBhbmQgdGhpcyBmZXRjaGVyIGlzXG4gICAgLy8gbW9yZSByZWNlbnQgdGhhbiB0aGUgbmF2aWdhdGlvbiwgd2Ugd2FudCB0aGUgbmV3ZXIgZGF0YSBzbyBhYm9ydCB0aGVcbiAgICAvLyBuYXZpZ2F0aW9uIGFuZCBjb21wbGV0ZSBpdCB3aXRoIHRoZSBmZXRjaGVyIGRhdGFcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJlxuICAgICAgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWRcbiAgICApIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuXG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgd2l0aCB0aGUgZmV0Y2hlciBkYXRhLCBwcmVzZXJ2aW5nIGFueSBleGlzdGluZ1xuICAgICAgLy8gbG9hZGVyRGF0YSBmb3IgbG9hZGVycyB0aGF0IGRpZCBub3QgbmVlZCB0byByZWxvYWQuICBXZSBoYXZlIHRvXG4gICAgICAvLyBtYW51YWxseSBtZXJnZSBoZXJlIHNpbmNlIHdlIGFyZW4ndCBnb2luZyB0aHJvdWdoIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgKSxcbiAgICAgICAgLi4uKGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwXG4gICAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9KTtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsIHRoZSBtYXRjaGVkIGxvYWRlciBmb3IgZmV0Y2hlci5sb2FkKCksIGhhbmRsaW5nIHJlZGlyZWN0cywgZXJyb3JzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJMb2FkZXIoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb25cbiAgKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIC8vIFB1dCB0aGlzIGZldGNoZXIgaW50byBpdCdzIGxvYWRpbmcgc3RhdGVcbiAgICBsZXQgbG9hZGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICAgICk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZGluZ0ZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgLy8gQ2FsbCB0aGUgbG9hZGVyIGZvciB0aGlzIGZldGNoZXIgcm91dGUgbWF0Y2hcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG5cbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgIFwibG9hZGVyXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgIGJhc2VuYW1lXG4gICAgKTtcblxuICAgIC8vIERlZmVycmVkIGlzbid0IHN1cHBvcnRlZCBmb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPVxuICAgICAgICAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fFxuICAgICAgICByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvdXIgb3duIGZldGNoZXJcbiAgICAvLyByZS1sb2FkIHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb2FkZXIgdGhyZXcgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgLy8gQSBuZXcgbmF2aWdhdGlvbiB3YXMga2lja2VkIG9mZiBhZnRlciBvdXIgbG9hZGVyIHN0YXJ0ZWQsIHNvIHRoYXRcbiAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvblxuICAgICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICAvLyBUT0RPOiBJbiByZW1peCwgdGhpcyB3b3VsZCByZXNldCB0byBJRExFX05BVklHQVRJT04gaWYgaXQgd2FzIGEgY2F0Y2ggLVxuICAgICAgLy8gZG8gd2UgbmVlZCB0byBiZWhhdmUgYW55IGRpZmZlcmVudGx5IHdpdGggb3VyIG5vbi1yZWRpcmVjdCBlcnJvcnM/XG4gICAgICAvLyBXaGF0IGlmIGl0IHdhcyBhIG5vbi1yZWRpcmVjdCBSZXNwb25zZT9cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudCghaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpLCBcIlVuaGFuZGxlZCBmZXRjaGVyIGRlZmVycmVkIGRhdGFcIik7XG5cbiAgICAvLyBQdXQgdGhlIGZldGNoZXIgYmFjayBpbnRvIGFuIGlkbGUgc3RhdGVcbiAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIHJlZGlyZWN0cyByZXR1cm5lZCBmcm9tIGFuIGFjdGlvbiBvciBsb2FkZXIuXG4gICAqIE5vcm1hbGx5LCBhIHJlZGlyZWN0IFwicmVwbGFjZXNcIiB0aGUgbmF2aWdhdGlvbiB0aGF0IHRyaWdnZXJlZCBpdC4gIFNvLCBmb3JcbiAgICogZXhhbXBsZTpcbiAgICpcbiAgICogIC0gdXNlciBpcyBvbiAvYVxuICAgKiAgLSB1c2VyIGNsaWNrcyBhIGxpbmsgdG8gL2JcbiAgICogIC0gbG9hZGVyIGZvciAvYiByZWRpcmVjdHMgdG8gL2NcbiAgICpcbiAgICogSW4gYSBub24tSlMgYXBwIHRoZSBicm93c2VyIHdvdWxkIHRyYWNrIHRoZSBpbi1mbGlnaHQgbmF2aWdhdGlvbiB0byAvYiBhbmRcbiAgICogdGhlbiByZXBsYWNlIGl0IHdpdGggL2Mgd2hlbiBpdCBlbmNvdW50ZXJlZCB0aGUgcmVkaXJlY3QgcmVzcG9uc2UuICBJblxuICAgKiB0aGUgZW5kIGl0IHdvdWxkIG9ubHkgZXZlciB1cGRhdGUgdGhlIFVSTCBiYXIgd2l0aCAvYy5cbiAgICpcbiAgICogSW4gY2xpZW50LXNpZGUgcm91dGluZyB1c2luZyBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlLCB3ZSBhaW0gdG8gZW11bGF0ZVxuICAgKiB0aGlzIGJlaGF2aW9yIGFuZCB3ZSBhbHNvIGRvIG5vdCB1cGRhdGUgaGlzdG9yeSB1bnRpbCB0aGUgZW5kIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uIChpbmNsdWRpbmcgcHJvY2Vzc2VkIHJlZGlyZWN0cykuICBUaGlzIG1lYW5zIHRoYXQgd2UgbmV2ZXJcbiAgICogYWN0dWFsbHkgdG91Y2ggaGlzdG9yeSB1bnRpbCB3ZSd2ZSBwcm9jZXNzZWQgcmVkaXJlY3RzLCBzbyB3ZSBqdXN0IHVzZVxuICAgKiB0aGUgaGlzdG9yeSBhY3Rpb24gZnJvbSB0aGUgb3JpZ2luYWwgbmF2aWdhdGlvbiAoUFVTSCBvciBSRVBMQUNFKS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgICByZWRpcmVjdDogUmVkaXJlY3RSZXN1bHQsXG4gICAge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgcmVwbGFjZSxcbiAgICB9OiB7XG4gICAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIGZldGNoZXJTdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIH0gPSB7fVxuICApIHtcbiAgICBpZiAocmVkaXJlY3QucmV2YWxpZGF0ZSkge1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHJlZGlyZWN0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcmVkaXJlY3QubG9jYXRpb24sIHtcbiAgICAgIF9pc1JlZGlyZWN0OiB0cnVlLFxuICAgIH0pO1xuICAgIGludmFyaWFudChcbiAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICBcIkV4cGVjdGVkIGEgbG9jYXRpb24gb24gdGhlIHJlZGlyZWN0IG5hdmlnYXRpb25cIlxuICAgICk7XG5cbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICBsZXQgaXNEb2N1bWVudFJlbG9hZCA9IGZhbHNlO1xuXG4gICAgICBpZiAocmVkaXJlY3QucmVsb2FkRG9jdW1lbnQpIHtcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5lZCBYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QocmVkaXJlY3QubG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID1cbiAgICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0byBhIG5ldyBvcmlnaW5cbiAgICAgICAgICB1cmwub3JpZ2luICE9PSByb3V0ZXJXaW5kb3cubG9jYXRpb24ub3JpZ2luIHx8XG4gICAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgICBzdHJpcEJhc2VuYW1lKHVybC5wYXRobmFtZSwgYmFzZW5hbWUpID09IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RvY3VtZW50UmVsb2FkKSB7XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLnJlcGxhY2UocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICBsZXQgcmVkaXJlY3RIaXN0b3J5QWN0aW9uID1cbiAgICAgIHJlcGxhY2UgPT09IHRydWUgPyBIaXN0b3J5QWN0aW9uLlJlcGxhY2UgOiBIaXN0b3J5QWN0aW9uLlB1c2g7XG5cbiAgICAvLyBVc2UgdGhlIGluY29taW5nIHN1Ym1pc3Npb24gaWYgcHJvdmlkZWQsIGZhbGxiYWNrIG9uIHRoZSBhY3RpdmUgb25lIGluXG4gICAgLy8gc3RhdGUubmF2aWdhdGlvblxuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICAgIGlmIChcbiAgICAgICFzdWJtaXNzaW9uICYmXG4gICAgICAhZmV0Y2hlclN1Ym1pc3Npb24gJiZcbiAgICAgIGZvcm1NZXRob2QgJiZcbiAgICAgIGZvcm1BY3Rpb24gJiZcbiAgICAgIGZvcm1FbmNUeXBlXG4gICAgKSB7XG4gICAgICBzdWJtaXNzaW9uID0gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24pO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2FzIGEgMzA3LzMwOCBzdWJtaXNzaW9uIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlIEhUVFAgbWV0aG9kIGFuZFxuICAgIC8vIHJlLXN1Ym1pdCB0aGUgR0VUL1BPU1QvUFVUL1BBVENIL0RFTEVURSBhcyBhIHN1Ym1pc3Npb24gbmF2aWdhdGlvbiB0byB0aGVcbiAgICAvLyByZWRpcmVjdGVkIGxvY2F0aW9uXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uO1xuICAgIGlmIChcbiAgICAgIHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3Quc3RhdHVzKSAmJlxuICAgICAgYWN0aXZlU3VibWlzc2lvbiAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChhY3RpdmVTdWJtaXNzaW9uLmZvcm1NZXRob2QpXG4gICAgKSB7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAuLi5hY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgICAgIGZvcm1BY3Rpb246IHJlZGlyZWN0LmxvY2F0aW9uLFxuICAgICAgICB9LFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGlzIGZsYWcgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIG5hdmlnYXRpb24gc3VibWlzc2lvbiwgd2Ugd2lsbCBwcmVzZXJ2ZSBpdCB0aHJvdWdoIHRoZVxuICAgICAgLy8gcmVkaXJlY3QgbmF2aWdhdGlvblxuICAgICAgbGV0IG92ZXJyaWRlTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKFxuICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICBzdWJtaXNzaW9uXG4gICAgICApO1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb24sXG4gICAgICAgIC8vIFNlbmQgZmV0Y2hlciBzdWJtaXNzaW9ucyB0aHJvdWdoIGZvciBzaG91bGRSZXZhbGlkYXRlXG4gICAgICAgIGZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGlzIGZsYWcgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgY3VycmVudE1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGZldGNoZXJzVG9Mb2FkOiBSZXZhbGlkYXRpbmdGZXRjaGVyW10sXG4gICAgcmVxdWVzdDogUmVxdWVzdFxuICApIHtcbiAgICAvLyBDYWxsIGFsbCBuYXZpZ2F0aW9uIGxvYWRlcnMgYW5kIHJldmFsaWRhdGluZyBmZXRjaGVyIGxvYWRlcnMgaW4gcGFyYWxsZWwsXG4gICAgLy8gdGhlbiBzbGljZSBvZmYgdGhlIHJlc3VsdHMgaW50byBzZXBhcmF0ZSBhcnJheXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtXG4gICAgLy8gYWNjb3JkaW5nbHlcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLm1hdGNoZXNUb0xvYWQubWFwKChtYXRjaCkgPT5cbiAgICAgICAgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgLi4uZmV0Y2hlcnNUb0xvYWQubWFwKChmKSA9PiB7XG4gICAgICAgIGlmIChmLm1hdGNoZXMgJiYgZi5tYXRjaCAmJiBmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICAgIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCBmLmNvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICAgIGYubWF0Y2gsXG4gICAgICAgICAgICBmLm1hdGNoZXMsXG4gICAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZXJyb3I6IEVycm9yUmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogZi5wYXRoIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICBdKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UobWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhcbiAgICAgICAgY3VycmVudE1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICAgIGxvYWRlclJlc3VsdHMubWFwKCgpID0+IHJlcXVlc3Quc2lnbmFsKSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHN0YXRlLmxvYWRlckRhdGFcbiAgICAgICksXG4gICAgICByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICAgICAgICBjdXJyZW50TWF0Y2hlcyxcbiAgICAgICAgZmV0Y2hlcnNUb0xvYWQubWFwKChmKSA9PiBmLm1hdGNoKSxcbiAgICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICAgIGZldGNoZXJzVG9Mb2FkLm1hcCgoZikgPT4gKGYuY29udHJvbGxlciA/IGYuY29udHJvbGxlci5zaWduYWwgOiBudWxsKSksXG4gICAgICAgIHRydWVcbiAgICAgICksXG4gICAgXSk7XG5cbiAgICByZXR1cm4geyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyByb3V0ZS1sZXZlbCBkZWZlcnJlZHMgYW5kIG1hcmsgY2FuY2VsbGVkIHJvdXRlcyBmb3JcbiAgICAvLyByZXZhbGlkYXRpb25cbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5wdXNoKC4uLmNhbmNlbEFjdGl2ZURlZmVycmVkcygpKTtcblxuICAgIC8vIEFib3J0IGluLWZsaWdodCBmZXRjaGVyIGxvYWRzXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5wdXNoKGtleSk7XG4gICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleTogc3RyaW5nLCByb3V0ZUlkOiBzdHJpbmcsIGVycm9yOiBhbnkpIHtcbiAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGVycm9yczoge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IGVycm9yLFxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIC8vIERvbid0IGFib3J0IHRoZSBjb250cm9sbGVyIGlmIHRoaXMgaXMgYSBkZWxldGlvbiBvZiBhIGZldGNoZXIuc3VibWl0KClcbiAgICAvLyBpbiBpdCdzIGxvYWRpbmcgcGhhc2Ugc2luY2UgLSB3ZSBkb24ndCB3YW50IHRvIGFib3J0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgLy8gcmV2YWxpZGF0aW9uIGFuZCB3YW50IHRoZW0gdG8gY29tcGxldGUgYW5kIGxhbmRcbiAgICBpZiAoXG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpICYmXG4gICAgICAhKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgZmV0Y2hSZWxvYWRJZHMuaGFzKGtleSkpXG4gICAgKSB7XG4gICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICB9XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleTogc3RyaW5nKSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGludmFyaWFudChjb250cm9sbGVyLCBgRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogJHtrZXl9YCk7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIoZmV0Y2hlci5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk6IGJvb2xlYW4ge1xuICAgIGxldCBkb25lS2V5cyA9IFtdO1xuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB1cGRhdGVkRmV0Y2hlcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgICByZXR1cm4gdXBkYXRlZEZldGNoZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgICAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB5ZWV0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKHllZXRlZEtleXMpO1xuICAgIHJldHVybiB5ZWV0ZWRLZXlzLmxlbmd0aCA+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleTogc3RyaW5nLCBmbjogQmxvY2tlckZ1bmN0aW9uKSB7XG4gICAgbGV0IGJsb2NrZXI6IEJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG5cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlQmxvY2tlcihrZXk6IHN0cmluZykge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHVwZGF0ZSBibG9ja2VycywgZW5zdXJpbmcgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnNcbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlcihrZXk6IHN0cmluZywgbmV3QmxvY2tlcjogQmxvY2tlcikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuXG4gICAgLy8gUG9vciBtYW5zIHN0YXRlIG1hY2hpbmUgOilcbiAgICAvLyBodHRwczovL21lcm1haWQubGl2ZS9lZGl0I3Bha286ZU5xVmtjOU93ekFNeGw4bDhubmpBWXJFdERJT0hFQklnd3ZLSlRSZUd5M19sRHBJcU8yN2s2YXdNRzBYY3JMbG56ODdud2RvbkVTb2dLWFhCdUU3OXJxNzVYWk8zLXlIZHMwUkpWdXY3MFlyUGxVckNFZTJIZnJPUlMzcnVicVpmdWh0cGc1Qzl3azV0WjRWS2NSVXE4OHE5WjhSUzAtNDhjRTFpSEprTDB1Z2JIdUZMdXM5TDZzcFp5OG5YOU1QMkNOZG9tVmFwb3NxdTNmR2F5VDhUOC1qSlF3aGVwb19VdHBnQlFhREVVb20wNGRaaEFOMWFKQkRsVUtKQnhFMWNlQjJTbWowTWxuLUlCVzVBRlUyZHdVaWt0dF8yUWFxMmRCZmFLZEV1cDg1VVY3WWQtZEtqbG5rYWJsMlB2cjBEVGtUcmVNXG4gICAgaW52YXJpYW50KFxuICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIpLFxuICAgICAgYEludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiAke2Jsb2NrZXIuc3RhdGV9IC0+ICR7bmV3QmxvY2tlci5zdGF0ZX1gXG4gICAgKTtcblxuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgIGJsb2NrZXJzLnNldChrZXksIG5ld0Jsb2NrZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICBuZXh0TG9jYXRpb24sXG4gICAgaGlzdG9yeUFjdGlvbixcbiAgfToge1xuICAgIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gICAgbmV4dExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xuICB9KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2Ugb255IHN1cHBvcnQgYSBzaW5nbGUgYWN0aXZlIGJsb2NrZXIgYXQgdGhlIG1vbWVudCBzaW5jZSB3ZSBkb24ndCBoYXZlXG4gICAgLy8gYW55IGNvbXBlbGxpbmcgdXNlIGNhc2VzIGZvciBtdWx0aS1ibG9ja2VyIHlldFxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIkEgcm91dGVyIG9ubHkgc3VwcG9ydHMgb25lIGJsb2NrZXIgYXQgYSB0aW1lXCIpO1xuICAgIH1cblxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuXG4gICAgaWYgKGJsb2NrZXIgJiYgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHtcbiAgICAgIC8vIElmIHRoZSBibG9ja2VyIGlzIGN1cnJlbnRseSBwcm9jZWVkaW5nLCB3ZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrXG4gICAgICAvLyBpdCBhbmQgY2FuIGxldCB0aGlzIG5hdmlnYXRpb24gY29udGludWVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBrbm93IHdlJ3JlIHVuYmxvY2tlZC9ibG9ja2VkIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlXG4gICAgLy8gdXNlci1wcm92aWRlZCBibG9ja2VyIGZ1bmN0aW9uXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbih7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0pKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcktleTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoXG4gICAgcHJlZGljYXRlPzogKHJvdXRlSWQ6IHN0cmluZykgPT4gYm9vbGVhblxuICApOiBzdHJpbmdbXSB7XG4gICAgbGV0IGNhbmNlbGxlZFJvdXRlSWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGFjdGl2ZURlZmVycmVkcy5mb3JFYWNoKChkZmQsIHJvdXRlSWQpID0+IHtcbiAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShyb3V0ZUlkKSkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlZmVycmVkIC0gYnV0IGRvIG5vdCByZW1vdmUgZnJvbSBhY3RpdmVEZWZlcnJlZHMgaGVyZSAtXG4gICAgICAgIC8vIHdlIHJlbHkgb24gdGhlIHN1YnNjcmliZXJzIHRvIGRvIHRoYXQgc28gb3VyIHRlc3RzIGNhbiBhc3NlcnQgcHJvcGVyXG4gICAgICAgIC8vIGNsZWFudXAgdmlhIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkc1xuICAgICAgICBkZmQuY2FuY2VsKCk7XG4gICAgICAgIGNhbmNlbGxlZFJvdXRlSWRzLnB1c2gocm91dGVJZCk7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5kZWxldGUocm91dGVJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbmNlbGxlZFJvdXRlSWRzO1xuICB9XG5cbiAgLy8gT3B0IGluIHRvIGNhcHR1cmluZyBhbmQgcmVwb3J0aW5nIHNjcm9sbCBwb3NpdGlvbnMgZHVyaW5nIG5hdmlnYXRpb25zLFxuICAvLyB1c2VkIGJ5IHRoZSA8U2Nyb2xsUmVzdG9yYXRpb24+IGNvbXBvbmVudFxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICBwb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ2V0UG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24sXG4gICAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvblxuICApIHtcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xuICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gZ2V0S2V5IHx8IG51bGw7XG5cbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxuICAgIC8vIHRoZSBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgYmVjYXVzZSB3ZSd2ZSBub3QgeWV0IHJlbmRlcmVkIDxTY3JvbGxSZXN0b3JhdGlvbi8+XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBoYXZlIG5vIHNhdmVkU2Nyb2xsUG9zaXRpb25zIGF2YWlsYWJsZVxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiB5IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNjcm9sbEtleShsb2NhdGlvbjogTG9jYXRpb24sIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSkge1xuICAgIGlmIChnZXRTY3JvbGxSZXN0b3JhdGlvbktleSkge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcy5tYXAoKG0pID0+IGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBrZXkgfHwgbG9jYXRpb24ua2V5O1xuICAgIH1cbiAgICByZXR1cm4gbG9jYXRpb24ua2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXVxuICApOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm5hbFNldFJvdXRlcyhuZXdSb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10pIHtcbiAgICBtYW5pZmVzdCA9IHt9O1xuICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICBuZXdSb3V0ZXMsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBtYW5pZmVzdFxuICAgICk7XG4gIH1cblxuICByb3V0ZXIgPSB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2gsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICAvLyBQYXNzdGhyb3VnaCB0byBoaXN0b3J5LWF3YXJlIGNyZWF0ZUhyZWYgdXNlZCBieSB1c2VIcmVmIHNvIHdlIGdldCBwcm9wZXJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXG4gICAgY3JlYXRlSHJlZjogKHRvOiBUbykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG86IFRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcixcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzLFxuICB9O1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVTdGF0aWNIYW5kbGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCA9IFN5bWJvbChcImRlZmVycmVkXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVN0YXRpY0hhbmRsZXJPcHRpb25zIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG1hcFJvdXRlUHJvcGVydGllc2AgaW5zdGVhZFxuICAgKi9cbiAgZGV0ZWN0RXJyb3JCb3VuZGFyeT86IERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbjtcbiAgbWFwUm91dGVQcm9wZXJ0aWVzPzogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IENyZWF0ZVN0YXRpY0hhbmRsZXJPcHRpb25zXG4pOiBTdGF0aWNIYW5kbGVyIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiXG4gICk7XG5cbiAgbGV0IG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0ID0ge307XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbjtcbiAgaWYgKG9wdHM/Lm1hcFJvdXRlUHJvcGVydGllcykge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IG9wdHMubWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9IGVsc2UgaWYgKG9wdHM/LmRldGVjdEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB0aGV5IGFyZSBzdGlsbCB1c2luZyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uLCB3cmFwIGl0IHdpdGggdGhlIG5ldyBBUElcbiAgICBsZXQgZGV0ZWN0RXJyb3JCb3VuZGFyeSA9IG9wdHMuZGV0ZWN0RXJyb3JCb3VuZGFyeTtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSAocm91dGUpID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9XG5cbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5kZWZpbmVkLFxuICAgIG1hbmlmZXN0XG4gICk7XG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZG9jdW1lbnQgcmVxdWVzdHMsIGluIHdoaWNoIHdlIHdhbnQgdG9cbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcbiAgICogcm91dGVzLiAgSXQgcmV0dXJucyBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgdmVyeSBzaW1pbGFyXG4gICAqIHRvIHRoZSByb3V0ZXIgc3RhdGUgKGxvY2F0aW9uLCBsb2FkZXJEYXRhLCBhY3Rpb25EYXRhLCBlcnJvcnMsIGV0Yy4pIGFuZFxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcbiAgICogZnJvbSBhY3Rpb24vbG9hZGVycyBSZXNwb25zZXMuXG4gICAqXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcbiAgICogcmV0dXJuZWQgY29udGV4dC5lcnJvcnMgb2JqZWN0LCBwcm9wZXJseSBhc3NvY2lhdGluZyBlcnJvcnMgdG8gdGhlaXIgZXJyb3JcbiAgICogYm91bmRhcnkuICBBZGRpdGlvbmFsbHksIGl0IHRyYWNrcyBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB3aGljaCBjYW4gYmVcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXG4gICAqIHBhc3Mgb25seSBkb3duIHRvIHRoZSBib3VuZGFyeUlkLlxuICAgKlxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXG4gICAqIHJlZGlyZWN0IHJlc3BvbnNlIGlzIHJldHVybmVkIG9yIHRocm93biBmcm9tIGFueSBhY3Rpb24vbG9hZGVyLiAgV2VcbiAgICogcHJvcGFnYXRlIHRoYXQgb3V0IGFuZCByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBzbyB0aGUgSFRUUCBzZXJ2ZXIgY2FuXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgeyByZXF1ZXN0Q29udGV4dCB9OiB7IHJlcXVlc3RDb250ZXh0PzogdW5rbm93biB9ID0ge31cbiAgKTogUHJvbWlzZTxTdGF0aWNIYW5kbGVyQ29udGV4dCB8IFJlc3BvbnNlPiB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbCxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFdoZW4gcmV0dXJuaW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0LCB3ZSBwYXRjaCBiYWNrIGluIHRoZSBsb2NhdGlvbiBoZXJlXG4gICAgLy8gc2luY2Ugd2UgbmVlZCBpdCBmb3IgUmVhY3QgQ29udGV4dC4gIEJ1dCB0aGlzIGhlbHBzIGtlZXAgb3VyIHN1Ym1pdCBhbmRcbiAgICAvLyBsb2FkUm91dGVEYXRhIG9wZXJhdGluZyBvbiBhIFJlcXVlc3QgaW5zdGVhZCBvZiBhIExvY2F0aW9uXG4gICAgcmV0dXJuIHsgbG9jYXRpb24sIGJhc2VuYW1lLCAuLi5yZXN1bHQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnlSb3V0ZSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdGFyZ2V0ZWQgcm91dGUgcmVxdWVzdHMsIGVpdGhlclxuICAgKiBmb3IgZmV0Y2ggP19kYXRhIHJlcXVlc3RzIG9yIHJlc291cmNlIHJvdXRlIHJlcXVlc3RzLiAgSW4gdGhpcyBjYXNlLCB3ZVxuICAgKiBhcmUgb25seSBldmVyIGNhbGxpbmcgYSBzaW5nbGUgYWN0aW9uIG9yIGxvYWRlciwgYW5kIHdlIGFyZSByZXR1cm5pbmcgdGhlXG4gICAqIHJldHVybmVkIHZhbHVlIGRpcmVjdGx5LiAgSW4gbW9zdCBjYXNlcywgdGhpcyB3aWxsIGJlIGEgUmVzcG9uc2UgcmV0dXJuZWRcbiAgICogZnJvbSB0aGUgYWN0aW9uL2xvYWRlciwgYnV0IGl0IG1heSBiZSBhIHByaW1pdGl2ZSBvciBvdGhlciB2YWx1ZSBhcyB3ZWxsIC1cbiAgICogYW5kIGluIHN1Y2ggY2FzZXMgdGhlIGNhbGxpbmcgY29udGV4dCBzaG91bGQgaGFuZGxlIHRoYXQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIFdlIGRvIHJlc3BlY3QgdGhlIHRocm93L3JldHVybiBkaWZmZXJlbnRpYXRpb24sIHNvIGlmIGFuIGFjdGlvbi9sb2FkZXJcbiAgICogdGhyb3dzLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgdGhlIHZhbHVlLiAgVGhpcyBpcyBpbXBvcnRhbnQgc28gd2VcbiAgICogY2FuIGRvIHByb3BlciBib3VuZGFyeSBpZGVudGlmaWNhdGlvbiBpbiBSZW1peCB3aGVyZSBhIHRocm93biBSZXNwb25zZVxuICAgKiBtdXN0IGdvIHRvIHRoZSBDYXRjaCBCb3VuZGFyeSBidXQgYSByZXR1cm5lZCBSZXNwb25zZSBpcyBoYXBweS1wYXRoLlxuICAgKlxuICAgKiBPbmUgdGhpbmcgdG8gbm90ZSBpcyB0aGF0IGFueSBSb3V0ZXItaW5pdGlhdGVkIEVycm9ycyB0aGF0IG1ha2Ugc2Vuc2VcbiAgICogdG8gYXNzb2NpYXRlIHdpdGggYSBzdGF0dXMgY29kZSB3aWxsIGJlIHRocm93biBhcyBhbiBFcnJvclJlc3BvbnNlXG4gICAqIGluc3RhbmNlIHdoaWNoIGluY2x1ZGUgdGhlIHJhdyBFcnJvciwgc3VjaCB0aGF0IHRoZSBjYWxsaW5nIGNvbnRleHQgY2FuXG4gICAqIHNlcmlhbGl6ZSB0aGUgZXJyb3IgYXMgdGhleSBzZWUgZml0IHdoaWxlIGluY2x1ZGluZyB0aGUgcHJvcGVyIHJlc3BvbnNlXG4gICAqIGNvZGUuICBFeGFtcGxlcyBoZXJlIGFyZSA0MDQgYW5kIDQwNSBlcnJvcnMgdGhhdCBvY2N1ciBwcmlvciB0byByZWFjaGluZ1xuICAgKiBhbnkgdXNlci1kZWZpbmVkIGxvYWRlcnMuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeVJvdXRlKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgIH06IHsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duOyByb3V0ZUlkPzogc3RyaW5nIH0gPSB7fVxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuXG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiICYmIG1ldGhvZCAhPT0gXCJPUFRJT05TXCIpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoID0gcm91dGVJZFxuICAgICAgPyBtYXRjaGVzLmZpbmQoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpXG4gICAgICA6IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcblxuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDMsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2gpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhpdCBJIGRvbid0IHRoaW5rP1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBtYXRjaFxuICAgICk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3JzID8gT2JqZWN0LnZhbHVlcyhyZXN1bHQuZXJyb3JzKVswXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgd2UgZ290IGJhY2sgcmVzdWx0LmVycm9ycywgdGhhdCBtZWFucyB0aGUgbG9hZGVyL2FjdGlvbiB0aHJld1xuICAgICAgLy8gX3NvbWV0aGluZ18gdGhhdCB3YXNuJ3QgYSBSZXNwb25zZSwgYnV0IGl0J3Mgbm90IGd1YXJhbnRlZWQvcmVxdWlyZWRcbiAgICAgIC8vIHRvIGJlIGFuIGBpbnN0YW5jZW9mIEVycm9yYCBlaXRoZXIsIHNvIHdlIGhhdmUgdG8gdXNlIHRocm93IGhlcmUgdG9cbiAgICAgIC8vIHByZXNlcnZlIHRoZSBcImVycm9yXCIgc3RhdGUgb3V0c2lkZSBvZiBxdWVyeUltcGwuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBQaWNrIG9mZiB0aGUgcmlnaHQgc3RhdGUgdmFsdWUgdG8gcmV0dXJuXG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XG4gICAgICBsZXQgZGF0YSA9IE9iamVjdC52YWx1ZXMocmVzdWx0LmxvYWRlckRhdGEpWzBdO1xuICAgICAgaWYgKHJlc3VsdC5hY3RpdmVEZWZlcnJlZHM/LlttYXRjaC5yb3V0ZS5pZF0pIHtcbiAgICAgICAgZGF0YVtVTlNBRkVfREVGRVJSRURfU1lNQk9MXSA9IHJlc3VsdC5hY3RpdmVEZWZlcnJlZHNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgcm91dGVNYXRjaD86IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbiAgKTogUHJvbWlzZTxPbWl0PFN0YXRpY0hhbmRsZXJDb250ZXh0LCBcImxvY2F0aW9uXCIgfCBcImJhc2VuYW1lXCI+IHwgUmVzcG9uc2U+IHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIlxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGlzTXV0YXRpb25NZXRob2QocmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHN1Ym1pdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksXG4gICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgcm91dGVNYXRjaCAhPSBudWxsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgcm91dGVNYXRjaFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdClcbiAgICAgICAgPyByZXN1bHRcbiAgICAgICAgOiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB0aHJldy9yZXR1cm5lZCBhIFJlc3BvbnNlIGluIGNhbGxMb2FkZXJPckFjdGlvbiwgd2UgdGhyb3dcbiAgICAgIC8vIGl0IHRvIGJhaWwgb3V0IGFuZCB0aGVuIHJldHVybiBvciB0aHJvdyBoZXJlIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHVzZXJcbiAgICAgIC8vIHJldHVybmVkIG9yIHRocmV3XG4gICAgICBpZiAoaXNRdWVyeVJvdXRlUmVzcG9uc2UoZSkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgICAgIHRocm93IGUucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICAvLyBSZWRpcmVjdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBzaW5jZSB0aGV5IGRvbid0IHByb3BhZ2F0ZSB0byBjYXRjaFxuICAgICAgLy8gYm91bmRhcmllc1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3VibWl0KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGFjdGlvbk1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIGlzUm91dGVSZXF1ZXN0OiBib29sZWFuXG4gICk6IFByb21pc2U8T21pdDxTdGF0aWNIYW5kbGVyQ29udGV4dCwgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiPiB8IFJlc3BvbnNlPiB7XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdDtcblxuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkLFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIHsgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLCBpc1JvdXRlUmVxdWVzdCwgcmVxdWVzdENvbnRleHQgfVxuICAgICAgKTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHttZXRob2R9KCkgY2FsbCBhYm9ydGVkOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFthY3Rpb25NYXRjaF0sXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gYWN0aW9uIHN0YXR1cyBjb2RlcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXIgc3RhdHVzIGNvZGVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgPyByZXN1bHQuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgOiA1MDAsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIEdFVCByZXF1ZXN0IGZvciB0aGUgbG9hZGVyc1xuICAgIGxldCBsb2FkZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLihyZXN1bHQuc3RhdHVzQ29kZSA/IHsgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1c0NvZGUgfSA6IHt9KSxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEsXG4gICAgICB9LFxuICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIHJvdXRlTWF0Y2g/OiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHBlbmRpbmdBY3Rpb25FcnJvcj86IFJvdXRlRGF0YVxuICApOiBQcm9taXNlPFxuICAgIHwgT21pdDxcbiAgICAgICAgU3RhdGljSGFuZGxlckNvbnRleHQsXG4gICAgICAgIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIiB8IFwiYWN0aW9uRGF0YVwiIHwgXCJhY3Rpb25IZWFkZXJzXCJcbiAgICAgID5cbiAgICB8IFJlc3BvbnNlXG4gID4ge1xuICAgIGxldCBpc1JvdXRlUmVxdWVzdCA9IHJvdXRlTWF0Y2ggIT0gbnVsbDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnlSb3V0ZSgpKVxuICAgIGlmIChcbiAgICAgIGlzUm91dGVSZXF1ZXN0ICYmXG4gICAgICAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyICYmXG4gICAgICAhcm91dGVNYXRjaD8ucm91dGUubGF6eVxuICAgICkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZU1hdGNoPy5yb3V0ZS5pZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0TWF0Y2hlcyA9IHJvdXRlTWF0Y2hcbiAgICAgID8gW3JvdXRlTWF0Y2hdXG4gICAgICA6IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXVxuICAgICAgICApO1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gcmVxdWVzdE1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG0pID0+IG0ucm91dGUubG9hZGVyIHx8IG0ucm91dGUubGF6eVxuICAgICk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW4gKHF1ZXJ5KCkpXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICAvLyBBZGQgYSBudWxsIGZvciBhbGwgbWF0Y2hlZCByb3V0ZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgICAgICBsb2FkZXJEYXRhOiBtYXRjaGVzLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBtKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbbS5yb3V0ZS5pZF06IG51bGwgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKSxcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uRXJyb3IgfHwgbnVsbCxcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLm1hdGNoZXNUb0xvYWQubWFwKChtYXRjaCkgPT5cbiAgICAgICAgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICB7IGlzU3RhdGljUmVxdWVzdDogdHJ1ZSwgaXNSb3V0ZVJlcXVlc3QsIHJlcXVlc3RDb250ZXh0IH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICBdKTtcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZDogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IGFjdGl2ZURlZmVycmVkcyA9IG5ldyBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+KCk7XG4gICAgbGV0IGNvbnRleHQgPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICByZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvbkVycm9yLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIC8vIEFkZCBhIG51bGwgZm9yIGFueSBub24tbG9hZGVyIG1hdGNoZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgIGxldCBleGVjdXRlZExvYWRlcnMgPSBuZXcgU2V0PHN0cmluZz4oXG4gICAgICBtYXRjaGVzVG9Mb2FkLm1hcCgobWF0Y2gpID0+IG1hdGNoLnJvdXRlLmlkKVxuICAgICk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgaWYgKCFleGVjdXRlZExvYWRlcnMuaGFzKG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgICBjb250ZXh0LmxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZURlZmVycmVkczpcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLnNpemUgPiAwXG4gICAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoYWN0aXZlRGVmZXJyZWRzLmVudHJpZXMoKSlcbiAgICAgICAgICA6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlLFxuICB9O1xufVxuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIZWxwZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdpdmVuIGFuIGV4aXN0aW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0IGFuZCBhbiBlcnJvciB0aHJvd24gYXQgcmVuZGVyIHRpbWUsXG4gKiBwcm92aWRlIGFuIHVwZGF0ZWQgU3RhdGljSGFuZGxlckNvbnRleHQgc3VpdGFibGUgZm9yIGEgc2Vjb25kIFNTUiByZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IoXG4gIHJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSxcbiAgY29udGV4dDogU3RhdGljSGFuZGxlckNvbnRleHQsXG4gIGVycm9yOiBhbnlcbikge1xuICBsZXQgbmV3Q29udGV4dDogU3RhdGljSGFuZGxlckNvbnRleHQgPSB7XG4gICAgLi4uY29udGV4dCxcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvcixcbiAgICB9LFxuICB9O1xuICByZXR1cm4gbmV3Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihcbiAgb3B0czogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4pOiBvcHRzIGlzIFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMge1xuICByZXR1cm4gKFxuICAgIG9wdHMgIT0gbnVsbCAmJlxuICAgICgoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsKSB8fFxuICAgICAgKFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpKVxuICApO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUbyhcbiAgbG9jYXRpb246IFBhdGgsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgYmFzZW5hbWU6IHN0cmluZyxcbiAgcHJlcGVuZEJhc2VuYW1lOiBib29sZWFuLFxuICB0bzogVG8gfCBudWxsLFxuICBmcm9tUm91dGVJZD86IHN0cmluZyxcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlXG4pIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG4gIGxldCBhY3RpdmVSb3V0ZU1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgdW5kZWZpbmVkO1xuICBpZiAoZnJvbVJvdXRlSWQgIT0gbnVsbCAmJiByZWxhdGl2ZSAhPT0gXCJwYXRoXCIpIHtcbiAgICAvLyBHcmFiIG1hdGNoZXMgdXAgdG8gdGhlIGNhbGxpbmcgcm91dGUgc28gb3VyIHJvdXRlLXJlbGF0aXZlIGxvZ2ljIGlzXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIGNvcnJlY3Qgc291cmNlIHJvdXRlLiAgV2hlbiB1c2luZyByZWxhdGl2ZTpwYXRoLFxuICAgIC8vIGZyb21Sb3V0ZUlkIGlzIGlnbm9yZWQgc2luY2UgdGhhdCBpcyBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnRcbiAgICAvLyBsb2NhdGlvbiBwYXRoXG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb250ZXh0dWFsTWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCA9PT0gZnJvbVJvdXRlSWQpIHtcbiAgICAgICAgYWN0aXZlUm91dGVNYXRjaCA9IG1hdGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvLyBSZXNvbHZlIHRoZSByZWxhdGl2ZSBwYXRoXG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvID8gdG8gOiBcIi5cIixcbiAgICBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhjb250ZXh0dWFsTWF0Y2hlcykubWFwKChtKSA9PiBtLnBhdGhuYW1lQmFzZSksXG4gICAgc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICApO1xuXG4gIC8vIFdoZW4gYHRvYCBpcyBub3Qgc3BlY2lmaWVkIHdlIGluaGVyaXQgc2VhcmNoL2hhc2ggZnJvbSB0aGUgY3VycmVudFxuICAvLyBsb2NhdGlvbiwgdW5saWtlIHdoZW4gdG89XCIuXCIgYW5kIHdlIGp1c3QgaW5oZXJpdCB0aGUgcGF0aC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xuICBpZiAodG8gPT0gbnVsbCkge1xuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIH1cblxuICAvLyBBZGQgYW4gP2luZGV4IHBhcmFtIGZvciBtYXRjaGVkIGluZGV4IHJvdXRlcyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmIChcbiAgICAodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmXG4gICAgYWN0aXZlUm91dGVNYXRjaCAmJlxuICAgIGFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiZcbiAgICAhaGFzTmFrZWRJbmRleFF1ZXJ5KHBhdGguc2VhcmNoKVxuICApIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoXG4gICAgICA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIilcbiAgICAgIDogXCI/aW5kZXhcIjtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUuICBJZlxuICAvLyB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlIHRoZSByYXcgYmFzZW5hbWUgd2hpY2ggYWxsb3dzXG4gIC8vIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZSBvZiBhIHRyYWlsaW5nIHNsYXNoXG4gIC8vIG9uIHJvb3QgYWN0aW9uc1xuICBpZiAocHJlcGVuZEJhc2VuYW1lICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPVxuICAgICAgcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuXG4vLyBOb3JtYWxpemUgbmF2aWdhdGlvbiBvcHRpb25zIGJ5IGNvbnZlcnRpbmcgZm9ybU1ldGhvZD1HRVQgZm9ybURhdGEgb2JqZWN0cyB0b1xuLy8gVVJMU2VhcmNoUGFyYW1zIHNvIHRoZXkgYmVoYXZlIGlkZW50aWNhbGx5IHRvIGxpbmtzIHdpdGggcXVlcnkgcGFyYW1zXG5mdW5jdGlvbiBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gIG5vcm1hbGl6ZUZvcm1NZXRob2Q6IGJvb2xlYW4sXG4gIGlzRmV0Y2hlcjogYm9vbGVhbixcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4pOiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gIGVycm9yPzogRXJyb3JSZXNwb25zZUltcGw7XG59IHtcbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7IHBhdGggfTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pLFxuICAgIH07XG4gIH1cblxuICBsZXQgZ2V0SW52YWxpZEJvZHlFcnJvciA9ICgpID0+ICh7XG4gICAgcGF0aCxcbiAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJpbnZhbGlkLWJvZHlcIiB9KSxcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGEgU3VibWlzc2lvbiBvbiBub24tR0VUIG5hdmlnYXRpb25zXG4gIGxldCByYXdGb3JtTWV0aG9kID0gb3B0cy5mb3JtTWV0aG9kIHx8IFwiZ2V0XCI7XG4gIGxldCBmb3JtTWV0aG9kID0gbm9ybWFsaXplRm9ybU1ldGhvZFxuICAgID8gKHJhd0Zvcm1NZXRob2QudG9VcHBlckNhc2UoKSBhcyBWN19Gb3JtTWV0aG9kKVxuICAgIDogKHJhd0Zvcm1NZXRob2QudG9Mb3dlckNhc2UoKSBhcyBGb3JtTWV0aG9kKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKTtcblxuICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIHRleHQgb25seSBzdXBwb3J0IFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0ID1cbiAgICAgICAgdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgID8gb3B0cy5ib2R5XG4gICAgICAgICAgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fFxuICAgICAgICAgICAgb3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zXG4gICAgICAgICAgPyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNwbGFpbi10ZXh0LWZvcm0tZGF0YVxuICAgICAgICAgICAgQXJyYXkuZnJvbShvcHRzLmJvZHkuZW50cmllcygpKS5yZWR1Y2UoXG4gICAgICAgICAgICAgIChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IGAke2FjY30ke25hbWV9PSR7dmFsdWV9XFxuYCxcbiAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogU3RyaW5nKG9wdHMuYm9keSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgLy8ganNvbiBvbmx5IHN1cHBvcnRzIFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID1cbiAgICAgICAgICB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShvcHRzLmJvZHkpIDogb3B0cy5ib2R5O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsXG4gICAgXCJGb3JtRGF0YSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnRcIlxuICApO1xuXG4gIGxldCBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcztcbiAgbGV0IGZvcm1EYXRhOiBGb3JtRGF0YTtcblxuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuZm9ybURhdGEpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gb3B0cy5ib2R5O1xuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBsZXQgc3VibWlzc2lvbjogU3VibWlzc2lvbiA9IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6XG4gICAgICAob3B0cyAmJiBvcHRzLmZvcm1FbmNUeXBlKSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWQsXG4gIH07XG5cbiAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7IHBhdGgsIHN1Ym1pc3Npb24gfTtcbiAgfVxuXG4gIC8vIEZsYXR0ZW4gc3VibWlzc2lvbiBvbnRvIFVSTFNlYXJjaFBhcmFtcyBmb3IgR0VUIHN1Ym1pc3Npb25zXG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICAvLyBPbiBHRVQgbmF2aWdhdGlvbiBzdWJtaXNzaW9ucyB3ZSBjYW4gZHJvcCB0aGUgP2luZGV4IHBhcmFtIGZyb20gdGhlXG4gIC8vIHJlc3VsdGluZyBsb2NhdGlvbiBzaW5jZSBhbGwgbG9hZGVycyB3aWxsIHJ1bi4gIEJ1dCBmZXRjaGVyIEdFVCBzdWJtaXNzaW9uc1xuICAvLyBvbmx5IHJ1biBhIHNpbmdsZSBsb2FkZXIgc28gd2UgbmVlZCB0byBwcmVzZXJ2ZSBhbnkgaW5jb21pbmcgP2luZGV4IHBhcmFtc1xuICBpZiAoaXNGZXRjaGVyICYmIHBhcnNlZFBhdGguc2VhcmNoICYmIGhhc05ha2VkSW5kZXhRdWVyeShwYXJzZWRQYXRoLnNlYXJjaCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgXCJcIik7XG4gIH1cbiAgcGFyc2VkUGF0aC5zZWFyY2ggPSBgPyR7c2VhcmNoUGFyYW1zfWA7XG5cbiAgcmV0dXJuIHsgcGF0aDogY3JlYXRlUGF0aChwYXJzZWRQYXRoKSwgc3VibWlzc2lvbiB9O1xufVxuXG4vLyBGaWx0ZXIgb3V0IGFsbCByb3V0ZXMgYmVsb3cgYW55IGNhdWdodCBlcnJvciBhcyB0aGV5IGFyZW4ndCBnb2luZyB0b1xuLy8gcmVuZGVyIHNvIHdlIGRvbid0IG5lZWQgdG8gbG9hZCB0aGVtXG5mdW5jdGlvbiBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBib3VuZGFyeUlkPzogc3RyaW5nXG4pIHtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXM7XG4gIGlmIChib3VuZGFyeUlkKSB7XG4gICAgbGV0IGluZGV4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kYXJ5TWF0Y2hlcztcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgaGlzdG9yeTogSGlzdG9yeSxcbiAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHN1Ym1pc3Npb246IFN1Ym1pc3Npb24gfCB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZDogYm9vbGVhbixcbiAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdLFxuICBjYW5jZWxsZWRGZXRjaGVyTG9hZHM6IHN0cmluZ1tdLFxuICBmZXRjaExvYWRNYXRjaGVzOiBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD4sXG4gIGZldGNoUmVkaXJlY3RJZHM6IFNldDxzdHJpbmc+LFxuICByb3V0ZXNUb1VzZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSxcbiAgYmFzZW5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGEsXG4gIHBlbmRpbmdFcnJvcj86IFJvdXRlRGF0YVxuKTogW0Fnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSwgUmV2YWxpZGF0aW5nRmV0Y2hlcltdXSB7XG4gIGxldCBhY3Rpb25SZXN1bHQgPSBwZW5kaW5nRXJyb3JcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXVxuICAgIDogcGVuZGluZ0FjdGlvbkRhdGFcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0FjdGlvbkRhdGEpWzBdXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuXG4gIC8vIFBpY2sgbmF2aWdhdGlvbiBtYXRjaGVzIHRoYXQgYXJlIG5ldC1uZXcgb3IgcXVhbGlmeSBmb3IgcmV2YWxpZGF0aW9uXG4gIGxldCBib3VuZGFyeUlkID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpO1xuXG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXRjaC5yb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBsb2FkZXIgb24gbmV3IHJvdXRlIGluc3RhbmNlcyBhbmQgcGVuZGluZyBkZWZlciBjYW5jZWxsYXRpb25zXG4gICAgaWYgKFxuICAgICAgaXNOZXdMb2FkZXIoc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKSB8fFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMuc29tZSgoaWQpID0+IGlkID09PSBtYXRjaC5yb3V0ZS5pZClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuXG4gICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIHtcbiAgICAgIGN1cnJlbnRVcmwsXG4gICAgICBjdXJyZW50UGFyYW1zOiBjdXJyZW50Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICBuZXh0VXJsLFxuICAgICAgbmV4dFBhcmFtczogbmV4dFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgICAvLyBGb3JjZWQgcmV2YWxpZGF0aW9uIGR1ZSB0byBzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlXG4gICAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHxcbiAgICAgICAgLy8gQ2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gICAgICAgIGN1cnJlbnRVcmwucGF0aG5hbWUgKyBjdXJyZW50VXJsLnNlYXJjaCA9PT1cbiAgICAgICAgICBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHxcbiAgICAgICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgICAgY3VycmVudFVybC5zZWFyY2ggIT09IG5leHRVcmwuc2VhcmNoIHx8XG4gICAgICAgIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50Um91dGVNYXRjaCwgbmV4dFJvdXRlTWF0Y2gpLFxuICAgIH0pO1xuICB9KTtcblxuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZSBpZiBmZXRjaGVyIHdvbid0IGJlIHByZXNlbnQgaW4gdGhlIHN1YnNlcXVlbnQgcmVuZGVyXG4gICAgaWYgKCFtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IGYucm91dGVJZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgZmV0Y2hlciBwYXRoIG5vIGxvbmdlciBtYXRjaGVzLCBwdXNoIGl0IGluIHdpdGggbnVsbCBtYXRjaGVzIHNvXG4gICAgLy8gd2UgY2FuIHRyaWdnZXIgYSA0MDQgaW4gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhLiAgTm90ZSB0aGlzIGlzXG4gICAgLy8gY3VycmVudGx5IG9ubHkgYSB1c2UtY2FzZSBmb3IgUmVtaXggSE1SIHdoZXJlIHRoZSByb3V0ZSB0cmVlIGNhbiBjaGFuZ2VcbiAgICAvLyBhdCBydW50aW1lIGFuZCByZW1vdmUgYSByb3V0ZSBwcmV2aW91c2x5IGxvYWRlZCB2aWEgYSBmZXRjaGVyXG4gICAgaWYgKCFmZXRjaGVyTWF0Y2hlcykge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IG51bGwsXG4gICAgICAgIG1hdGNoOiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmV2YWxpZGF0aW5nIGZldGNoZXJzIGFyZSBkZWNvdXBsZWQgZnJvbSB0aGUgcm91dGUgbWF0Y2hlcyBzaW5jZSB0aGV5XG4gICAgLy8gbG9hZCBmcm9tIGEgc3RhdGljIGhyZWYuICBUaGV5IHJldmFsaWRhdGUgYmFzZWQgb24gZXhwbGljaXQgcmV2YWxpZGF0aW9uXG4gICAgLy8gKHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGUpXG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlck1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2goZmV0Y2hlck1hdGNoZXMsIGYucGF0aCk7XG5cbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBOZXZlciB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFuIGFjdGl2ZWx5IHJlZGlyZWN0aW5nIGZldGNoZXJcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAvLyBBbHdheXMgcmV2YWxpZGF0ZSBpZiB0aGUgZmV0Y2hlciB3YXMgY2FuY2VsbGVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgZmV0Y2hlciAmJlxuICAgICAgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiZcbiAgICAgIGZldGNoZXIuZGF0YSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGUgZmV0Y2hlciBoYXNuJ3QgZXZlciBjb21wbGV0ZWQgbG9hZGluZyB5ZXQsIHRoZW4gdGhpcyBpc24ndCBhXG4gICAgICAvLyByZXZhbGlkYXRpb24sIGl0IHdvdWxkIGp1c3QgYmUgYSBicmFuZCBuZXcgbG9hZCBpZiBhbiBleHBsaWNpdFxuICAgICAgLy8gcmV2YWxpZGF0aW9uIGlzIHJlcXVpcmVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gaXNSZXZhbGlkYXRpb25SZXF1aXJlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayBvbiBhbnkgdXNlci1kZWZpbmVkIHNob3VsZFJldmFsaWRhdGUsIGRlZmF1bHRpbmdcbiAgICAgIC8vIHRvIGV4cGxpY2l0IHJldmFsaWRhdGlvbnMgb25seVxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCB7XG4gICAgICAgIGN1cnJlbnRVcmwsXG4gICAgICAgIGN1cnJlbnRQYXJhbXM6IHN0YXRlLm1hdGNoZXNbc3RhdGUubWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIG5leHRVcmwsXG4gICAgICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IGZldGNoZXJNYXRjaGVzLFxuICAgICAgICBtYXRjaDogZmV0Y2hlck1hdGNoLFxuICAgICAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKCksXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBbbmF2aWdhdGlvbk1hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzXTtcbn1cblxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoXG4gIGN1cnJlbnRMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgaXNOZXcgPVxuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICAhY3VycmVudE1hdGNoIHx8XG4gICAgLy8gW2EsIGJdIC0+IFthLCBjXVxuICAgIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2gucm91dGUuaWQ7XG5cbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciBhIHJlLXVzZWQgcm91dGUsIHBvdGVudGlhbGx5XG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZDtcblxuICAvLyBBbHdheXMgbG9hZCBpZiB0aGlzIGlzIGEgbmV0LW5ldyByb3V0ZSBvciB3ZSBkb24ndCB5ZXQgaGF2ZSBkYXRhXG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuXG5mdW5jdGlvbiBpc05ld1JvdXRlSW5zdGFuY2UoXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgY3VycmVudFBhdGggPSBjdXJyZW50TWF0Y2gucm91dGUucGF0aDtcbiAgcmV0dXJuIChcbiAgICAvLyBwYXJhbSBjaGFuZ2UgZm9yIHRoaXMgbWF0Y2gsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgIGN1cnJlbnRNYXRjaC5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHxcbiAgICAvLyBzcGxhdCBwYXJhbSBjaGFuZ2VkLCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiBtYXRjaC5wYXRoXG4gICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgKGN1cnJlbnRQYXRoICE9IG51bGwgJiZcbiAgICAgIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJlxuICAgICAgY3VycmVudE1hdGNoLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJldmFsaWRhdGVMb2FkZXIoXG4gIGxvYWRlck1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBhcmc6IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbkFyZ3Ncbikge1xuICBpZiAobG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgIGxldCByb3V0ZUNob2ljZSA9IGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoYXJnKTtcbiAgICBpZiAodHlwZW9mIHJvdXRlQ2hvaWNlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHJvdXRlQ2hvaWNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5cbi8qKlxuICogRXhlY3V0ZSByb3V0ZS5sYXp5KCkgbWV0aG9kcyB0byBsYXppbHkgbG9hZCByb3V0ZSBtb2R1bGVzIChsb2FkZXIsIGFjdGlvbixcbiAqIHNob3VsZFJldmFsaWRhdGUpIGFuZCB1cGRhdGUgdGhlIHJvdXRlTWFuaWZlc3QgaW4gcGxhY2Ugd2hpY2ggc2hhcmVzIG9iamVjdHNcbiAqIHdpdGggZGF0YVJvdXRlcyBzbyB0aG9zZSBnZXQgdXBkYXRlZCBhcyB3ZWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkTGF6eVJvdXRlTW9kdWxlKFxuICByb3V0ZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIG1hcFJvdXRlUHJvcGVydGllczogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24sXG4gIG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0XG4pIHtcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IHJvdXRlLmxhenkoKTtcblxuICAvLyBJZiB0aGUgbGF6eSByb3V0ZSBmdW5jdGlvbiB3YXMgZXhlY3V0ZWQgYW5kIHJlbW92ZWQgYnkgYW5vdGhlciBwYXJhbGxlbFxuICAvLyBjYWxsIHRoZW4gd2UgY2FuIHJldHVybiAtIGZpcnN0IGxhenkoKSB0byBmaW5pc2ggd2lucyBiZWNhdXNlIHRoZSByZXR1cm5cbiAgLy8gdmFsdWUgb2YgbGF6eSBpcyBleHBlY3RlZCB0byBiZSBzdGF0aWNcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XG4gIGludmFyaWFudChyb3V0ZVRvVXBkYXRlLCBcIk5vIHJvdXRlIGZvdW5kIGluIG1hbmlmZXN0XCIpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgcm91dGUgaW4gcGxhY2UuICBUaGlzIHNob3VsZCBiZSBzYWZlIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgLy8gd2UgY291bGQgeWV0IGJlIHNpdHRpbmcgb24gdGhpcyByb3V0ZSBhcyB3ZSBjYW4ndCBnZXQgdGhlcmUgd2l0aG91dFxuICAvLyByZXNvbHZpbmcgbGF6eSgpIGZpcnN0LlxuICAvL1xuICAvLyBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBITVIgXCJ1cGRhdGVcIiB1c2UtY2FzZSB3aGVyZSB3ZSBtYXkgYWN0aXZlbHkgYmVcbiAgLy8gb24gdGhlIHJvdXRlIGJlaW5nIHVwZGF0ZWQuICBUaGUgbWFpbiBjb25jZXJuIGJvaWxzIGRvd24gdG8gXCJkb2VzIHRoaXNcbiAgLy8gbXV0YXRpb24gYWZmZWN0IGFueSBvbmdvaW5nIG5hdmlnYXRpb25zIG9yIGFueSBjdXJyZW50IHN0YXRlLm1hdGNoZXNcbiAgLy8gdmFsdWVzP1wiLiAgSWYgbm90LCBpdCBzaG91bGQgYmUgc2FmZSB0byB1cGRhdGUgaW4gcGxhY2UuXG4gIGxldCByb3V0ZVVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPVxuICAgICAgcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eSBhcyBrZXlvZiB0eXBlb2Ygcm91dGVUb1VwZGF0ZV07XG5cbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID1cbiAgICAgIHN0YXRpY1JvdXRlVmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpc24ndCBzdGF0aWMgc2luY2UgaXQgc2hvdWxkIGFsd2F5cyBiZSB1cGRhdGVkIGJhc2VkXG4gICAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgICAgbGF6eVJvdXRlUHJvcGVydHkgIT09IFwiaGFzRXJyb3JCb3VuZGFyeVwiO1xuXG4gICAgd2FybmluZyhcbiAgICAgICFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQsXG4gICAgICBgUm91dGUgXCIke3JvdXRlVG9VcGRhdGUuaWR9XCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiBgICtcbiAgICAgICAgYGRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIGAgK1xuICAgICAgICBgVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIHdpbGwgYmUgaWdub3JlZC5gXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgICFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiZcbiAgICAgICFpbW11dGFibGVSb3V0ZUtleXMuaGFzKGxhenlSb3V0ZVByb3BlcnR5IGFzIEltbXV0YWJsZVJvdXRlS2V5KVxuICAgICkge1xuICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9XG4gICAgICAgIGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eSBhcyBrZXlvZiB0eXBlb2YgbGF6eVJvdXRlXTtcbiAgICB9XG4gIH1cblxuICAvLyBNdXRhdGUgdGhlIHJvdXRlIHdpdGggdGhlIHByb3ZpZGVkIHVwZGF0ZXMuICBEbyB0aGlzIGZpcnN0IHNvIHdlIHBhc3NcbiAgLy8gdGhlIHVwZGF0ZWQgdmVyc2lvbiB0byBtYXBSb3V0ZVByb3BlcnRpZXNcbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xuXG4gIC8vIE11dGF0ZSB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHByb3BlcnR5IG9uIHRoZSByb3V0ZSBiYXNlZCBvbiB0aGUgcm91dGVcbiAgLy8gdXBkYXRlcyBhbmQgcmVtb3ZlIHRoZSBgbGF6eWAgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzb2x2ZSB0aGUgbGF6eVxuICAvLyByb3V0ZSBhZ2Fpbi5cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCB7XG4gICAgLy8gVG8ga2VlcCB0aGluZ3MgZnJhbWV3b3JrIGFnbm9zdGljLCB3ZSB1c2UgdGhlIHByb3ZpZGVkXG4gICAgLy8gYG1hcFJvdXRlUHJvcGVydGllc2AgKG9yIHdyYXBwZWQgYGRldGVjdEVycm9yQm91bmRhcnlgKSBmdW5jdGlvbiB0b1xuICAgIC8vIHNldCB0aGUgZnJhbWV3b3JrLWF3YXJlIHByb3BlcnRpZXMgKGBlbGVtZW50YC9gaGFzRXJyb3JCb3VuZGFyeWApIHNpbmNlXG4gICAgLy8gdGhlIGxvZ2ljIHdpbGwgZGlmZmVyIGJldHdlZW4gZnJhbWV3b3Jrcy5cbiAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMocm91dGVUb1VwZGF0ZSksXG4gICAgbGF6eTogdW5kZWZpbmVkLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlck9yQWN0aW9uKFxuICB0eXBlOiBcImxvYWRlclwiIHwgXCJhY3Rpb25cIixcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QsXG4gIG1hcFJvdXRlUHJvcGVydGllczogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24sXG4gIGJhc2VuYW1lOiBzdHJpbmcsXG4gIG9wdHM6IHtcbiAgICBpc1N0YXRpY1JlcXVlc3Q/OiBib29sZWFuO1xuICAgIGlzUm91dGVSZXF1ZXN0PzogYm9vbGVhbjtcbiAgICByZXF1ZXN0Q29udGV4dD86IHVua25vd247XG4gIH0gPSB7fVxuKTogUHJvbWlzZTxEYXRhUmVzdWx0PiB7XG4gIGxldCByZXN1bHRUeXBlO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuICBsZXQgcnVuSGFuZGxlciA9IChoYW5kbGVyOiBBY3Rpb25GdW5jdGlvbiB8IExvYWRlckZ1bmN0aW9uKSA9PiB7XG4gICAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgICBsZXQgcmVqZWN0OiAoKSA9PiB2b2lkO1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gKHJlamVjdCA9IHIpKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICBoYW5kbGVyKHtcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIGNvbnRleHQ6IG9wdHMucmVxdWVzdENvbnRleHQsXG4gICAgICB9KSxcbiAgICAgIGFib3J0UHJvbWlzZSxcbiAgICBdKTtcbiAgfTtcblxuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG5cbiAgICBpZiAobWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgLy8gUnVuIHN0YXRpY2FsbHkgZGVmaW5lZCBoYW5kbGVyIGluIHBhcmFsbGVsIHdpdGggbGF6eSgpXG4gICAgICAgIGxldCBoYW5kbGVyRXJyb3I7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgICAgLy8gcm91dGUgaGFzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXJFcnJvciA9IGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgaGFuZGxlckVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExvYWQgbGF6eSByb3V0ZSBtb2R1bGUsIHRoZW4gcnVuIGFueSByZXR1cm5lZCBoYW5kbGVyXG4gICAgICAgIGF3YWl0IGxvYWRMYXp5Um91dGVNb2R1bGUobWF0Y2gucm91dGUsIG1hcFJvdXRlUHJvcGVydGllcywgbWFuaWZlc3QpO1xuXG4gICAgICAgIGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAvLyBIYW5kbGVyIHN0aWxsIHJ1biBldmVuIGlmIHdlIGdvdCBpbnRlcnJ1cHRlZCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXG4gICAgICAgICAgLy8gcHJldmlvdXNseS1sYXp5LWxvYWRlZCByb3V0ZXNcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGF6eSgpIHJvdXRlIGhhcyBubyBsb2FkZXIgdG8gcnVuLiAgU2hvcnQgY2lyY3VpdCBoZXJlIHNvIHdlIGRvbid0XG4gICAgICAgICAgLy8gaGl0IHRoZSBpbnZhcmlhbnQgYmVsb3cgdGhhdCBlcnJvcnMgb24gcmV0dXJuaW5nIHVuZGVmaW5lZC5cbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsIGRhdGE6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgcmVzdWx0ICE9PSB1bmRlZmluZWQsXG4gICAgICBgWW91IGRlZmluZWQgJHt0eXBlID09PSBcImFjdGlvblwiID8gXCJhbiBhY3Rpb25cIiA6IFwiYSBsb2FkZXJcIn0gZm9yIHJvdXRlIGAgK1xuICAgICAgICBgXCIke21hdGNoLnJvdXRlLmlkfVwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZyb20geW91ciBcXGAke3R5cGV9XFxgIGAgK1xuICAgICAgICBgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmBcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0VHlwZSA9IFJlc3VsdFR5cGUuZXJyb3I7XG4gICAgcmVzdWx0ID0gZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob25SZWplY3QpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuXG4gICAgLy8gUHJvY2VzcyByZWRpcmVjdHNcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMoc3RhdHVzKSkge1xuICAgICAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCJcbiAgICAgICk7XG5cbiAgICAgIC8vIFN1cHBvcnQgcmVsYXRpdmUgcm91dGluZyBpbiBpbnRlcm5hbCByZWRpcmVjdHNcbiAgICAgIGlmICghQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8oXG4gICAgICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICAgICAgbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmluZGV4T2YobWF0Y2gpICsgMSksXG4gICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBsb2NhdGlvblxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghb3B0cy5pc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIilcbiAgICAgICAgICA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIGxvY2F0aW9uKVxuICAgICAgICAgIDogbmV3IFVSTChsb2NhdGlvbik7XG4gICAgICAgIGxldCBpc1NhbWVCYXNlbmFtZSA9IHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgIT0gbnVsbDtcbiAgICAgICAgaWYgKHVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIGlzU2FtZUJhc2VuYW1lKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5yZWRpcmVjdCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0ZTogcmVzdWx0LmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpICE9PSBudWxsLFxuICAgICAgICByZWxvYWREb2N1bWVudDogcmVzdWx0LmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikgIT09IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZvciBTU1Igc2luZ2xlLXJvdXRlIHJlcXVlc3RzLCB3ZSB3YW50IHRvIGhhbmQgUmVzcG9uc2VzIGJhY2sgZGlyZWN0bHlcbiAgICAvLyB3aXRob3V0IHVud3JhcHBpbmcuICBXZSBkbyB0aGlzIHdpdGggdGhlIFF1ZXJ5Um91dGVSZXNwb25zZSB3cmFwcGVyXG4gICAgLy8gaW50ZXJmYWNlIHNvIHdlIGNhbiBrbm93IHdoZXRoZXIgaXQgd2FzIHJldHVybmVkIG9yIHRocm93blxuICAgIGlmIChvcHRzLmlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICBsZXQgcXVlcnlSb3V0ZVJlc3BvbnNlOiBRdWVyeVJvdXRlUmVzcG9uc2UgPSB7XG4gICAgICAgIHR5cGU6XG4gICAgICAgICAgcmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciA/IFJlc3VsdFR5cGUuZXJyb3IgOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICB9O1xuICAgICAgdGhyb3cgcXVlcnlSb3V0ZVJlc3BvbnNlO1xuICAgIH1cblxuICAgIGxldCBkYXRhOiBhbnk7XG4gICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIC8vIENoZWNrIGJldHdlZW4gd29yZCBib3VuZGFyaWVzIGluc3RlYWQgb2Ygc3RhcnRzV2l0aCgpIGR1ZSB0byB0aGUgbGFzdFxuICAgIC8vIHBhcmFncmFwaCBvZiBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI2ZpZWxkLmNvbnRlbnQtdHlwZVxuICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQudGV4dCgpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiByZXN1bHRUeXBlLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yUmVzcG9uc2VJbXBsKHN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEpLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgIGRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogcmVzdWx0VHlwZSwgZXJyb3I6IHJlc3VsdCB9O1xuICB9XG5cbiAgaWYgKGlzRGVmZXJyZWREYXRhKHJlc3VsdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZCxcbiAgICAgIGRlZmVycmVkRGF0YTogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LmluaXQ/LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzICYmIG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsIGRhdGE6IHJlc3VsdCB9O1xufVxuXG4vLyBVdGlsaXR5IG1ldGhvZCBmb3IgY3JlYXRpbmcgdGhlIFJlcXVlc3QgaW5zdGFuY2VzIGZvciBsb2FkZXJzL2FjdGlvbnMgZHVyaW5nXG4vLyBjbGllbnQtc2lkZSBuYXZpZ2F0aW9ucyBhbmQgZmV0Y2hlcy4gIER1cmluZyBTU1Igd2Ugd2lsbCBhbHdheXMgaGF2ZSBhXG4vLyBSZXF1ZXN0IGluc3RhbmNlIGZyb20gdGhlIHN0YXRpYyBoYW5kbGVyIChxdWVyeS9xdWVyeVJvdXRlKVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gIGhpc3Rvcnk6IEhpc3RvcnksXG4gIGxvY2F0aW9uOiBzdHJpbmcgfCBMb2NhdGlvbixcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb25cbik6IFJlcXVlc3Qge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdDogUmVxdWVzdEluaXQgPSB7IHNpZ25hbCB9O1xuXG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlIH0gPSBzdWJtaXNzaW9uO1xuICAgIC8vIERpZG4ndCB0aGluayB3ZSBuZWVkZWQgdGhpcyBidXQgaXQgdHVybnMgb3V0IHVubGlrZSBvdGhlciBtZXRob2RzLCBwYXRjaFxuICAgIC8vIHdvbid0IGJlIHByb3Blcmx5IG5vcm1hbGl6ZWQgdG8gdXBwZXJjYXNlIGFuZCByZXN1bHRzIGluIGEgNDA1IGVycm9yLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kXG4gICAgaW5pdC5tZXRob2QgPSBmb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlIH0pO1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoc3VibWlzc2lvbi5qc29uKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLnRleHQ7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICYmXG4gICAgICBzdWJtaXNzaW9uLmZvcm1EYXRhXG4gICAgKSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKHN1Ym1pc3Npb24uZm9ybURhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24uZm9ybURhdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhOiBGb3JtRGF0YSk6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2NvbnZlcnRpbmctYW4tZW50cnktbGlzdC10by1hLWxpc3Qtb2YtbmFtZS12YWx1ZS1wYWlyc1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IHZhbHVlLm5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cblxuZnVuY3Rpb24gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBGb3JtRGF0YSB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdIHwgbnVsbDtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbn0ge1xuICAvLyBGaWxsIGluIGxvYWRlckRhdGEvZXJyb3JzIGZyb20gb3VyIGxvYWRlcnNcbiAgbGV0IGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXSA9IHt9O1xuICBsZXQgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGwgPSBudWxsO1xuICBsZXQgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz4gPSB7fTtcblxuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSxcbiAgICAgIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCJcbiAgICApO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxuICAgICAgLy8gdGhhdCB0aHJvd3MgYSBsb2FkZXIgZXJyb3IsIGFuZCB0aGVuIGNsZWFyIGl0IG91dCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAvLyBpdCB3YXMgY29uc3VtZWRcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF07XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuXG4gICAgICAvLyBQcmVmZXIgaGlnaGVyIGVycm9yIHZhbHVlcyBpZiBsb3dlciBlcnJvcnMgYnViYmxlIHRvIHRoZSBzYW1lIGJvdW5kYXJ5XG4gICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID0gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIG91ciBhbnkgcHJpb3IgbG9hZGVyRGF0YSBmb3IgdGhlIHRocm93aW5nIHJvdXRlXG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgPyByZXN1bHQuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2V0KGlkLCByZXN1bHQuZGVmZXJyZWREYXRhKTtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJlxuICAgICAgICAhZm91bmRFcnJvclxuICAgICAgKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2UgZGlkbid0IGNvbnN1bWUgdGhlIHBlbmRpbmcgYWN0aW9uIGVycm9yIChpLmUuLCBhbGwgbG9hZGVyc1xuICAvLyByZXNvbHZlZCksIHRoZW4gY29uc3VtZSBpdCBoZXJlLiAgQWxzbyBjbGVhciBvdXQgYW55IGxvYWRlckRhdGEgZm9yIHRoZVxuICAvLyB0aHJvd2luZyByb3V0ZVxuICBpZiAocGVuZGluZ0Vycm9yKSB7XG4gICAgZXJyb3JzID0gcGVuZGluZ0Vycm9yO1xuICAgIGxvYWRlckRhdGFbT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICBmZXRjaGVyUmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn0ge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICBtYXRjaGVzVG9Mb2FkLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0Vycm9yLFxuICAgIGFjdGl2ZURlZmVycmVkc1xuICApO1xuXG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB7IGtleSwgbWF0Y2gsIGNvbnRyb2xsZXIgfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiXG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuXG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciBhYm9ydGVkIGZldGNoZXJzXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoPy5yb3V0ZS5pZCk7XG4gICAgICBpZiAoIShlcnJvcnMgJiYgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdKSkge1xuICAgICAgICBlcnJvcnMgPSB7XG4gICAgICAgICAgLi4uZXJyb3JzLFxuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgcmVkaXJlY3RzIHNob3VsZCBnZXQgcHJvY2Vzc2VkIGFib3ZlLCBidXQgd2VcbiAgICAgIC8vIGtlZXAgdGhpcyB0byB0eXBlIG5hcnJvdyB0byBhIHN1Y2Nlc3MgcmVzdWx0IGluIHRoZSBlbHNlXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGRlZmVycmVkIGRhdGEgc2hvdWxkIGJlIGF3YWl0ZWQgZm9yIGZldGNoZXJzXG4gICAgICAvLyBpbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGxvYWRlckRhdGEsIGVycm9ycyB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEoXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgbmV3TG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGVycm9yczogUm91dGVEYXRhIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogUm91dGVEYXRhIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSB7IC4uLm5ld0xvYWRlckRhdGEgfTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmIChuZXdMb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgaWYgKG5ld0xvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBuZXdMb2FkZXJEYXRhW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vLW9wIC0gdGhpcyBpcyBzbyB3ZSBpZ25vcmUgZXhpc3RpbmcgZGF0YSBpZiB3ZSBoYXZlIGEga2V5IGluIHRoZVxuICAgICAgICAvLyBpbmNvbWluZyBvYmplY3Qgd2l0aCBhbiB1bmRlZmluZWQgdmFsdWUsIHdoaWNoIGlzIGhvdyB3ZSB1bnNldCBhIHByaW9yXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaWYgd2UgZW5jb3VudGVyIGEgbG9hZGVyIGVycm9yXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgLy8gUHJlc2VydmUgZXhpc3Rpbmcga2V5cyBub3QgaW5jbHVkZWQgaW4gbmV3TG9hZGVyRGF0YSBhbmQgd2hlcmUgYSBsb2FkZXJcbiAgICAgIC8vIHdhc24ndCByZW1vdmVkIGJ5IEhNUlxuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIC8vIERvbid0IGtlZXAgYW55IGxvYWRlciBkYXRhIGJlbG93IHRoZSBib3VuZGFyeVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRMb2FkZXJEYXRhO1xufVxuXG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXG4vLyByb3V0ZSBzcGVjaWZpZWQgYnkgcm91dGVJZCkgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yIGJvdW5kYXJ5LFxuLy8gZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByb3V0ZUlkPzogc3RyaW5nXG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWRcbiAgICA/IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSlcbiAgICA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIChcbiAgICBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQoKG0pID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHxcbiAgICBtYXRjaGVzWzBdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdKToge1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG4gIHJvdXRlOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdDtcbn0ge1xuICAvLyBQcmVmZXIgYSByb290IGxheW91dCByb3V0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2Ugc2hpbSBpbiBhIHJvdXRlIG9iamVjdFxuICBsZXQgcm91dGUgPSByb3V0ZXMuZmluZCgocikgPT4gci5pbmRleCB8fCAhci5wYXRoIHx8IHIucGF0aCA9PT0gXCIvXCIpIHx8IHtcbiAgICBpZDogYF9fc2hpbS1lcnJvci1yb3V0ZV9fYCxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFtcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgIHBhdGhuYW1lQmFzZTogXCJcIixcbiAgICAgICAgcm91dGUsXG4gICAgICB9LFxuICAgIF0sXG4gICAgcm91dGUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsUm91dGVyRXJyb3IoXG4gIHN0YXR1czogbnVtYmVyLFxuICB7XG4gICAgcGF0aG5hbWUsXG4gICAgcm91dGVJZCxcbiAgICBtZXRob2QsXG4gICAgdHlwZSxcbiAgfToge1xuICAgIHBhdGhuYW1lPzogc3RyaW5nO1xuICAgIHJvdXRlSWQ/OiBzdHJpbmc7XG4gICAgbWV0aG9kPzogc3RyaW5nO1xuICAgIHR5cGU/OiBcImRlZmVyLWFjdGlvblwiIHwgXCJpbnZhbGlkLWJvZHlcIjtcbiAgfSA9IHt9XG4pIHtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcblxuICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJCYWQgUmVxdWVzdFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgYFlvdSBtYWRlIGEgJHttZXRob2R9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBgICtcbiAgICAgICAgYGRpZCBub3QgcHJvdmlkZSBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIGAgK1xuICAgICAgICBgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkZWZlci1hY3Rpb25cIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJkZWZlcigpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWN0aW9uc1wiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbnZhbGlkLWJvZHlcIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJVbmFibGUgdG8gZW5jb2RlIHN1Ym1pc3Npb24gYm9keVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgIHN0YXR1c1RleHQgPSBcIkZvcmJpZGRlblwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBtYXRjaCBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIHN0YXR1c1RleHQgPSBcIk5vdCBGb3VuZFwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBgWW91IG1hZGUgYSAke21ldGhvZC50b1VwcGVyQ2FzZSgpfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgYCArXG4gICAgICAgIGBkaWQgbm90IHByb3ZpZGUgYW4gXFxgYWN0aW9uXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgYCArXG4gICAgICAgIGBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHttZXRob2QudG9VcHBlckNhc2UoKX1cImA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICBzdGF0dXMgfHwgNTAwLFxuICAgIHN0YXR1c1RleHQsXG4gICAgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksXG4gICAgdHJ1ZVxuICApO1xufVxuXG4vLyBGaW5kIGFueSByZXR1cm5lZCByZWRpcmVjdCBlcnJvcnMsIHN0YXJ0aW5nIGZyb20gdGhlIGxvd2VzdCBtYXRjaFxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W11cbik6IHsgcmVzdWx0OiBSZWRpcmVjdFJlc3VsdDsgaWR4OiBudW1iZXIgfSB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHsgcmVzdWx0LCBpZHg6IGkgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBIYXNoRnJvbVBhdGgocGF0aDogVG8pIHtcbiAgbGV0IHBhcnNlZFBhdGggPSB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChwYXRoKSA6IHBhdGg7XG4gIHJldHVybiBjcmVhdGVQYXRoKHsgLi4ucGFyc2VkUGF0aCwgaGFzaDogXCJcIiB9KTtcbn1cblxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhOiBMb2NhdGlvbiwgYjogTG9jYXRpb24pOiBib29sZWFuIHtcbiAgaWYgKGEucGF0aG5hbWUgIT09IGIucGF0aG5hbWUgfHwgYS5zZWFyY2ggIT09IGIuc2VhcmNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuaGFzaCA9PT0gXCJcIikge1xuICAgIC8vIC9wYWdlIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gYi5oYXNoICE9PSBcIlwiO1xuICB9IGVsc2UgaWYgKGEuaGFzaCA9PT0gYi5oYXNoKSB7XG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNoYXNoXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYi5oYXNoICE9PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNvdGhlclxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSWYgdGhlIGhhc2ggaXMgcmVtb3ZlZCB0aGUgYnJvd3NlciB3aWxsIHJlLXBlcmZvcm0gYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIERlZmVycmVkUmVzdWx0IHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmRlZmVycmVkO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdDogRGF0YVJlc3VsdCk6IHJlc3VsdCBpcyBFcnJvclJlc3VsdCB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcjtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQ/OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIFJlZGlyZWN0UmVzdWx0IHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBSZXN1bHRUeXBlLnJlZGlyZWN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZlcnJlZERhdGEodmFsdWU6IGFueSk6IHZhbHVlIGlzIERlZmVycmVkRGF0YSB7XG4gIGxldCBkZWZlcnJlZDogRGVmZXJyZWREYXRhID0gdmFsdWU7XG4gIHJldHVybiAoXG4gICAgZGVmZXJyZWQgJiZcbiAgICB0eXBlb2YgZGVmZXJyZWQgPT09IFwib2JqZWN0XCIgJiZcbiAgICB0eXBlb2YgZGVmZXJyZWQuZGF0YSA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZC5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZC5jYW5jZWwgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZC5yZXNvbHZlRGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUmVzcG9uc2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlc3BvbnNlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmXG4gICAgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuYm9keSAhPT0gXCJ1bmRlZmluZWRcIlxuICApO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzdWx0OiBhbnkpOiByZXN1bHQgaXMgUmVzcG9uc2Uge1xuICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgcmV0dXJuIHN0YXR1cyA+PSAzMDAgJiYgc3RhdHVzIDw9IDM5OSAmJiBsb2NhdGlvbiAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1F1ZXJ5Um91dGVSZXNwb25zZShvYmo6IGFueSk6IG9iaiBpcyBRdWVyeVJvdXRlUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIG9iaiAmJlxuICAgIGlzUmVzcG9uc2Uob2JqLnJlc3BvbnNlKSAmJlxuICAgIChvYmoudHlwZSA9PT0gUmVzdWx0VHlwZS5kYXRhIHx8IG9iai50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZDogc3RyaW5nKTogbWV0aG9kIGlzIEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kIHtcbiAgcmV0dXJuIHZhbGlkUmVxdWVzdE1ldGhvZHMuaGFzKG1ldGhvZC50b0xvd2VyQ2FzZSgpIGFzIEZvcm1NZXRob2QpO1xufVxuXG5mdW5jdGlvbiBpc011dGF0aW9uTWV0aG9kKFxuICBtZXRob2Q6IHN0cmluZ1xuKTogbWV0aG9kIGlzIE11dGF0aW9uRm9ybU1ldGhvZCB8IFY3X011dGF0aW9uRm9ybU1ldGhvZCB7XG4gIHJldHVybiB2YWxpZE11dGF0aW9uTWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkgYXMgTXV0YXRpb25Gb3JtTWV0aG9kKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhcbiAgY3VycmVudE1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogKEFnbm9zdGljRGF0YVJvdXRlTWF0Y2ggfCBudWxsKVtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHNpZ25hbHM6IChBYm9ydFNpZ25hbCB8IG51bGwpW10sXG4gIGlzRmV0Y2hlcjogYm9vbGVhbixcbiAgY3VycmVudExvYWRlckRhdGE/OiBSb3V0ZURhdGFcbikge1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpbmRleF07XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hlc1RvTG9hZFtpbmRleF07XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoLCB0aGVuIHdlIGNhbiBoYXZlIGEgZGVmZXJyZWQgcmVzdWx0IHRvIGRvXG4gICAgLy8gYW55dGhpbmcgd2l0aC4gIFRoaXMgaXMgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVycyB3aGVyZSB0aGUgcm91dGUgd2FzXG4gICAgLy8gcmVtb3ZlZCBkdXJpbmcgSE1SXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRNYXRjaCA9IGN1cnJlbnRNYXRjaGVzLmZpbmQoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5pZCA9PT0gbWF0Y2ghLnJvdXRlLmlkXG4gICAgKTtcbiAgICBsZXQgaXNSZXZhbGlkYXRpbmdMb2FkZXIgPVxuICAgICAgY3VycmVudE1hdGNoICE9IG51bGwgJiZcbiAgICAgICFpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkgJiZcbiAgICAgIChjdXJyZW50TG9hZGVyRGF0YSAmJiBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0pICE9PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpICYmIChpc0ZldGNoZXIgfHwgaXNSZXZhbGlkYXRpbmdMb2FkZXIpKSB7XG4gICAgICAvLyBOb3RlOiB3ZSBkbyBub3QgaGF2ZSB0byB0b3VjaCBhY3RpdmVEZWZlcnJlZHMgaGVyZSBzaW5jZSB3ZSByYWNlIHRoZW1cbiAgICAgIC8vIGFnYWluc3QgdGhlIHNpZ25hbCBpbiByZXNvbHZlRGVmZXJyZWREYXRhIGFuZCB0aGV5J2xsIGdldCBhYm9ydGVkXG4gICAgICAvLyB0aGVyZSBpZiBuZWVkZWRcbiAgICAgIGxldCBzaWduYWwgPSBzaWduYWxzW2luZGV4XTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBcIkV4cGVjdGVkIGFuIEFib3J0U2lnbmFsIGZvciByZXZhbGlkYXRpbmcgZmV0Y2hlciBkZWZlcnJlZCByZXN1bHRcIlxuICAgICAgKTtcbiAgICAgIGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBzaWduYWwsIGlzRmV0Y2hlcikudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdCB8fCByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZERhdGEoXG4gIHJlc3VsdDogRGVmZXJyZWRSZXN1bHQsXG4gIHNpZ25hbDogQWJvcnRTaWduYWwsXG4gIHVud3JhcCA9IGZhbHNlXG4pOiBQcm9taXNlPFN1Y2Nlc3NSZXN1bHQgfCBFcnJvclJlc3VsdCB8IHVuZGVmaW5lZD4ge1xuICBsZXQgYWJvcnRlZCA9IGF3YWl0IHJlc3VsdC5kZWZlcnJlZERhdGEucmVzb2x2ZURhdGEoc2lnbmFsKTtcbiAgaWYgKGFib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodW53cmFwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS51bndyYXBwZWREYXRhLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBIYW5kbGUgYW55IFRyYWNrZWRQcm9taXNlLl9lcnJvciB2YWx1ZXMgZW5jb3VudGVyZWQgd2hpbGUgdW53cmFwcGluZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3I6IGUsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGxvY2F0aW9uOiBMb2NhdGlvbiB8IHN0cmluZ1xuKSB7XG4gIGxldCBzZWFyY2ggPVxuICAgIHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbikuc2VhcmNoIDogbG9jYXRpb24uc2VhcmNoO1xuICBpZiAoXG4gICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4ICYmXG4gICAgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKVxuICApIHtcbiAgICAvLyBSZXR1cm4gdGhlIGxlYWYgaW5kZXggcm91dGUgd2hlbiBpbmRleCBpcyBwcmVzZW50XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICAvLyBPdGhlcndpc2UgZ3JhYiB0aGUgZGVlcGVzdCBcInBhdGggY29udHJpYnV0aW5nXCIgbWF0Y2ggKGlnbm9yaW5nIGluZGV4IGFuZFxuICAvLyBwYXRobGVzcyBsYXlvdXQgcm91dGVzKVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24oXG4gIG5hdmlnYXRpb246IE5hdmlnYXRpb25cbik6IFN1Ym1pc3Npb24gfCB1bmRlZmluZWQge1xuICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgdGV4dCwgZm9ybURhdGEsIGpzb24gfSA9XG4gICAgbmF2aWdhdGlvbjtcbiAgaWYgKCFmb3JtTWV0aG9kIHx8ICFmb3JtQWN0aW9uIHx8ICFmb3JtRW5jVHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0LFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZm9ybURhdGEgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGEsXG4gICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGluZ05hdmlnYXRpb24oXG4gIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb25cbik6IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24oXG4gIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgc3VibWlzc2lvbjogU3VibWlzc2lvblxuKTogTmF2aWdhdGlvblN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0ge1xuICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0gPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGxvY2F0aW9uLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5cbmZ1bmN0aW9uIGdldExvYWRpbmdGZXRjaGVyKFxuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgZGF0YT86IEZldGNoZXJbXCJkYXRhXCJdXG4pOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICAgIGRhdGEsXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGEsXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nRmV0Y2hlcihcbiAgc3VibWlzc2lvbjogU3VibWlzc2lvbixcbiAgZXhpc3RpbmdGZXRjaGVyPzogRmV0Y2hlclxuKTogRmV0Y2hlclN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0ge1xuICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0gPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCxcbiAgfTtcbiAgcmV0dXJuIGZldGNoZXI7XG59XG5cbmZ1bmN0aW9uIGdldERvbmVGZXRjaGVyKGRhdGE6IEZldGNoZXJbXCJkYXRhXCJdKTogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0ge1xuICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgZGF0YSxcbiAgfTtcbiAgcmV0dXJuIGZldGNoZXI7XG59XG4vLyNlbmRyZWdpb25cbiJdLCJuYW1lcyI6WyJBY3Rpb24iLCJQb3BTdGF0ZUV2ZW50VHlwZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJvcHRpb25zIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJ2NUNvbXBhdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImluZGV4IiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsInVuZGVmaW5lZCIsImNsYW1wSW5kZXgiLCJsZW5ndGgiLCJhY3Rpb24iLCJQb3AiLCJsaXN0ZW5lciIsIm4iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwidG8iLCJrZXkiLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0ciIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfZXh0ZW5kcyIsIl9yZWYiLCJwYXJzZWRQYXRoIiwic2VhcmNoSW5kZXgiLCJnZXRMb2NhdGlvbiIsInZhbGlkYXRlTG9jYXRpb24iLCJkZWZhdWx0VmlldyIsImdldEluZGV4IiwicmVwbGFjZVN0YXRlIiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJET01FeGNlcHRpb24iLCJuYW1lIiwiYXNzaWduIiwib3JpZ2luIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZXN1bHRUeXBlIiwiaW1tdXRhYmxlUm91dGVLZXlzIiwiU2V0IiwiaXNJbmRleFJvdXRlIiwicm91dGUiLCJjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzIiwicm91dGVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsIm1hdGNoUm91dGVzIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsInN0cmlwQmFzZW5hbWUiLCJicmFuY2hlcyIsImZsYXR0ZW5Sb3V0ZXMiLCJyYW5rUm91dGVCcmFuY2hlcyIsIm1hdGNoZXMiLCJpIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInNhZmVseURlY29kZVVSSSIsImNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwibWF0Y2giLCJsb2FkZXJEYXRhIiwicGFyYW1zIiwiZGF0YSIsImhhbmRsZSIsInBhcmVudHNNZXRhIiwiZmxhdHRlblJvdXRlIiwicmVsYXRpdmVQYXRoIiwibWV0YSIsImNhc2VTZW5zaXRpdmUiLCJjaGlsZHJlbkluZGV4Iiwiam9pblBhdGhzIiwicm91dGVzTWV0YSIsImNvbmNhdCIsInNjb3JlIiwiY29tcHV0ZVNjb3JlIiwiZm9yRWFjaCIsIl9yb3V0ZSRwYXRoIiwiaW5jbHVkZXMiLCJleHBsb2RlZCIsImV4cGxvZGVPcHRpb25hbFNlZ21lbnRzIiwic2VnbWVudHMiLCJzcGxpdCIsImZpcnN0IiwicmVzdCIsImlzT3B0aW9uYWwiLCJlbmRzV2l0aCIsInJlcXVpcmVkIiwicmVzdEV4cGxvZGVkIiwicmVzdWx0Iiwic3VicGF0aCIsInNvcnQiLCJhIiwiYiIsImNvbXBhcmVJbmRleGVzIiwicGFyYW1SZSIsImR5bmFtaWNTZWdtZW50VmFsdWUiLCJpbmRleFJvdXRlVmFsdWUiLCJlbXB0eVNlZ21lbnRWYWx1ZSIsInN0YXRpY1NlZ21lbnRWYWx1ZSIsInNwbGF0UGVuYWx0eSIsImlzU3BsYXQiLCJzIiwiaW5pdGlhbFNjb3JlIiwic29tZSIsImZpbHRlciIsInJlZHVjZSIsInNlZ21lbnQiLCJ0ZXN0Iiwic2libGluZ3MiLCJldmVyeSIsImJyYW5jaCIsIm1hdGNoZWRQYXJhbXMiLCJtYXRjaGVkUGF0aG5hbWUiLCJlbmQiLCJyZW1haW5pbmdQYXRobmFtZSIsIm1hdGNoUGF0aCIsIk9iamVjdCIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwiZ2VuZXJhdGVQYXRoIiwib3JpZ2luYWxQYXRoIiwicHJlZml4IiwicCIsIlN0cmluZyIsImFycmF5IiwiaXNMYXN0U2VnbWVudCIsInN0YXIiLCJrZXlNYXRjaCIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwibWF0Y2hlciIsInBhcmFtTmFtZXMiLCJjb21waWxlUGF0aCIsImNhcHR1cmVHcm91cHMiLCJtZW1vIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInNhZmVseURlY29kZVVSSUNvbXBvbmVudCIsInJlZ2V4cFNvdXJjZSIsIl8iLCJSZWdFeHAiLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0SW5kZXgiLCJuZXh0Q2hhciIsInJlc29sdmVQYXRoIiwiZnJvbVBhdGhuYW1lIiwidG9QYXRobmFtZSIsInJlc29sdmVQYXRobmFtZSIsIm5vcm1hbGl6ZVNlYXJjaCIsIm5vcm1hbGl6ZUhhc2giLCJyZWxhdGl2ZVNlZ21lbnRzIiwicG9wIiwiZ2V0SW52YWxpZFBhdGhFcnJvciIsImNoYXIiLCJmaWVsZCIsImRlc3QiLCJnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJpbml0IiwicmVzcG9uc2VJbml0Iiwic3RhdHVzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJoYXMiLCJzZXQiLCJSZXNwb25zZSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiRGVmZXJyZWREYXRhIiwiY29uc3RydWN0b3IiLCJwZW5kaW5nS2V5c1NldCIsInN1YnNjcmliZXJzIiwiZGVmZXJyZWRLZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwicmVqZWN0IiwiYWJvcnRQcm9taXNlIiwiUHJvbWlzZSIsInIiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25BYm9ydCIsInVubGlzdGVuQWJvcnRTaWduYWwiLCJzaWduYWwiLCJhY2MiLCJ0cmFja1Byb21pc2UiLCJkb25lIiwiYWRkIiwicHJvbWlzZSIsInJhY2UiLCJ0aGVuIiwib25TZXR0bGUiLCJjYXRjaCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYWJvcnRlZCIsImRlbGV0ZSIsInVuZGVmaW5lZEVycm9yIiwiZW1pdCIsInNldHRsZWRLZXkiLCJzdWJzY3JpYmVyIiwic3Vic2NyaWJlIiwiY2FuY2VsIiwiYWJvcnQiLCJ2IiwiayIsInJlc29sdmVEYXRhIiwicmVzb2x2ZSIsInNpemUiLCJ1bndyYXBwZWREYXRhIiwiX3JlZjIiLCJ1bndyYXBUcmFja2VkUHJvbWlzZSIsInBlbmRpbmdLZXlzIiwiaXNUcmFja2VkUHJvbWlzZSIsIl90cmFja2VkIiwiX2Vycm9yIiwiX2RhdGEiLCJkZWZlciIsInJlZGlyZWN0IiwicmVkaXJlY3REb2N1bWVudCIsInJlc3BvbnNlIiwiRXJyb3JSZXNwb25zZUltcGwiLCJzdGF0dXNUZXh0IiwiaW50ZXJuYWwiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsInZhbGlkTXV0YXRpb25NZXRob2RzQXJyIiwidmFsaWRNdXRhdGlvbk1ldGhvZHMiLCJ2YWxpZFJlcXVlc3RNZXRob2RzQXJyIiwidmFsaWRSZXF1ZXN0TWV0aG9kcyIsInJlZGlyZWN0U3RhdHVzQ29kZXMiLCJyZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMiLCJJRExFX05BVklHQVRJT04iLCJmb3JtTWV0aG9kIiwiZm9ybUFjdGlvbiIsImZvcm1FbmNUeXBlIiwiZm9ybURhdGEiLCJ0ZXh0IiwiSURMRV9GRVRDSEVSIiwiSURMRV9CTE9DS0VSIiwicHJvY2VlZCIsInJlc2V0IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyIsImhhc0Vycm9yQm91bmRhcnkiLCJCb29sZWFuIiwiY3JlYXRlUm91dGVyIiwicm91dGVyV2luZG93IiwiaXNCcm93c2VyIiwiY3JlYXRlRWxlbWVudCIsImlzU2VydmVyIiwiZGV0ZWN0RXJyb3JCb3VuZGFyeSIsImRhdGFSb3V0ZXMiLCJpbkZsaWdodERhdGFSb3V0ZXMiLCJmdXR1cmUiLCJ2N19ub3JtYWxpemVGb3JtTWV0aG9kIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwidW5saXN0ZW5IaXN0b3J5Iiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJnZXRTY3JvbGxSZXN0b3JhdGlvbktleSIsImdldFNjcm9sbFBvc2l0aW9uIiwiaW5pdGlhbFNjcm9sbFJlc3RvcmVkIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxNYXRjaGVzIiwiaW5pdGlhbEVycm9ycyIsImdldEludGVybmFsUm91dGVyRXJyb3IiLCJnZXRTaG9ydENpcmN1aXRNYXRjaGVzIiwiaW5pdGlhbGl6ZWQiLCJtIiwibGF6eSIsImxvYWRlciIsInJvdXRlciIsImhpc3RvcnlBY3Rpb24iLCJuYXZpZ2F0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwicHJldmVudFNjcm9sbFJlc2V0IiwicmV2YWxpZGF0aW9uIiwiYWN0aW9uRGF0YSIsImVycm9ycyIsImZldGNoZXJzIiwiTWFwIiwiYmxvY2tlcnMiLCJwZW5kaW5nQWN0aW9uIiwicGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCIsInBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciIsImlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsImlzUmV2YWxpZGF0aW9uUmVxdWlyZWQiLCJjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyIsImNhbmNlbGxlZEZldGNoZXJMb2FkcyIsImZldGNoQ29udHJvbGxlcnMiLCJpbmNyZW1lbnRpbmdMb2FkSWQiLCJwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCIsImZldGNoUmVsb2FkSWRzIiwiZmV0Y2hSZWRpcmVjdElkcyIsImZldGNoTG9hZE1hdGNoZXMiLCJhY3RpdmVEZWZlcnJlZHMiLCJibG9ja2VyRnVuY3Rpb25zIiwiaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUiLCJpbml0aWFsaXplIiwiYmxvY2tlcktleSIsInNob3VsZEJsb2NrTmF2aWdhdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsInVwZGF0ZUJsb2NrZXIiLCJ1cGRhdGVTdGF0ZSIsInN0YXJ0TmF2aWdhdGlvbiIsImRpc3Bvc2UiLCJjbGVhciIsImRlbGV0ZUZldGNoZXIiLCJkZWxldGVCbG9ja2VyIiwibmV3U3RhdGUiLCJjb21wbGV0ZU5hdmlnYXRpb24iLCJfbG9jYXRpb24kc3RhdGUiLCJfbG9jYXRpb24kc3RhdGUyIiwiaXNBY3Rpb25SZWxvYWQiLCJpc011dGF0aW9uTWV0aG9kIiwiX2lzUmVkaXJlY3QiLCJrZXlzIiwibWVyZ2VMb2FkZXJEYXRhIiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsIm5hdmlnYXRlIiwib3B0cyIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplVG8iLCJmcm9tUm91dGVJZCIsInJlbGF0aXZlIiwic3VibWlzc2lvbiIsIm5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyIsInVzZXJSZXBsYWNlIiwicGVuZGluZ0Vycm9yIiwicmV2YWxpZGF0ZSIsImludGVycnVwdEFjdGl2ZUxvYWRzIiwic3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwib3ZlcnJpZGVOYXZpZ2F0aW9uIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwicm91dGVzVG9Vc2UiLCJsb2FkaW5nTmF2aWdhdGlvbiIsIm5vdEZvdW5kTWF0Y2hlcyIsImNhbmNlbEFjdGl2ZURlZmVycmVkcyIsImlzSGFzaENoYW5nZU9ubHkiLCJyZXF1ZXN0IiwiY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QiLCJwZW5kaW5nQWN0aW9uRGF0YSIsImZpbmROZWFyZXN0Qm91bmRhcnkiLCJhY3Rpb25PdXRwdXQiLCJoYW5kbGVBY3Rpb24iLCJzaG9ydENpcmN1aXRlZCIsInBlbmRpbmdBY3Rpb25FcnJvciIsImdldExvYWRpbmdOYXZpZ2F0aW9uIiwiUmVxdWVzdCIsImhhbmRsZUxvYWRlcnMiLCJmZXRjaGVyU3VibWlzc2lvbiIsImdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uIiwiYWN0aW9uTWF0Y2giLCJnZXRUYXJnZXRNYXRjaCIsInR5cGUiLCJtZXRob2QiLCJyb3V0ZUlkIiwiY2FsbExvYWRlck9yQWN0aW9uIiwiaXNSZWRpcmVjdFJlc3VsdCIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiaXNFcnJvclJlc3VsdCIsImJvdW5kYXJ5TWF0Y2giLCJpc0RlZmVycmVkUmVzdWx0IiwiYWN0aXZlU3VibWlzc2lvbiIsImdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbiIsIm1hdGNoZXNUb0xvYWQiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJ1cGRhdGVkRmV0Y2hlcnMiLCJtYXJrRmV0Y2hSZWRpcmVjdHNEb25lIiwicmYiLCJmZXRjaGVyIiwicmV2YWxpZGF0aW5nRmV0Y2hlciIsImdldExvYWRpbmdGZXRjaGVyIiwiYWJvcnRGZXRjaGVyIiwiYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zIiwiZiIsInJlc3VsdHMiLCJsb2FkZXJSZXN1bHRzIiwiZmV0Y2hlclJlc3VsdHMiLCJjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEiLCJmaW5kUmVkaXJlY3QiLCJmZXRjaGVyS2V5IiwicHJvY2Vzc0xvYWRlckRhdGEiLCJkZWZlcnJlZERhdGEiLCJkaWRBYm9ydEZldGNoTG9hZHMiLCJhYm9ydFN0YWxlRmV0Y2hMb2FkcyIsInNob3VsZFVwZGF0ZUZldGNoZXJzIiwiZ2V0RmV0Y2hlciIsImZldGNoIiwic2V0RmV0Y2hlckVycm9yIiwiaGFuZGxlRmV0Y2hlckFjdGlvbiIsImhhbmRsZUZldGNoZXJMb2FkZXIiLCJyZXF1ZXN0TWF0Y2hlcyIsImV4aXN0aW5nRmV0Y2hlciIsImdldFN1Ym1pdHRpbmdGZXRjaGVyIiwiYWJvcnRDb250cm9sbGVyIiwiZmV0Y2hSZXF1ZXN0Iiwib3JpZ2luYXRpbmdMb2FkSWQiLCJhY3Rpb25SZXN1bHQiLCJkb25lRmV0Y2hlciIsImdldERvbmVGZXRjaGVyIiwibG9hZGluZ0ZldGNoZXIiLCJyZXZhbGlkYXRpb25SZXF1ZXN0IiwibG9hZElkIiwibG9hZEZldGNoZXIiLCJzdGFsZUtleSIsInJlc29sdmVEZWZlcnJlZERhdGEiLCJfdGVtcCIsInJlZGlyZWN0TG9jYXRpb24iLCJpc0RvY3VtZW50UmVsb2FkIiwicmVsb2FkRG9jdW1lbnQiLCJyZWRpcmVjdEhpc3RvcnlBY3Rpb24iLCJjdXJyZW50TWF0Y2hlcyIsImZldGNoZXJzVG9Mb2FkIiwiYWxsIiwicmVzb2x2ZURlZmVycmVkUmVzdWx0cyIsIm1hcmtGZXRjaGVyc0RvbmUiLCJkb25lS2V5cyIsImxhbmRlZElkIiwieWVldGVkS2V5cyIsImdldEJsb2NrZXIiLCJibG9ja2VyIiwibmV3QmxvY2tlciIsImJsb2NrZXJGdW5jdGlvbiIsInByZWRpY2F0ZSIsImNhbmNlbGxlZFJvdXRlSWRzIiwiZGZkIiwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsImdldEtleSIsInkiLCJnZXRTY3JvbGxLZXkiLCJfaW50ZXJuYWxTZXRSb3V0ZXMiLCJuZXdSb3V0ZXMiLCJfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzIiwiX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzIiwiVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCIsIlN5bWJvbCIsImNyZWF0ZVN0YXRpY0hhbmRsZXIiLCJxdWVyeSIsIl90ZW1wMiIsInJlcXVlc3RDb250ZXh0IiwiaXNWYWxpZE1ldGhvZCIsIm1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzIiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwicXVlcnlJbXBsIiwiaXNSZXNwb25zZSIsInF1ZXJ5Um91dGUiLCJfdGVtcDMiLCJmaW5kIiwidmFsdWVzIiwiX3Jlc3VsdCRhY3RpdmVEZWZlcnJlIiwicm91dGVNYXRjaCIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc1F1ZXJ5Um91dGVSZXNwb25zZSIsImlzUmVkaXJlY3RSZXNwb25zZSIsImlzUm91dGVSZXF1ZXN0IiwiaXNTdGF0aWNSZXF1ZXN0IiwiTG9jYXRpb24iLCJjb250ZXh0IiwibG9hZGVyUmVxdWVzdCIsImdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5IiwicHJvY2Vzc1JvdXRlTG9hZGVyRGF0YSIsImV4ZWN1dGVkTG9hZGVycyIsImZyb21FbnRyaWVzIiwiZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciIsIm5ld0NvbnRleHQiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsImlzU3VibWlzc2lvbk5hdmlnYXRpb24iLCJib2R5IiwicHJlcGVuZEJhc2VuYW1lIiwiY29udGV4dHVhbE1hdGNoZXMiLCJhY3RpdmVSb3V0ZU1hdGNoIiwiaGFzTmFrZWRJbmRleFF1ZXJ5Iiwibm9ybWFsaXplRm9ybU1ldGhvZCIsImlzRmV0Y2hlciIsImdldEludmFsaWRCb2R5RXJyb3IiLCJyYXdGb3JtTWV0aG9kIiwidG9VcHBlckNhc2UiLCJzdHJpcEhhc2hGcm9tUGF0aCIsIkZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiX3JlZjMiLCJwYXJzZSIsInNlYXJjaFBhcmFtcyIsImNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zIiwiY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEiLCJhcHBlbmQiLCJib3VuZGFyeUlkIiwiYm91bmRhcnlNYXRjaGVzIiwiZmluZEluZGV4IiwiY3VycmVudFVybCIsIm5leHRVcmwiLCJuYXZpZ2F0aW9uTWF0Y2hlcyIsImlzTmV3TG9hZGVyIiwiY3VycmVudFJvdXRlTWF0Y2giLCJuZXh0Um91dGVNYXRjaCIsInNob3VsZFJldmFsaWRhdGVMb2FkZXIiLCJjdXJyZW50UGFyYW1zIiwibmV4dFBhcmFtcyIsImRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIiwiaXNOZXdSb3V0ZUluc3RhbmNlIiwiZmV0Y2hlck1hdGNoZXMiLCJmZXRjaGVyTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlIiwiY3VycmVudExvYWRlckRhdGEiLCJjdXJyZW50TWF0Y2giLCJpc05ldyIsImlzTWlzc2luZ0RhdGEiLCJjdXJyZW50UGF0aCIsImxvYWRlck1hdGNoIiwiYXJnIiwicm91dGVDaG9pY2UiLCJsb2FkTGF6eVJvdXRlTW9kdWxlIiwibGF6eVJvdXRlIiwicm91dGVUb1VwZGF0ZSIsInJvdXRlVXBkYXRlcyIsImxhenlSb3V0ZVByb3BlcnR5Iiwic3RhdGljUm91dGVWYWx1ZSIsImlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCIsInJlc3VsdFR5cGUiLCJvblJlamVjdCIsInJ1bkhhbmRsZXIiLCJoYW5kbGVyIiwiaGFuZGxlckVycm9yIiwicHJvdG9jb2wiLCJpc1NhbWVCYXNlbmFtZSIsInF1ZXJ5Um91dGVSZXNwb25zZSIsImNvbnRlbnRUeXBlIiwiaXNEZWZlcnJlZERhdGEiLCJfcmVzdWx0JGluaXQiLCJfcmVzdWx0JGluaXQyIiwiZGVmZXJyZWQiLCJmb3VuZEVycm9yIiwibmV3TG9hZGVyRGF0YSIsIm1lcmdlZExvYWRlckRhdGEiLCJoYXNPd25Qcm9wZXJ0eSIsImVsaWdpYmxlTWF0Y2hlcyIsInJldmVyc2UiLCJfdGVtcDQiLCJlcnJvck1lc3NhZ2UiLCJvYmoiLCJzaWduYWxzIiwiaXNSZXZhbGlkYXRpbmdMb2FkZXIiLCJ1bndyYXAiLCJnZXRBbGwiLCJwYXRoTWF0Y2hlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1300\n')},6598:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  P1: () => (/* binding */ createSelector)\n});\n\n// UNUSED EXPORTS: createSelectorCreator, createStructuredSelector, defaultEqualityCheck, defaultMemoize\n\n;// CONCATENATED MODULE: ./node_modules/reselect/es/defaultMemoize.js\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = 'NOT_FOUND';\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    } // No entry found in cache, return sentinel\n\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n    var length = prev.length;\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nfunction defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n    equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n    _providedOptions$maxS = providedOptions.maxSize,\n    maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n    resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n        if (matchingEntry) {\n          value = matchingEntry.value;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n  return memoized;\n}\n;// CONCATENATED MODULE: ./node_modules/reselect/es/index.js\n\n\nfunction getDependencies(funcs) {\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n  if (!dependencies.every(function (dep) {\n    return typeof dep === 'function';\n  })) {\n    var dependencyTypes = dependencies.map(function (dep) {\n      return typeof dep === 'function' ? \"function \" + (dep.name || 'unnamed') + \"()\" : typeof dep;\n    }).join(', ');\n    throw new Error(\"createSelector expects all input-selectors to be functions, but received the following types: [\" + dependencyTypes + \"]\");\n  }\n  return dependencies;\n}\nfunction createSelectorCreator(memoize) {\n  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    memoizeOptionsFromArgs[_key - 1] = arguments[_key];\n  }\n  var createSelector = function createSelector() {\n    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      funcs[_key2] = arguments[_key2];\n    }\n    var _recomputations = 0;\n    var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.\n    // So, start by declaring the default value here.\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n\n    var directlyPassedOptions = {\n      memoizeOptions: undefined\n    }; // Normally, the result func or \"output selector\" is the last arg\n\n    var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object\n\n    if (typeof resultFunc === 'object') {\n      directlyPassedOptions = resultFunc; // and pop the real result func off\n\n      resultFunc = funcs.pop();\n    }\n    if (typeof resultFunc !== 'function') {\n      throw new Error(\"createSelector expects an output function after the inputs, but received: [\" + typeof resultFunc + \"]\");\n    } // Determine which set of options we're using. Prefer options passed directly,\n    // but fall back to options given to createSelectorCreator.\n\n    var _directlyPassedOption = directlyPassedOptions,\n      _directlyPassedOption2 = _directlyPassedOption.memoizeOptions,\n      memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n    // is an array. In most libs I've looked at, it's an equality function or options object.\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n    // we wrap it in an array so we can apply it.\n\n    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];\n    var dependencies = getDependencies(funcs);\n    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {\n      _recomputations++; // apply arguments instead of spreading for performance.\n\n      return resultFunc.apply(null, arguments);\n    }].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n\n    var selector = memoize(function dependenciesChecker() {\n      var params = [];\n      var length = dependencies.length;\n      for (var i = 0; i < length; i++) {\n        // apply arguments instead of spreading and mutate a local list of params for performance.\n        // @ts-ignore\n        params.push(dependencies[i].apply(null, arguments));\n      } // apply arguments instead of spreading for performance.\n\n      _lastResult = memoizedResultFunc.apply(null, params);\n      return _lastResult;\n    });\n    Object.assign(selector, {\n      resultFunc: resultFunc,\n      memoizedResultFunc: memoizedResultFunc,\n      dependencies: dependencies,\n      lastResult: function lastResult() {\n        return _lastResult;\n      },\n      recomputations: function recomputations() {\n        return _recomputations;\n      },\n      resetRecomputations: function resetRecomputations() {\n        return _recomputations = 0;\n      }\n    });\n    return selector;\n  }; // @ts-ignore\n\n  return createSelector;\n}\nvar createSelector = /* #__PURE__ */createSelectorCreator(defaultMemoize);\n// Manual definition of state and output arguments\nvar createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {\n  if (selectorCreator === void 0) {\n    selectorCreator = createSelector;\n  }\n  if (typeof selectors !== 'object') {\n    throw new Error('createStructuredSelector expects first argument to be an object ' + (\"where each property is a selector, instead received a \" + typeof selectors));\n  }\n  var objectKeys = Object.keys(selectors);\n  var resultSelector = selectorCreator(\n  // @ts-ignore\n  objectKeys.map(function (key) {\n    return selectors[key];\n  }), function () {\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n    return values.reduce(function (composition, value, index) {\n      composition[objectKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n  return resultSelector;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU5OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsSUFBSUEsU0FBUyxHQUFHLFdBQVc7QUFFM0IsU0FBU0Msb0JBQW9CQSxDQUFDQyxNQUFNLEVBQUU7RUFDcEMsSUFBSUMsS0FBSztFQUNULE9BQU87SUFDTEMsR0FBRyxFQUFFLFNBQVNBLEdBQUdBLENBQUNDLEdBQUcsRUFBRTtNQUNyQixJQUFJRixLQUFLLElBQUlELE1BQU0sQ0FBQ0MsS0FBSyxDQUFDRSxHQUFHLEVBQUVBLEdBQUcsQ0FBQyxFQUFFO1FBQ25DLE9BQU9GLEtBQUssQ0FBQ0csS0FBSztNQUNwQjtNQUVBLE9BQU9OLFNBQVM7SUFDbEIsQ0FBQztJQUNETyxHQUFHLEVBQUUsU0FBU0EsR0FBR0EsQ0FBQ0YsR0FBRyxFQUFFQyxLQUFLLEVBQUU7TUFDNUJILEtBQUssR0FBRztRQUNORSxHQUFHLEVBQUVBLEdBQUc7UUFDUkMsS0FBSyxFQUFFQTtNQUNULENBQUM7SUFDSCxDQUFDO0lBQ0RFLFVBQVUsRUFBRSxTQUFTQSxVQUFVQSxDQUFBLEVBQUc7TUFDaEMsT0FBT0wsS0FBSyxHQUFHLENBQUNBLEtBQUssQ0FBQyxHQUFHLEVBQUU7SUFDN0IsQ0FBQztJQUNETSxLQUFLLEVBQUUsU0FBU0EsS0FBS0EsQ0FBQSxFQUFHO01BQ3RCTixLQUFLLEdBQUdPLFNBQVM7SUFDbkI7RUFDRixDQUFDO0FBQ0g7QUFFQSxTQUFTQyxjQUFjQSxDQUFDQyxPQUFPLEVBQUVWLE1BQU0sRUFBRTtFQUN2QyxJQUFJVyxPQUFPLEdBQUcsRUFBRTtFQUVoQixTQUFTVCxHQUFHQSxDQUFDQyxHQUFHLEVBQUU7SUFDaEIsSUFBSVMsVUFBVSxHQUFHRCxPQUFPLENBQUNFLFNBQVMsQ0FBQyxVQUFVWixLQUFLLEVBQUU7TUFDbEQsT0FBT0QsTUFBTSxDQUFDRyxHQUFHLEVBQUVGLEtBQUssQ0FBQ0UsR0FBRyxDQUFDO0lBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBRUosSUFBSVMsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFO01BQ25CLElBQUlYLEtBQUssR0FBR1UsT0FBTyxDQUFDQyxVQUFVLENBQUMsQ0FBQyxDQUFDOztNQUVqQyxJQUFJQSxVQUFVLEdBQUcsQ0FBQyxFQUFFO1FBQ2xCRCxPQUFPLENBQUNHLE1BQU0sQ0FBQ0YsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUM3QkQsT0FBTyxDQUFDSSxPQUFPLENBQUNkLEtBQUssQ0FBQztNQUN4QjtNQUVBLE9BQU9BLEtBQUssQ0FBQ0csS0FBSztJQUNwQixDQUFDLENBQUM7O0lBR0YsT0FBT04sU0FBUztFQUNsQjtFQUVBLFNBQVNPLEdBQUdBLENBQUNGLEdBQUcsRUFBRUMsS0FBSyxFQUFFO0lBQ3ZCLElBQUlGLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDLEtBQUtMLFNBQVMsRUFBRTtNQUMxQjtNQUNBYSxPQUFPLENBQUNJLE9BQU8sQ0FBQztRQUNkWixHQUFHLEVBQUVBLEdBQUc7UUFDUkMsS0FBSyxFQUFFQTtNQUNULENBQUMsQ0FBQztNQUVGLElBQUlPLE9BQU8sQ0FBQ0ssTUFBTSxHQUFHTixPQUFPLEVBQUU7UUFDNUJDLE9BQU8sQ0FBQ00sR0FBRyxDQUFDLENBQUM7TUFDZjtJQUNGO0VBQ0Y7RUFFQSxTQUFTWCxVQUFVQSxDQUFBLEVBQUc7SUFDcEIsT0FBT0ssT0FBTztFQUNoQjtFQUVBLFNBQVNKLEtBQUtBLENBQUEsRUFBRztJQUNmSSxPQUFPLEdBQUcsRUFBRTtFQUNkO0VBRUEsT0FBTztJQUNMVCxHQUFHLEVBQUVBLEdBQUc7SUFDUkcsR0FBRyxFQUFFQSxHQUFHO0lBQ1JDLFVBQVUsRUFBRUEsVUFBVTtJQUN0QkMsS0FBSyxFQUFFQTtFQUNULENBQUM7QUFDSDtBQUVPLElBQUlXLG9CQUFvQixHQUFHLFNBQVNBLG9CQUFvQkEsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7RUFDcEUsT0FBT0QsQ0FBQyxLQUFLQyxDQUFDO0FBQ2hCLENBQUM7QUFDTSxTQUFTQyx3QkFBd0JBLENBQUNDLGFBQWEsRUFBRTtFQUN0RCxPQUFPLFNBQVNDLDBCQUEwQkEsQ0FBQ0MsSUFBSSxFQUFFQyxJQUFJLEVBQUU7SUFDckQsSUFBSUQsSUFBSSxLQUFLLElBQUksSUFBSUMsSUFBSSxLQUFLLElBQUksSUFBSUQsSUFBSSxDQUFDUixNQUFNLEtBQUtTLElBQUksQ0FBQ1QsTUFBTSxFQUFFO01BQ2pFLE9BQU8sS0FBSztJQUNkLENBQUMsQ0FBQzs7SUFHRixJQUFJQSxNQUFNLEdBQUdRLElBQUksQ0FBQ1IsTUFBTTtJQUV4QixLQUFLLElBQUlVLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR1YsTUFBTSxFQUFFVSxDQUFDLEVBQUUsRUFBRTtNQUMvQixJQUFJLENBQUNKLGFBQWEsQ0FBQ0UsSUFBSSxDQUFDRSxDQUFDLENBQUMsRUFBRUQsSUFBSSxDQUFDQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3BDLE9BQU8sS0FBSztNQUNkO0lBQ0Y7SUFFQSxPQUFPLElBQUk7RUFDYixDQUFDO0FBQ0g7QUFDQTtBQUNBO0FBQ08sU0FBU0MsY0FBY0EsQ0FBQ0MsSUFBSSxFQUFFQyxzQkFBc0IsRUFBRTtFQUMzRCxJQUFJQyxlQUFlLEdBQUcsT0FBT0Qsc0JBQXNCLEtBQUssUUFBUSxHQUFHQSxzQkFBc0IsR0FBRztJQUMxRlAsYUFBYSxFQUFFTztFQUNqQixDQUFDO0VBQ0QsSUFBSUUscUJBQXFCLEdBQUdELGVBQWUsQ0FBQ1IsYUFBYTtJQUNyREEsYUFBYSxHQUFHUyxxQkFBcUIsS0FBSyxLQUFLLENBQUMsR0FBR2Isb0JBQW9CLEdBQUdhLHFCQUFxQjtJQUMvRkMscUJBQXFCLEdBQUdGLGVBQWUsQ0FBQ3BCLE9BQU87SUFDL0NBLE9BQU8sR0FBR3NCLHFCQUFxQixLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBR0EscUJBQXFCO0lBQ3RFQyxtQkFBbUIsR0FBR0gsZUFBZSxDQUFDRyxtQkFBbUI7RUFDN0QsSUFBSUMsVUFBVSxHQUFHYix3QkFBd0IsQ0FBQ0MsYUFBYSxDQUFDO0VBQ3hELElBQUlhLEtBQUssR0FBR3pCLE9BQU8sS0FBSyxDQUFDLEdBQUdYLG9CQUFvQixDQUFDbUMsVUFBVSxDQUFDLEdBQUd6QixjQUFjLENBQUNDLE9BQU8sRUFBRXdCLFVBQVUsQ0FBQyxDQUFDLENBQUM7O0VBRXBHLFNBQVNFLFFBQVFBLENBQUEsRUFBRztJQUNsQixJQUFJaEMsS0FBSyxHQUFHK0IsS0FBSyxDQUFDakMsR0FBRyxDQUFDbUMsU0FBUyxDQUFDO0lBRWhDLElBQUlqQyxLQUFLLEtBQUtOLFNBQVMsRUFBRTtNQUN2QjtNQUNBTSxLQUFLLEdBQUd3QixJQUFJLENBQUNVLEtBQUssQ0FBQyxJQUFJLEVBQUVELFNBQVMsQ0FBQztNQUVuQyxJQUFJSixtQkFBbUIsRUFBRTtRQUN2QixJQUFJdEIsT0FBTyxHQUFHd0IsS0FBSyxDQUFDN0IsVUFBVSxDQUFDLENBQUM7UUFDaEMsSUFBSWlDLGFBQWEsR0FBRzVCLE9BQU8sQ0FBQzZCLElBQUksQ0FBQyxVQUFVdkMsS0FBSyxFQUFFO1VBQ2hELE9BQU9nQyxtQkFBbUIsQ0FBQ2hDLEtBQUssQ0FBQ0csS0FBSyxFQUFFQSxLQUFLLENBQUM7UUFDaEQsQ0FBQyxDQUFDO1FBRUYsSUFBSW1DLGFBQWEsRUFBRTtVQUNqQm5DLEtBQUssR0FBR21DLGFBQWEsQ0FBQ25DLEtBQUs7UUFDN0I7TUFDRjtNQUVBK0IsS0FBSyxDQUFDOUIsR0FBRyxDQUFDZ0MsU0FBUyxFQUFFakMsS0FBSyxDQUFDO0lBQzdCO0lBRUEsT0FBT0EsS0FBSztFQUNkO0VBRUFnQyxRQUFRLENBQUNLLFVBQVUsR0FBRyxZQUFZO0lBQ2hDLE9BQU9OLEtBQUssQ0FBQzVCLEtBQUssQ0FBQyxDQUFDO0VBQ3RCLENBQUM7RUFFRCxPQUFPNkIsUUFBUTtBQUNqQixDOztBQ2xKd0U7QUFDeEI7QUFFaEQsU0FBU00sZUFBZUEsQ0FBQ0MsS0FBSyxFQUFFO0VBQzlCLElBQUlDLFlBQVksR0FBR0MsS0FBSyxDQUFDQyxPQUFPLENBQUNILEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHQSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUdBLEtBQUs7RUFFN0QsSUFBSSxDQUFDQyxZQUFZLENBQUNHLEtBQUssQ0FBQyxVQUFVQyxHQUFHLEVBQUU7SUFDckMsT0FBTyxPQUFPQSxHQUFHLEtBQUssVUFBVTtFQUNsQyxDQUFDLENBQUMsRUFBRTtJQUNGLElBQUlDLGVBQWUsR0FBR0wsWUFBWSxDQUFDTSxHQUFHLENBQUMsVUFBVUYsR0FBRyxFQUFFO01BQ3BELE9BQU8sT0FBT0EsR0FBRyxLQUFLLFVBQVUsR0FBRyxXQUFXLElBQUlBLEdBQUcsQ0FBQ0csSUFBSSxJQUFJLFNBQVMsQ0FBQyxHQUFHLElBQUksR0FBRyxPQUFPSCxHQUFHO0lBQzlGLENBQUMsQ0FBQyxDQUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ2IsTUFBTSxJQUFJQyxLQUFLLENBQUMsaUdBQWlHLEdBQUdKLGVBQWUsR0FBRyxHQUFHLENBQUM7RUFDNUk7RUFFQSxPQUFPTCxZQUFZO0FBQ3JCO0FBRU8sU0FBU1UscUJBQXFCQSxDQUFDQyxPQUFPLEVBQUU7RUFDN0MsS0FBSyxJQUFJQyxJQUFJLEdBQUduQixTQUFTLENBQUNyQixNQUFNLEVBQUV5QyxzQkFBc0IsR0FBRyxJQUFJWixLQUFLLENBQUNXLElBQUksR0FBRyxDQUFDLEdBQUdBLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUVFLElBQUksR0FBRyxDQUFDLEVBQUVBLElBQUksR0FBR0YsSUFBSSxFQUFFRSxJQUFJLEVBQUUsRUFBRTtJQUM1SEQsc0JBQXNCLENBQUNDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBR3JCLFNBQVMsQ0FBQ3FCLElBQUksQ0FBQztFQUNwRDtFQUVBLElBQUlDLGNBQWMsR0FBRyxTQUFTQSxjQUFjQSxDQUFBLEVBQUc7SUFDN0MsS0FBSyxJQUFJQyxLQUFLLEdBQUd2QixTQUFTLENBQUNyQixNQUFNLEVBQUUyQixLQUFLLEdBQUcsSUFBSUUsS0FBSyxDQUFDZSxLQUFLLENBQUMsRUFBRUMsS0FBSyxHQUFHLENBQUMsRUFBRUEsS0FBSyxHQUFHRCxLQUFLLEVBQUVDLEtBQUssRUFBRSxFQUFFO01BQzlGbEIsS0FBSyxDQUFDa0IsS0FBSyxDQUFDLEdBQUd4QixTQUFTLENBQUN3QixLQUFLLENBQUM7SUFDakM7SUFFQSxJQUFJQyxlQUFlLEdBQUcsQ0FBQztJQUV2QixJQUFJQyxXQUFXLENBQUMsQ0FBQztJQUNqQjtJQUNBOztJQUdBLElBQUlDLHFCQUFxQixHQUFHO01BQzFCQyxjQUFjLEVBQUV6RDtJQUNsQixDQUFDLENBQUMsQ0FBQzs7SUFFSCxJQUFJMEQsVUFBVSxHQUFHdkIsS0FBSyxDQUFDMUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUU5QixJQUFJLE9BQU9pRCxVQUFVLEtBQUssUUFBUSxFQUFFO01BQ2xDRixxQkFBcUIsR0FBR0UsVUFBVSxDQUFDLENBQUM7O01BRXBDQSxVQUFVLEdBQUd2QixLQUFLLENBQUMxQixHQUFHLENBQUMsQ0FBQztJQUMxQjtJQUVBLElBQUksT0FBT2lELFVBQVUsS0FBSyxVQUFVLEVBQUU7TUFDcEMsTUFBTSxJQUFJYixLQUFLLENBQUMsNkVBQTZFLEdBQUcsT0FBT2EsVUFBVSxHQUFHLEdBQUcsQ0FBQztJQUMxSCxDQUFDLENBQUM7SUFDRjs7SUFHQSxJQUFJQyxxQkFBcUIsR0FBR0gscUJBQXFCO01BQzdDSSxzQkFBc0IsR0FBR0QscUJBQXFCLENBQUNGLGNBQWM7TUFDN0RBLGNBQWMsR0FBR0csc0JBQXNCLEtBQUssS0FBSyxDQUFDLEdBQUdYLHNCQUFzQixHQUFHVyxzQkFBc0IsQ0FBQyxDQUFDO0lBQzFHO0lBQ0E7SUFDQTtJQUNBOztJQUVBLElBQUlDLG1CQUFtQixHQUFHeEIsS0FBSyxDQUFDQyxPQUFPLENBQUNtQixjQUFjLENBQUMsR0FBR0EsY0FBYyxHQUFHLENBQUNBLGNBQWMsQ0FBQztJQUMzRixJQUFJckIsWUFBWSxHQUFHRixlQUFlLENBQUNDLEtBQUssQ0FBQztJQUN6QyxJQUFJMkIsa0JBQWtCLEdBQUdmLE9BQU8sQ0FBQ2pCLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLFNBQVNpQyxvQkFBb0JBLENBQUEsRUFBRztNQUM5RVQsZUFBZSxFQUFFLENBQUMsQ0FBQzs7TUFFbkIsT0FBT0ksVUFBVSxDQUFDNUIsS0FBSyxDQUFDLElBQUksRUFBRUQsU0FBUyxDQUFDO0lBQzFDLENBQUMsQ0FBQyxDQUFDbUMsTUFBTSxDQUFDSCxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFFakMsSUFBSUksUUFBUSxHQUFHbEIsT0FBTyxDQUFDLFNBQVNtQixtQkFBbUJBLENBQUEsRUFBRztNQUNwRCxJQUFJQyxNQUFNLEdBQUcsRUFBRTtNQUNmLElBQUkzRCxNQUFNLEdBQUc0QixZQUFZLENBQUM1QixNQUFNO01BRWhDLEtBQUssSUFBSVUsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHVixNQUFNLEVBQUVVLENBQUMsRUFBRSxFQUFFO1FBQy9CO1FBQ0E7UUFDQWlELE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEMsWUFBWSxDQUFDbEIsQ0FBQyxDQUFDLENBQUNZLEtBQUssQ0FBQyxJQUFJLEVBQUVELFNBQVMsQ0FBQyxDQUFDO01BQ3JELENBQUMsQ0FBQzs7TUFHRjBCLFdBQVcsR0FBR08sa0JBQWtCLENBQUNoQyxLQUFLLENBQUMsSUFBSSxFQUFFcUMsTUFBTSxDQUFDO01BQ3BELE9BQU9aLFdBQVc7SUFDcEIsQ0FBQyxDQUFDO0lBQ0ZjLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDTCxRQUFRLEVBQUU7TUFDdEJQLFVBQVUsRUFBRUEsVUFBVTtNQUN0Qkksa0JBQWtCLEVBQUVBLGtCQUFrQjtNQUN0QzFCLFlBQVksRUFBRUEsWUFBWTtNQUMxQm1DLFVBQVUsRUFBRSxTQUFTQSxVQUFVQSxDQUFBLEVBQUc7UUFDaEMsT0FBT2hCLFdBQVc7TUFDcEIsQ0FBQztNQUNEaUIsY0FBYyxFQUFFLFNBQVNBLGNBQWNBLENBQUEsRUFBRztRQUN4QyxPQUFPbEIsZUFBZTtNQUN4QixDQUFDO01BQ0RtQixtQkFBbUIsRUFBRSxTQUFTQSxtQkFBbUJBLENBQUEsRUFBRztRQUNsRCxPQUFPbkIsZUFBZSxHQUFHLENBQUM7TUFDNUI7SUFDRixDQUFDLENBQUM7SUFDRixPQUFPVyxRQUFRO0VBQ2pCLENBQUMsQ0FBQyxDQUFDOztFQUdILE9BQU9kLGNBQWM7QUFDdkI7QUFDTyxJQUFJQSxjQUFjLEdBQUcsZUFBZUwscUJBQXFCLENBQUMzQixjQUFjLENBQUM7QUFDaEY7QUFDTyxJQUFJdUQsd0JBQXdCLEdBQUcsU0FBU0Esd0JBQXdCQSxDQUFDQyxTQUFTLEVBQUVDLGVBQWUsRUFBRTtFQUNsRyxJQUFJQSxlQUFlLEtBQUssS0FBSyxDQUFDLEVBQUU7SUFDOUJBLGVBQWUsR0FBR3pCLGNBQWM7RUFDbEM7RUFFQSxJQUFJLE9BQU93QixTQUFTLEtBQUssUUFBUSxFQUFFO0lBQ2pDLE1BQU0sSUFBSTlCLEtBQUssQ0FBQyxrRUFBa0UsSUFBSSx3REFBd0QsR0FBRyxPQUFPOEIsU0FBUyxDQUFDLENBQUM7RUFDcks7RUFFQSxJQUFJRSxVQUFVLEdBQUdSLE1BQU0sQ0FBQ1MsSUFBSSxDQUFDSCxTQUFTLENBQUM7RUFDdkMsSUFBSUksY0FBYyxHQUFHSCxlQUFlO0VBQUU7RUFDdENDLFVBQVUsQ0FBQ25DLEdBQUcsQ0FBQyxVQUFVL0MsR0FBRyxFQUFFO0lBQzVCLE9BQU9nRixTQUFTLENBQUNoRixHQUFHLENBQUM7RUFDdkIsQ0FBQyxDQUFDLEVBQUUsWUFBWTtJQUNkLEtBQUssSUFBSXFGLEtBQUssR0FBR25ELFNBQVMsQ0FBQ3JCLE1BQU0sRUFBRXlFLE1BQU0sR0FBRyxJQUFJNUMsS0FBSyxDQUFDMkMsS0FBSyxDQUFDLEVBQUVFLEtBQUssR0FBRyxDQUFDLEVBQUVBLEtBQUssR0FBR0YsS0FBSyxFQUFFRSxLQUFLLEVBQUUsRUFBRTtNQUMvRkQsTUFBTSxDQUFDQyxLQUFLLENBQUMsR0FBR3JELFNBQVMsQ0FBQ3FELEtBQUssQ0FBQztJQUNsQztJQUVBLE9BQU9ELE1BQU0sQ0FBQ0UsTUFBTSxDQUFDLFVBQVVDLFdBQVcsRUFBRXhGLEtBQUssRUFBRXlGLEtBQUssRUFBRTtNQUN4REQsV0FBVyxDQUFDUCxVQUFVLENBQUNRLEtBQUssQ0FBQyxDQUFDLEdBQUd6RixLQUFLO01BQ3RDLE9BQU93RixXQUFXO0lBQ3BCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNSLENBQUMsQ0FBQztFQUNGLE9BQU9MLGNBQWM7QUFDdkIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZGVyLWJvb2tzLWZlLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2VzL2RlZmF1bHRNZW1vaXplLmpzPzEyYzgiLCJ3ZWJwYWNrOi8vZWxkZXItYm9va3MtZmUvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvaW5kZXguanM/MWI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWNoZSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBFcmlrIFJhc211c3NlbidzIGBscnUtbWVtb2l6ZWA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXJpa3Jhcy9scnUtbWVtb2l6ZVxudmFyIE5PVF9GT1VORCA9ICdOT1RfRk9VTkQnO1xuXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25DYWNoZShlcXVhbHMpIHtcbiAgdmFyIGVudHJ5O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgZW50cnkgPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRFbnRyaWVzOiBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJ5ID8gW2VudHJ5XSA6IFtdO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpO1xuICAgIH0pOyAvLyBXZSBmb3VuZCBhIGNhY2hlZCBlbnRyeVxuXG4gICAgaWYgKGNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XTsgLy8gQ2FjaGVkIGVudHJ5IG5vdCBhdCB0b3Agb2YgY2FjaGUsIG1vdmUgaXQgdG8gdGhlIHRvcFxuXG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9IC8vIE5vIGVudHJ5IGZvdW5kIGluIGNhY2hlLCByZXR1cm4gc2VudGluZWxcblxuXG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGdldChrZXkpID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIC8vIFRPRE8gSXMgdW5zaGlmdCBzbG93P1xuICAgICAgZW50cmllcy51bnNoaWZ0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW50cmllcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGdldCxcbiAgICBwdXQ6IHB1dCxcbiAgICBnZXRFbnRyaWVzOiBnZXRFbnRyaWVzLFxuICAgIGNsZWFyOiBjbGVhclxuICB9O1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRFcXVhbGl0eUNoZWNrID0gZnVuY3Rpb24gZGVmYXVsdEVxdWFsaXR5Q2hlY2soYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGxlbmd0aCA9IHByZXYubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbi8vIGRlZmF1bHRNZW1vaXplIG5vdyBzdXBwb3J0cyBhIGNvbmZpZ3VyYWJsZSBjYWNoZSBzaXplIHdpdGggTFJVIGJlaGF2aW9yLFxuLy8gYW5kIG9wdGlvbmFsIGNvbXBhcmlzb24gb2YgdGhlIHJlc3VsdCB2YWx1ZSB3aXRoIGV4aXN0aW5nIHZhbHVlc1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZW1vaXplKGZ1bmMsIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMpIHtcbiAgdmFyIHByb3ZpZGVkT3B0aW9ucyA9IHR5cGVvZiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zID09PSAnb2JqZWN0JyA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7XG4gICAgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9uc1xuICB9O1xuICB2YXIgX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID0gcHJvdmlkZWRPcHRpb25zLmVxdWFsaXR5Q2hlY2ssXG4gICAgICBlcXVhbGl0eUNoZWNrID0gX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID09PSB2b2lkIDAgPyBkZWZhdWx0RXF1YWxpdHlDaGVjayA6IF9wcm92aWRlZE9wdGlvbnMkZXF1YSxcbiAgICAgIF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9IHByb3ZpZGVkT3B0aW9ucy5tYXhTaXplLFxuICAgICAgbWF4U2l6ZSA9IF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9PT0gdm9pZCAwID8gMSA6IF9wcm92aWRlZE9wdGlvbnMkbWF4UyxcbiAgICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2sgPSBwcm92aWRlZE9wdGlvbnMucmVzdWx0RXF1YWxpdHlDaGVjaztcbiAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjayk7XG4gIHZhciBjYWNoZSA9IG1heFNpemUgPT09IDEgPyBjcmVhdGVTaW5nbGV0b25DYWNoZShjb21wYXJhdG9yKSA6IGNyZWF0ZUxydUNhY2hlKG1heFNpemUsIGNvbXBhcmF0b3IpOyAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBjYWNoZS5nZXRFbnRyaWVzKCk7XG4gICAgICAgIHZhciBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuXG4gIHJldHVybiBtZW1vaXplZDtcbn0iLCJpbXBvcnQgeyBkZWZhdWx0TWVtb2l6ZSwgZGVmYXVsdEVxdWFsaXR5Q2hlY2sgfSBmcm9tICcuL2RlZmF1bHRNZW1vaXplJztcbmV4cG9ydCB7IGRlZmF1bHRNZW1vaXplLCBkZWZhdWx0RXF1YWxpdHlDaGVjayB9O1xuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoZnVuY3MpIHtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoZnVuY3NbMF0pID8gZnVuY3NbMF0gOiBmdW5jcztcblxuICBpZiAoIWRlcGVuZGVuY2llcy5ldmVyeShmdW5jdGlvbiAoZGVwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkZXAgPT09ICdmdW5jdGlvbic7XG4gIH0pKSB7XG4gICAgdmFyIGRlcGVuZGVuY3lUeXBlcyA9IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkZXAgPT09ICdmdW5jdGlvbicgPyBcImZ1bmN0aW9uIFwiICsgKGRlcC5uYW1lIHx8ICd1bm5hbWVkJykgKyBcIigpXCIgOiB0eXBlb2YgZGVwO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbGwgaW5wdXQtc2VsZWN0b3JzIHRvIGJlIGZ1bmN0aW9ucywgYnV0IHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IFtcIiArIGRlcGVuZGVuY3lUeXBlcyArIFwiXVwiKTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3IobWVtb2l6ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVtb2l6ZU9wdGlvbnNGcm9tQXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWVtb2l6ZU9wdGlvbnNGcm9tQXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY3JlYXRlU2VsZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBmdW5jc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBfcmVjb21wdXRhdGlvbnMgPSAwO1xuXG4gICAgdmFyIF9sYXN0UmVzdWx0OyAvLyBEdWUgdG8gdGhlIGludHJpY2FjaWVzIG9mIHJlc3QgcGFyYW1zLCB3ZSBjYW4ndCBkbyBhbiBvcHRpb25hbCBhcmcgYWZ0ZXIgYC4uLmZ1bmNzYC5cbiAgICAvLyBTbywgc3RhcnQgYnkgZGVjbGFyaW5nIHRoZSBkZWZhdWx0IHZhbHVlIGhlcmUuXG4gICAgLy8gKEFuZCB5ZXMsIHRoZSB3b3JkcyAnbWVtb2l6ZScgYW5kICdvcHRpb25zJyBhcHBlYXIgdG9vIG1hbnkgdGltZXMgaW4gdGhpcyBuZXh0IHNlcXVlbmNlLilcblxuXG4gICAgdmFyIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHtcbiAgICAgIG1lbW9pemVPcHRpb25zOiB1bmRlZmluZWRcbiAgICB9OyAvLyBOb3JtYWxseSwgdGhlIHJlc3VsdCBmdW5jIG9yIFwib3V0cHV0IHNlbGVjdG9yXCIgaXMgdGhlIGxhc3QgYXJnXG5cbiAgICB2YXIgcmVzdWx0RnVuYyA9IGZ1bmNzLnBvcCgpOyAvLyBJZiB0aGUgcmVzdWx0IGZ1bmMgaXMgYWN0dWFsbHkgYW4gX29iamVjdF8sIGFzc3VtZSBpdCdzIG91ciBvcHRpb25zIG9iamVjdFxuXG4gICAgaWYgKHR5cGVvZiByZXN1bHRGdW5jID09PSAnb2JqZWN0Jykge1xuICAgICAgZGlyZWN0bHlQYXNzZWRPcHRpb25zID0gcmVzdWx0RnVuYzsgLy8gYW5kIHBvcCB0aGUgcmVhbCByZXN1bHQgZnVuYyBvZmZcblxuICAgICAgcmVzdWx0RnVuYyA9IGZ1bmNzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbiBvdXRwdXQgZnVuY3Rpb24gYWZ0ZXIgdGhlIGlucHV0cywgYnV0IHJlY2VpdmVkOiBbXCIgKyB0eXBlb2YgcmVzdWx0RnVuYyArIFwiXVwiKTtcbiAgICB9IC8vIERldGVybWluZSB3aGljaCBzZXQgb2Ygb3B0aW9ucyB3ZSdyZSB1c2luZy4gUHJlZmVyIG9wdGlvbnMgcGFzc2VkIGRpcmVjdGx5LFxuICAgIC8vIGJ1dCBmYWxsIGJhY2sgdG8gb3B0aW9ucyBnaXZlbiB0byBjcmVhdGVTZWxlY3RvckNyZWF0b3IuXG5cblxuICAgIHZhciBfZGlyZWN0bHlQYXNzZWRPcHRpb24gPSBkaXJlY3RseVBhc3NlZE9wdGlvbnMsXG4gICAgICAgIF9kaXJlY3RseVBhc3NlZE9wdGlvbjIgPSBfZGlyZWN0bHlQYXNzZWRPcHRpb24ubWVtb2l6ZU9wdGlvbnMsXG4gICAgICAgIG1lbW9pemVPcHRpb25zID0gX2RpcmVjdGx5UGFzc2VkT3B0aW9uMiA9PT0gdm9pZCAwID8gbWVtb2l6ZU9wdGlvbnNGcm9tQXJncyA6IF9kaXJlY3RseVBhc3NlZE9wdGlvbjI7IC8vIFNpbXBsaWZ5aW5nIGFzc3VtcHRpb246IGl0J3MgdW5saWtlbHkgdGhhdCB0aGUgZmlyc3Qgb3B0aW9ucyBhcmcgb2YgdGhlIHByb3ZpZGVkIG1lbW9pemVyXG4gICAgLy8gaXMgYW4gYXJyYXkuIEluIG1vc3QgbGlicyBJJ3ZlIGxvb2tlZCBhdCwgaXQncyBhbiBlcXVhbGl0eSBmdW5jdGlvbiBvciBvcHRpb25zIG9iamVjdC5cbiAgICAvLyBCYXNlZCBvbiB0aGF0LCBpZiBgbWVtb2l6ZU9wdGlvbnNgIF9pc18gYW4gYXJyYXksIHdlIGFzc3VtZSBpdCdzIGEgZnVsbFxuICAgIC8vIHVzZXItcHJvdmlkZWQgYXJyYXkgb2Ygb3B0aW9ucy4gT3RoZXJ3aXNlLCBpdCBtdXN0IGJlIGp1c3QgdGhlIF9maXJzdF8gYXJnLCBhbmQgc29cbiAgICAvLyB3ZSB3cmFwIGl0IGluIGFuIGFycmF5IHNvIHdlIGNhbiBhcHBseSBpdC5cblxuICAgIHZhciBmaW5hbE1lbW9pemVPcHRpb25zID0gQXJyYXkuaXNBcnJheShtZW1vaXplT3B0aW9ucykgPyBtZW1vaXplT3B0aW9ucyA6IFttZW1vaXplT3B0aW9uc107XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhmdW5jcyk7XG4gICAgdmFyIG1lbW9pemVkUmVzdWx0RnVuYyA9IG1lbW9pemUuYXBwbHkodm9pZCAwLCBbZnVuY3Rpb24gcmVjb21wdXRhdGlvbldyYXBwZXIoKSB7XG4gICAgICBfcmVjb21wdXRhdGlvbnMrKzsgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cblxuICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XS5jb25jYXQoZmluYWxNZW1vaXplT3B0aW9ucykpOyAvLyBJZiBhIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBleGFjdCBzYW1lIGFyZ3VtZW50cyB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIG91ciBkZXBlbmRlbmNpZXMgYWdhaW4uXG5cbiAgICB2YXIgc2VsZWN0b3IgPSBtZW1vaXplKGZ1bmN0aW9uIGRlcGVuZGVuY2llc0NoZWNrZXIoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgYW5kIG11dGF0ZSBhIGxvY2FsIGxpc3Qgb2YgcGFyYW1zIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwYXJhbXMucHVzaChkZXBlbmRlbmNpZXNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICB9IC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG5cblxuICAgICAgX2xhc3RSZXN1bHQgPSBtZW1vaXplZFJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgcGFyYW1zKTtcbiAgICAgIHJldHVybiBfbGFzdFJlc3VsdDtcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKHNlbGVjdG9yLCB7XG4gICAgICByZXN1bHRGdW5jOiByZXN1bHRGdW5jLFxuICAgICAgbWVtb2l6ZWRSZXN1bHRGdW5jOiBtZW1vaXplZFJlc3VsdEZ1bmMsXG4gICAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICAgIGxhc3RSZXN1bHQ6IGZ1bmN0aW9uIGxhc3RSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiBfbGFzdFJlc3VsdDtcbiAgICAgIH0sXG4gICAgICByZWNvbXB1dGF0aW9uczogZnVuY3Rpb24gcmVjb21wdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVjb21wdXRhdGlvbnM7XG4gICAgICB9LFxuICAgICAgcmVzZXRSZWNvbXB1dGF0aW9uczogZnVuY3Rpb24gcmVzZXRSZWNvbXB1dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIF9yZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xuICB9OyAvLyBAdHMtaWdub3JlXG5cblxuICByZXR1cm4gY3JlYXRlU2VsZWN0b3I7XG59XG5leHBvcnQgdmFyIGNyZWF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY3JlYXRlU2VsZWN0b3JDcmVhdG9yKGRlZmF1bHRNZW1vaXplKTtcbi8vIE1hbnVhbCBkZWZpbml0aW9uIG9mIHN0YXRlIGFuZCBvdXRwdXQgYXJndW1lbnRzXG5leHBvcnQgdmFyIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcihzZWxlY3RvcnMsIHNlbGVjdG9yQ3JlYXRvcikge1xuICBpZiAoc2VsZWN0b3JDcmVhdG9yID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RvckNyZWF0b3IgPSBjcmVhdGVTZWxlY3RvcjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGV4cGVjdHMgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0ICcgKyAoXCJ3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSBcIiArIHR5cGVvZiBzZWxlY3RvcnMpKTtcbiAgfVxuXG4gIHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMoc2VsZWN0b3JzKTtcbiAgdmFyIHJlc3VsdFNlbGVjdG9yID0gc2VsZWN0b3JDcmVhdG9yKCAvLyBAdHMtaWdub3JlXG4gIG9iamVjdEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc2VsZWN0b3JzW2tleV07XG4gIH0pLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIHZhbHVlc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSB7XG4gICAgICBjb21wb3NpdGlvbltvYmplY3RLZXlzW2luZGV4XV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICB9LCB7fSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0U2VsZWN0b3I7XG59OyJdLCJuYW1lcyI6WyJOT1RfRk9VTkQiLCJjcmVhdGVTaW5nbGV0b25DYWNoZSIsImVxdWFscyIsImVudHJ5IiwiZ2V0Iiwia2V5IiwidmFsdWUiLCJwdXQiLCJnZXRFbnRyaWVzIiwiY2xlYXIiLCJ1bmRlZmluZWQiLCJjcmVhdGVMcnVDYWNoZSIsIm1heFNpemUiLCJlbnRyaWVzIiwiY2FjaGVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInVuc2hpZnQiLCJsZW5ndGgiLCJwb3AiLCJkZWZhdWx0RXF1YWxpdHlDaGVjayIsImEiLCJiIiwiY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yIiwiZXF1YWxpdHlDaGVjayIsImFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsIiwicHJldiIsIm5leHQiLCJpIiwiZGVmYXVsdE1lbW9pemUiLCJmdW5jIiwiZXF1YWxpdHlDaGVja09yT3B0aW9ucyIsInByb3ZpZGVkT3B0aW9ucyIsIl9wcm92aWRlZE9wdGlvbnMkZXF1YSIsIl9wcm92aWRlZE9wdGlvbnMkbWF4UyIsInJlc3VsdEVxdWFsaXR5Q2hlY2siLCJjb21wYXJhdG9yIiwiY2FjaGUiLCJtZW1vaXplZCIsImFyZ3VtZW50cyIsImFwcGx5IiwibWF0Y2hpbmdFbnRyeSIsImZpbmQiLCJjbGVhckNhY2hlIiwiZ2V0RGVwZW5kZW5jaWVzIiwiZnVuY3MiLCJkZXBlbmRlbmNpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsImRlcCIsImRlcGVuZGVuY3lUeXBlcyIsIm1hcCIsIm5hbWUiLCJqb2luIiwiRXJyb3IiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJtZW1vaXplIiwiX2xlbiIsIm1lbW9pemVPcHRpb25zRnJvbUFyZ3MiLCJfa2V5IiwiY3JlYXRlU2VsZWN0b3IiLCJfbGVuMiIsIl9rZXkyIiwiX3JlY29tcHV0YXRpb25zIiwiX2xhc3RSZXN1bHQiLCJkaXJlY3RseVBhc3NlZE9wdGlvbnMiLCJtZW1vaXplT3B0aW9ucyIsInJlc3VsdEZ1bmMiLCJfZGlyZWN0bHlQYXNzZWRPcHRpb24iLCJfZGlyZWN0bHlQYXNzZWRPcHRpb24yIiwiZmluYWxNZW1vaXplT3B0aW9ucyIsIm1lbW9pemVkUmVzdWx0RnVuYyIsInJlY29tcHV0YXRpb25XcmFwcGVyIiwiY29uY2F0Iiwic2VsZWN0b3IiLCJkZXBlbmRlbmNpZXNDaGVja2VyIiwicGFyYW1zIiwicHVzaCIsIk9iamVjdCIsImFzc2lnbiIsImxhc3RSZXN1bHQiLCJyZWNvbXB1dGF0aW9ucyIsInJlc2V0UmVjb21wdXRhdGlvbnMiLCJjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IiLCJzZWxlY3RvcnMiLCJzZWxlY3RvckNyZWF0b3IiLCJvYmplY3RLZXlzIiwia2V5cyIsInJlc3VsdFNlbGVjdG9yIiwiX2xlbjMiLCJ2YWx1ZXMiLCJfa2V5MyIsInJlZHVjZSIsImNvbXBvc2l0aW9uIiwiaW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6598\n")}}]);